/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    "/open-api/core": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get Open Api Schema */
        get: operations["GetOpenApiSchema"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/attachments": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Find Many attachments
         * @description **order_by**, **filter**, **limit**, **depth**, **starting_after** or **ending_before** can be provided to request your **attachments**
         */
        get: operations["findManyAttachments"];
        put?: never;
        /** Create One attachment */
        post: operations["createOneAttachment"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/batch/attachments": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Create Many attachments */
        post: operations["createManyAttachments"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/attachments/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Find One attachment
         * @description **depth** can be provided to request your **attachment**
         */
        get: operations["findOneAttachment"];
        put?: never;
        post?: never;
        /** Delete One attachment */
        delete: operations["deleteOneAttachment"];
        options?: never;
        head?: never;
        /** Update One attachment */
        patch: operations["UpdateOneAttachment"];
        trace?: never;
    };
    "/attachments/duplicates": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Find attachment Duplicates
         * @description **depth** can be provided to request your **attachment**
         */
        post: operations["findAttachmentDuplicates"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/blocklists": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Find Many blocklists
         * @description **order_by**, **filter**, **limit**, **depth**, **starting_after** or **ending_before** can be provided to request your **blocklists**
         */
        get: operations["findManyBlocklists"];
        put?: never;
        /** Create One blocklist */
        post: operations["createOneBlocklist"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/batch/blocklists": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Create Many blocklists */
        post: operations["createManyBlocklists"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/blocklists/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Find One blocklist
         * @description **depth** can be provided to request your **blocklist**
         */
        get: operations["findOneBlocklist"];
        put?: never;
        post?: never;
        /** Delete One blocklist */
        delete: operations["deleteOneBlocklist"];
        options?: never;
        head?: never;
        /** Update One blocklist */
        patch: operations["UpdateOneBlocklist"];
        trace?: never;
    };
    "/blocklists/duplicates": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Find blocklist Duplicates
         * @description **depth** can be provided to request your **blocklist**
         */
        post: operations["findBlocklistDuplicates"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/calendarChannelEventAssociations": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Find Many calendarChannelEventAssociations
         * @description **order_by**, **filter**, **limit**, **depth**, **starting_after** or **ending_before** can be provided to request your **calendarChannelEventAssociations**
         */
        get: operations["findManyCalendarChannelEventAssociations"];
        put?: never;
        /** Create One calendarChannelEventAssociation */
        post: operations["createOneCalendarChannelEventAssociation"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/batch/calendarChannelEventAssociations": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Create Many calendarChannelEventAssociations */
        post: operations["createManyCalendarChannelEventAssociations"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/calendarChannelEventAssociations/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Find One calendarChannelEventAssociation
         * @description **depth** can be provided to request your **calendarChannelEventAssociation**
         */
        get: operations["findOneCalendarChannelEventAssociation"];
        put?: never;
        post?: never;
        /** Delete One calendarChannelEventAssociation */
        delete: operations["deleteOneCalendarChannelEventAssociation"];
        options?: never;
        head?: never;
        /** Update One calendarChannelEventAssociation */
        patch: operations["UpdateOneCalendarChannelEventAssociation"];
        trace?: never;
    };
    "/calendarChannelEventAssociations/duplicates": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Find calendarChannelEventAssociation Duplicates
         * @description **depth** can be provided to request your **calendarChannelEventAssociation**
         */
        post: operations["findCalendarChannelEventAssociationDuplicates"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/calendarChannels": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Find Many calendarChannels
         * @description **order_by**, **filter**, **limit**, **depth**, **starting_after** or **ending_before** can be provided to request your **calendarChannels**
         */
        get: operations["findManyCalendarChannels"];
        put?: never;
        /** Create One calendarChannel */
        post: operations["createOneCalendarChannel"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/batch/calendarChannels": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Create Many calendarChannels */
        post: operations["createManyCalendarChannels"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/calendarChannels/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Find One calendarChannel
         * @description **depth** can be provided to request your **calendarChannel**
         */
        get: operations["findOneCalendarChannel"];
        put?: never;
        post?: never;
        /** Delete One calendarChannel */
        delete: operations["deleteOneCalendarChannel"];
        options?: never;
        head?: never;
        /** Update One calendarChannel */
        patch: operations["UpdateOneCalendarChannel"];
        trace?: never;
    };
    "/calendarChannels/duplicates": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Find calendarChannel Duplicates
         * @description **depth** can be provided to request your **calendarChannel**
         */
        post: operations["findCalendarChannelDuplicates"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/calendarEventParticipants": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Find Many calendarEventParticipants
         * @description **order_by**, **filter**, **limit**, **depth**, **starting_after** or **ending_before** can be provided to request your **calendarEventParticipants**
         */
        get: operations["findManyCalendarEventParticipants"];
        put?: never;
        /** Create One calendarEventParticipant */
        post: operations["createOneCalendarEventParticipant"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/batch/calendarEventParticipants": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Create Many calendarEventParticipants */
        post: operations["createManyCalendarEventParticipants"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/calendarEventParticipants/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Find One calendarEventParticipant
         * @description **depth** can be provided to request your **calendarEventParticipant**
         */
        get: operations["findOneCalendarEventParticipant"];
        put?: never;
        post?: never;
        /** Delete One calendarEventParticipant */
        delete: operations["deleteOneCalendarEventParticipant"];
        options?: never;
        head?: never;
        /** Update One calendarEventParticipant */
        patch: operations["UpdateOneCalendarEventParticipant"];
        trace?: never;
    };
    "/calendarEventParticipants/duplicates": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Find calendarEventParticipant Duplicates
         * @description **depth** can be provided to request your **calendarEventParticipant**
         */
        post: operations["findCalendarEventParticipantDuplicates"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/calendarEvents": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Find Many calendarEvents
         * @description **order_by**, **filter**, **limit**, **depth**, **starting_after** or **ending_before** can be provided to request your **calendarEvents**
         */
        get: operations["findManyCalendarEvents"];
        put?: never;
        /** Create One calendarEvent */
        post: operations["createOneCalendarEvent"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/batch/calendarEvents": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Create Many calendarEvents */
        post: operations["createManyCalendarEvents"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/calendarEvents/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Find One calendarEvent
         * @description **depth** can be provided to request your **calendarEvent**
         */
        get: operations["findOneCalendarEvent"];
        put?: never;
        post?: never;
        /** Delete One calendarEvent */
        delete: operations["deleteOneCalendarEvent"];
        options?: never;
        head?: never;
        /** Update One calendarEvent */
        patch: operations["UpdateOneCalendarEvent"];
        trace?: never;
    };
    "/calendarEvents/duplicates": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Find calendarEvent Duplicates
         * @description **depth** can be provided to request your **calendarEvent**
         */
        post: operations["findCalendarEventDuplicates"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/companies": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Find Many companies
         * @description **order_by**, **filter**, **limit**, **depth**, **starting_after** or **ending_before** can be provided to request your **companies**
         */
        get: operations["findManyCompanies"];
        put?: never;
        /** Create One company */
        post: operations["createOneCompany"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/batch/companies": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Create Many companies */
        post: operations["createManyCompanies"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/companies/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Find One company
         * @description **depth** can be provided to request your **company**
         */
        get: operations["findOneCompany"];
        put?: never;
        post?: never;
        /** Delete One company */
        delete: operations["deleteOneCompany"];
        options?: never;
        head?: never;
        /** Update One company */
        patch: operations["UpdateOneCompany"];
        trace?: never;
    };
    "/companies/duplicates": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Find company Duplicates
         * @description **depth** can be provided to request your **company**
         */
        post: operations["findCompanyDuplicates"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/connectedAccounts": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Find Many connectedAccounts
         * @description **order_by**, **filter**, **limit**, **depth**, **starting_after** or **ending_before** can be provided to request your **connectedAccounts**
         */
        get: operations["findManyConnectedAccounts"];
        put?: never;
        /** Create One connectedAccount */
        post: operations["createOneConnectedAccount"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/batch/connectedAccounts": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Create Many connectedAccounts */
        post: operations["createManyConnectedAccounts"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/connectedAccounts/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Find One connectedAccount
         * @description **depth** can be provided to request your **connectedAccount**
         */
        get: operations["findOneConnectedAccount"];
        put?: never;
        post?: never;
        /** Delete One connectedAccount */
        delete: operations["deleteOneConnectedAccount"];
        options?: never;
        head?: never;
        /** Update One connectedAccount */
        patch: operations["UpdateOneConnectedAccount"];
        trace?: never;
    };
    "/connectedAccounts/duplicates": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Find connectedAccount Duplicates
         * @description **depth** can be provided to request your **connectedAccount**
         */
        post: operations["findConnectedAccountDuplicates"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/favoriteFolders": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Find Many favoriteFolders
         * @description **order_by**, **filter**, **limit**, **depth**, **starting_after** or **ending_before** can be provided to request your **favoriteFolders**
         */
        get: operations["findManyFavoriteFolders"];
        put?: never;
        /** Create One favoriteFolder */
        post: operations["createOneFavoriteFolder"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/batch/favoriteFolders": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Create Many favoriteFolders */
        post: operations["createManyFavoriteFolders"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/favoriteFolders/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Find One favoriteFolder
         * @description **depth** can be provided to request your **favoriteFolder**
         */
        get: operations["findOneFavoriteFolder"];
        put?: never;
        post?: never;
        /** Delete One favoriteFolder */
        delete: operations["deleteOneFavoriteFolder"];
        options?: never;
        head?: never;
        /** Update One favoriteFolder */
        patch: operations["UpdateOneFavoriteFolder"];
        trace?: never;
    };
    "/favoriteFolders/duplicates": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Find favoriteFolder Duplicates
         * @description **depth** can be provided to request your **favoriteFolder**
         */
        post: operations["findFavoriteFolderDuplicates"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/favorites": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Find Many favorites
         * @description **order_by**, **filter**, **limit**, **depth**, **starting_after** or **ending_before** can be provided to request your **favorites**
         */
        get: operations["findManyFavorites"];
        put?: never;
        /** Create One favorite */
        post: operations["createOneFavorite"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/batch/favorites": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Create Many favorites */
        post: operations["createManyFavorites"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/favorites/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Find One favorite
         * @description **depth** can be provided to request your **favorite**
         */
        get: operations["findOneFavorite"];
        put?: never;
        post?: never;
        /** Delete One favorite */
        delete: operations["deleteOneFavorite"];
        options?: never;
        head?: never;
        /** Update One favorite */
        patch: operations["UpdateOneFavorite"];
        trace?: never;
    };
    "/favorites/duplicates": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Find favorite Duplicates
         * @description **depth** can be provided to request your **favorite**
         */
        post: operations["findFavoriteDuplicates"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/messageChannelMessageAssociations": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Find Many messageChannelMessageAssociations
         * @description **order_by**, **filter**, **limit**, **depth**, **starting_after** or **ending_before** can be provided to request your **messageChannelMessageAssociations**
         */
        get: operations["findManyMessageChannelMessageAssociations"];
        put?: never;
        /** Create One messageChannelMessageAssociation */
        post: operations["createOneMessageChannelMessageAssociation"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/batch/messageChannelMessageAssociations": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Create Many messageChannelMessageAssociations */
        post: operations["createManyMessageChannelMessageAssociations"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/messageChannelMessageAssociations/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Find One messageChannelMessageAssociation
         * @description **depth** can be provided to request your **messageChannelMessageAssociation**
         */
        get: operations["findOneMessageChannelMessageAssociation"];
        put?: never;
        post?: never;
        /** Delete One messageChannelMessageAssociation */
        delete: operations["deleteOneMessageChannelMessageAssociation"];
        options?: never;
        head?: never;
        /** Update One messageChannelMessageAssociation */
        patch: operations["UpdateOneMessageChannelMessageAssociation"];
        trace?: never;
    };
    "/messageChannelMessageAssociations/duplicates": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Find messageChannelMessageAssociation Duplicates
         * @description **depth** can be provided to request your **messageChannelMessageAssociation**
         */
        post: operations["findMessageChannelMessageAssociationDuplicates"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/messageChannels": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Find Many messageChannels
         * @description **order_by**, **filter**, **limit**, **depth**, **starting_after** or **ending_before** can be provided to request your **messageChannels**
         */
        get: operations["findManyMessageChannels"];
        put?: never;
        /** Create One messageChannel */
        post: operations["createOneMessageChannel"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/batch/messageChannels": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Create Many messageChannels */
        post: operations["createManyMessageChannels"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/messageChannels/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Find One messageChannel
         * @description **depth** can be provided to request your **messageChannel**
         */
        get: operations["findOneMessageChannel"];
        put?: never;
        post?: never;
        /** Delete One messageChannel */
        delete: operations["deleteOneMessageChannel"];
        options?: never;
        head?: never;
        /** Update One messageChannel */
        patch: operations["UpdateOneMessageChannel"];
        trace?: never;
    };
    "/messageChannels/duplicates": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Find messageChannel Duplicates
         * @description **depth** can be provided to request your **messageChannel**
         */
        post: operations["findMessageChannelDuplicates"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/messageFolders": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Find Many messageFolders
         * @description **order_by**, **filter**, **limit**, **depth**, **starting_after** or **ending_before** can be provided to request your **messageFolders**
         */
        get: operations["findManyMessageFolders"];
        put?: never;
        /** Create One messageFolder */
        post: operations["createOneMessageFolder"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/batch/messageFolders": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Create Many messageFolders */
        post: operations["createManyMessageFolders"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/messageFolders/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Find One messageFolder
         * @description **depth** can be provided to request your **messageFolder**
         */
        get: operations["findOneMessageFolder"];
        put?: never;
        post?: never;
        /** Delete One messageFolder */
        delete: operations["deleteOneMessageFolder"];
        options?: never;
        head?: never;
        /** Update One messageFolder */
        patch: operations["UpdateOneMessageFolder"];
        trace?: never;
    };
    "/messageFolders/duplicates": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Find messageFolder Duplicates
         * @description **depth** can be provided to request your **messageFolder**
         */
        post: operations["findMessageFolderDuplicates"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/messageParticipants": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Find Many messageParticipants
         * @description **order_by**, **filter**, **limit**, **depth**, **starting_after** or **ending_before** can be provided to request your **messageParticipants**
         */
        get: operations["findManyMessageParticipants"];
        put?: never;
        /** Create One messageParticipant */
        post: operations["createOneMessageParticipant"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/batch/messageParticipants": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Create Many messageParticipants */
        post: operations["createManyMessageParticipants"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/messageParticipants/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Find One messageParticipant
         * @description **depth** can be provided to request your **messageParticipant**
         */
        get: operations["findOneMessageParticipant"];
        put?: never;
        post?: never;
        /** Delete One messageParticipant */
        delete: operations["deleteOneMessageParticipant"];
        options?: never;
        head?: never;
        /** Update One messageParticipant */
        patch: operations["UpdateOneMessageParticipant"];
        trace?: never;
    };
    "/messageParticipants/duplicates": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Find messageParticipant Duplicates
         * @description **depth** can be provided to request your **messageParticipant**
         */
        post: operations["findMessageParticipantDuplicates"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/messages": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Find Many messages
         * @description **order_by**, **filter**, **limit**, **depth**, **starting_after** or **ending_before** can be provided to request your **messages**
         */
        get: operations["findManyMessages"];
        put?: never;
        /** Create One message */
        post: operations["createOneMessage"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/batch/messages": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Create Many messages */
        post: operations["createManyMessages"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/messages/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Find One message
         * @description **depth** can be provided to request your **message**
         */
        get: operations["findOneMessage"];
        put?: never;
        post?: never;
        /** Delete One message */
        delete: operations["deleteOneMessage"];
        options?: never;
        head?: never;
        /** Update One message */
        patch: operations["UpdateOneMessage"];
        trace?: never;
    };
    "/messages/duplicates": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Find message Duplicates
         * @description **depth** can be provided to request your **message**
         */
        post: operations["findMessageDuplicates"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/messageThreads": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Find Many messageThreads
         * @description **order_by**, **filter**, **limit**, **depth**, **starting_after** or **ending_before** can be provided to request your **messageThreads**
         */
        get: operations["findManyMessageThreads"];
        put?: never;
        /** Create One messageThread */
        post: operations["createOneMessageThread"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/batch/messageThreads": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Create Many messageThreads */
        post: operations["createManyMessageThreads"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/messageThreads/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Find One messageThread
         * @description **depth** can be provided to request your **messageThread**
         */
        get: operations["findOneMessageThread"];
        put?: never;
        post?: never;
        /** Delete One messageThread */
        delete: operations["deleteOneMessageThread"];
        options?: never;
        head?: never;
        /** Update One messageThread */
        patch: operations["UpdateOneMessageThread"];
        trace?: never;
    };
    "/messageThreads/duplicates": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Find messageThread Duplicates
         * @description **depth** can be provided to request your **messageThread**
         */
        post: operations["findMessageThreadDuplicates"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/notes": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Find Many notes
         * @description **order_by**, **filter**, **limit**, **depth**, **starting_after** or **ending_before** can be provided to request your **notes**
         */
        get: operations["findManyNotes"];
        put?: never;
        /** Create One note */
        post: operations["createOneNote"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/batch/notes": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Create Many notes */
        post: operations["createManyNotes"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/notes/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Find One note
         * @description **depth** can be provided to request your **note**
         */
        get: operations["findOneNote"];
        put?: never;
        post?: never;
        /** Delete One note */
        delete: operations["deleteOneNote"];
        options?: never;
        head?: never;
        /** Update One note */
        patch: operations["UpdateOneNote"];
        trace?: never;
    };
    "/notes/duplicates": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Find note Duplicates
         * @description **depth** can be provided to request your **note**
         */
        post: operations["findNoteDuplicates"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/noteTargets": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Find Many noteTargets
         * @description **order_by**, **filter**, **limit**, **depth**, **starting_after** or **ending_before** can be provided to request your **noteTargets**
         */
        get: operations["findManyNoteTargets"];
        put?: never;
        /** Create One noteTarget */
        post: operations["createOneNoteTarget"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/batch/noteTargets": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Create Many noteTargets */
        post: operations["createManyNoteTargets"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/noteTargets/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Find One noteTarget
         * @description **depth** can be provided to request your **noteTarget**
         */
        get: operations["findOneNoteTarget"];
        put?: never;
        post?: never;
        /** Delete One noteTarget */
        delete: operations["deleteOneNoteTarget"];
        options?: never;
        head?: never;
        /** Update One noteTarget */
        patch: operations["UpdateOneNoteTarget"];
        trace?: never;
    };
    "/noteTargets/duplicates": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Find noteTarget Duplicates
         * @description **depth** can be provided to request your **noteTarget**
         */
        post: operations["findNoteTargetDuplicates"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/opportunities": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Find Many opportunities
         * @description **order_by**, **filter**, **limit**, **depth**, **starting_after** or **ending_before** can be provided to request your **opportunities**
         */
        get: operations["findManyOpportunities"];
        put?: never;
        /** Create One opportunity */
        post: operations["createOneOpportunity"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/batch/opportunities": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Create Many opportunities */
        post: operations["createManyOpportunities"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/opportunities/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Find One opportunity
         * @description **depth** can be provided to request your **opportunity**
         */
        get: operations["findOneOpportunity"];
        put?: never;
        post?: never;
        /** Delete One opportunity */
        delete: operations["deleteOneOpportunity"];
        options?: never;
        head?: never;
        /** Update One opportunity */
        patch: operations["UpdateOneOpportunity"];
        trace?: never;
    };
    "/opportunities/duplicates": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Find opportunity Duplicates
         * @description **depth** can be provided to request your **opportunity**
         */
        post: operations["findOpportunityDuplicates"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/people": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Find Many people
         * @description **order_by**, **filter**, **limit**, **depth**, **starting_after** or **ending_before** can be provided to request your **people**
         */
        get: operations["findManyPeople"];
        put?: never;
        /** Create One person */
        post: operations["createOnePerson"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/batch/people": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Create Many people */
        post: operations["createManyPeople"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/people/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Find One person
         * @description **depth** can be provided to request your **person**
         */
        get: operations["findOnePerson"];
        put?: never;
        post?: never;
        /** Delete One person */
        delete: operations["deleteOnePerson"];
        options?: never;
        head?: never;
        /** Update One person */
        patch: operations["UpdateOnePerson"];
        trace?: never;
    };
    "/people/duplicates": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Find person Duplicates
         * @description **depth** can be provided to request your **person**
         */
        post: operations["findPersonDuplicates"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/tasks": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Find Many tasks
         * @description **order_by**, **filter**, **limit**, **depth**, **starting_after** or **ending_before** can be provided to request your **tasks**
         */
        get: operations["findManyTasks"];
        put?: never;
        /** Create One task */
        post: operations["createOneTask"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/batch/tasks": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Create Many tasks */
        post: operations["createManyTasks"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/tasks/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Find One task
         * @description **depth** can be provided to request your **task**
         */
        get: operations["findOneTask"];
        put?: never;
        post?: never;
        /** Delete One task */
        delete: operations["deleteOneTask"];
        options?: never;
        head?: never;
        /** Update One task */
        patch: operations["UpdateOneTask"];
        trace?: never;
    };
    "/tasks/duplicates": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Find task Duplicates
         * @description **depth** can be provided to request your **task**
         */
        post: operations["findTaskDuplicates"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/taskTargets": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Find Many taskTargets
         * @description **order_by**, **filter**, **limit**, **depth**, **starting_after** or **ending_before** can be provided to request your **taskTargets**
         */
        get: operations["findManyTaskTargets"];
        put?: never;
        /** Create One taskTarget */
        post: operations["createOneTaskTarget"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/batch/taskTargets": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Create Many taskTargets */
        post: operations["createManyTaskTargets"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/taskTargets/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Find One taskTarget
         * @description **depth** can be provided to request your **taskTarget**
         */
        get: operations["findOneTaskTarget"];
        put?: never;
        post?: never;
        /** Delete One taskTarget */
        delete: operations["deleteOneTaskTarget"];
        options?: never;
        head?: never;
        /** Update One taskTarget */
        patch: operations["UpdateOneTaskTarget"];
        trace?: never;
    };
    "/taskTargets/duplicates": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Find taskTarget Duplicates
         * @description **depth** can be provided to request your **taskTarget**
         */
        post: operations["findTaskTargetDuplicates"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/timelineActivities": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Find Many timelineActivities
         * @description **order_by**, **filter**, **limit**, **depth**, **starting_after** or **ending_before** can be provided to request your **timelineActivities**
         */
        get: operations["findManyTimelineActivities"];
        put?: never;
        /** Create One timelineActivity */
        post: operations["createOneTimelineActivity"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/batch/timelineActivities": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Create Many timelineActivities */
        post: operations["createManyTimelineActivities"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/timelineActivities/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Find One timelineActivity
         * @description **depth** can be provided to request your **timelineActivity**
         */
        get: operations["findOneTimelineActivity"];
        put?: never;
        post?: never;
        /** Delete One timelineActivity */
        delete: operations["deleteOneTimelineActivity"];
        options?: never;
        head?: never;
        /** Update One timelineActivity */
        patch: operations["UpdateOneTimelineActivity"];
        trace?: never;
    };
    "/timelineActivities/duplicates": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Find timelineActivity Duplicates
         * @description **depth** can be provided to request your **timelineActivity**
         */
        post: operations["findTimelineActivityDuplicates"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/viewFields": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Find Many viewFields
         * @description **order_by**, **filter**, **limit**, **depth**, **starting_after** or **ending_before** can be provided to request your **viewFields**
         */
        get: operations["findManyViewFields"];
        put?: never;
        /** Create One viewField */
        post: operations["createOneViewField"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/batch/viewFields": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Create Many viewFields */
        post: operations["createManyViewFields"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/viewFields/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Find One viewField
         * @description **depth** can be provided to request your **viewField**
         */
        get: operations["findOneViewField"];
        put?: never;
        post?: never;
        /** Delete One viewField */
        delete: operations["deleteOneViewField"];
        options?: never;
        head?: never;
        /** Update One viewField */
        patch: operations["UpdateOneViewField"];
        trace?: never;
    };
    "/viewFields/duplicates": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Find viewField Duplicates
         * @description **depth** can be provided to request your **viewField**
         */
        post: operations["findViewFieldDuplicates"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/viewFilterGroups": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Find Many viewFilterGroups
         * @description **order_by**, **filter**, **limit**, **depth**, **starting_after** or **ending_before** can be provided to request your **viewFilterGroups**
         */
        get: operations["findManyViewFilterGroups"];
        put?: never;
        /** Create One viewFilterGroup */
        post: operations["createOneViewFilterGroup"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/batch/viewFilterGroups": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Create Many viewFilterGroups */
        post: operations["createManyViewFilterGroups"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/viewFilterGroups/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Find One viewFilterGroup
         * @description **depth** can be provided to request your **viewFilterGroup**
         */
        get: operations["findOneViewFilterGroup"];
        put?: never;
        post?: never;
        /** Delete One viewFilterGroup */
        delete: operations["deleteOneViewFilterGroup"];
        options?: never;
        head?: never;
        /** Update One viewFilterGroup */
        patch: operations["UpdateOneViewFilterGroup"];
        trace?: never;
    };
    "/viewFilterGroups/duplicates": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Find viewFilterGroup Duplicates
         * @description **depth** can be provided to request your **viewFilterGroup**
         */
        post: operations["findViewFilterGroupDuplicates"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/viewFilters": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Find Many viewFilters
         * @description **order_by**, **filter**, **limit**, **depth**, **starting_after** or **ending_before** can be provided to request your **viewFilters**
         */
        get: operations["findManyViewFilters"];
        put?: never;
        /** Create One viewFilter */
        post: operations["createOneViewFilter"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/batch/viewFilters": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Create Many viewFilters */
        post: operations["createManyViewFilters"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/viewFilters/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Find One viewFilter
         * @description **depth** can be provided to request your **viewFilter**
         */
        get: operations["findOneViewFilter"];
        put?: never;
        post?: never;
        /** Delete One viewFilter */
        delete: operations["deleteOneViewFilter"];
        options?: never;
        head?: never;
        /** Update One viewFilter */
        patch: operations["UpdateOneViewFilter"];
        trace?: never;
    };
    "/viewFilters/duplicates": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Find viewFilter Duplicates
         * @description **depth** can be provided to request your **viewFilter**
         */
        post: operations["findViewFilterDuplicates"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/viewGroups": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Find Many viewGroups
         * @description **order_by**, **filter**, **limit**, **depth**, **starting_after** or **ending_before** can be provided to request your **viewGroups**
         */
        get: operations["findManyViewGroups"];
        put?: never;
        /** Create One viewGroup */
        post: operations["createOneViewGroup"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/batch/viewGroups": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Create Many viewGroups */
        post: operations["createManyViewGroups"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/viewGroups/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Find One viewGroup
         * @description **depth** can be provided to request your **viewGroup**
         */
        get: operations["findOneViewGroup"];
        put?: never;
        post?: never;
        /** Delete One viewGroup */
        delete: operations["deleteOneViewGroup"];
        options?: never;
        head?: never;
        /** Update One viewGroup */
        patch: operations["UpdateOneViewGroup"];
        trace?: never;
    };
    "/viewGroups/duplicates": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Find viewGroup Duplicates
         * @description **depth** can be provided to request your **viewGroup**
         */
        post: operations["findViewGroupDuplicates"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/views": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Find Many views
         * @description **order_by**, **filter**, **limit**, **depth**, **starting_after** or **ending_before** can be provided to request your **views**
         */
        get: operations["findManyViews"];
        put?: never;
        /** Create One view */
        post: operations["createOneView"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/batch/views": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Create Many views */
        post: operations["createManyViews"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/views/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Find One view
         * @description **depth** can be provided to request your **view**
         */
        get: operations["findOneView"];
        put?: never;
        post?: never;
        /** Delete One view */
        delete: operations["deleteOneView"];
        options?: never;
        head?: never;
        /** Update One view */
        patch: operations["UpdateOneView"];
        trace?: never;
    };
    "/views/duplicates": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Find view Duplicates
         * @description **depth** can be provided to request your **view**
         */
        post: operations["findViewDuplicates"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/viewSorts": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Find Many viewSorts
         * @description **order_by**, **filter**, **limit**, **depth**, **starting_after** or **ending_before** can be provided to request your **viewSorts**
         */
        get: operations["findManyViewSorts"];
        put?: never;
        /** Create One viewSort */
        post: operations["createOneViewSort"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/batch/viewSorts": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Create Many viewSorts */
        post: operations["createManyViewSorts"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/viewSorts/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Find One viewSort
         * @description **depth** can be provided to request your **viewSort**
         */
        get: operations["findOneViewSort"];
        put?: never;
        post?: never;
        /** Delete One viewSort */
        delete: operations["deleteOneViewSort"];
        options?: never;
        head?: never;
        /** Update One viewSort */
        patch: operations["UpdateOneViewSort"];
        trace?: never;
    };
    "/viewSorts/duplicates": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Find viewSort Duplicates
         * @description **depth** can be provided to request your **viewSort**
         */
        post: operations["findViewSortDuplicates"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/workflowAutomatedTriggers": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Find Many workflowAutomatedTriggers
         * @description **order_by**, **filter**, **limit**, **depth**, **starting_after** or **ending_before** can be provided to request your **workflowAutomatedTriggers**
         */
        get: operations["findManyWorkflowAutomatedTriggers"];
        put?: never;
        /** Create One workflowAutomatedTrigger */
        post: operations["createOneWorkflowAutomatedTrigger"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/batch/workflowAutomatedTriggers": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Create Many workflowAutomatedTriggers */
        post: operations["createManyWorkflowAutomatedTriggers"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/workflowAutomatedTriggers/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Find One workflowAutomatedTrigger
         * @description **depth** can be provided to request your **workflowAutomatedTrigger**
         */
        get: operations["findOneWorkflowAutomatedTrigger"];
        put?: never;
        post?: never;
        /** Delete One workflowAutomatedTrigger */
        delete: operations["deleteOneWorkflowAutomatedTrigger"];
        options?: never;
        head?: never;
        /** Update One workflowAutomatedTrigger */
        patch: operations["UpdateOneWorkflowAutomatedTrigger"];
        trace?: never;
    };
    "/workflowAutomatedTriggers/duplicates": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Find workflowAutomatedTrigger Duplicates
         * @description **depth** can be provided to request your **workflowAutomatedTrigger**
         */
        post: operations["findWorkflowAutomatedTriggerDuplicates"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/workflowRuns": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Find Many workflowRuns
         * @description **order_by**, **filter**, **limit**, **depth**, **starting_after** or **ending_before** can be provided to request your **workflowRuns**
         */
        get: operations["findManyWorkflowRuns"];
        put?: never;
        /** Create One workflowRun */
        post: operations["createOneWorkflowRun"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/batch/workflowRuns": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Create Many workflowRuns */
        post: operations["createManyWorkflowRuns"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/workflowRuns/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Find One workflowRun
         * @description **depth** can be provided to request your **workflowRun**
         */
        get: operations["findOneWorkflowRun"];
        put?: never;
        post?: never;
        /** Delete One workflowRun */
        delete: operations["deleteOneWorkflowRun"];
        options?: never;
        head?: never;
        /** Update One workflowRun */
        patch: operations["UpdateOneWorkflowRun"];
        trace?: never;
    };
    "/workflowRuns/duplicates": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Find workflowRun Duplicates
         * @description **depth** can be provided to request your **workflowRun**
         */
        post: operations["findWorkflowRunDuplicates"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/workflows": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Find Many workflows
         * @description **order_by**, **filter**, **limit**, **depth**, **starting_after** or **ending_before** can be provided to request your **workflows**
         */
        get: operations["findManyWorkflows"];
        put?: never;
        /** Create One workflow */
        post: operations["createOneWorkflow"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/batch/workflows": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Create Many workflows */
        post: operations["createManyWorkflows"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/workflows/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Find One workflow
         * @description **depth** can be provided to request your **workflow**
         */
        get: operations["findOneWorkflow"];
        put?: never;
        post?: never;
        /** Delete One workflow */
        delete: operations["deleteOneWorkflow"];
        options?: never;
        head?: never;
        /** Update One workflow */
        patch: operations["UpdateOneWorkflow"];
        trace?: never;
    };
    "/workflows/duplicates": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Find workflow Duplicates
         * @description **depth** can be provided to request your **workflow**
         */
        post: operations["findWorkflowDuplicates"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/workflowVersions": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Find Many workflowVersions
         * @description **order_by**, **filter**, **limit**, **depth**, **starting_after** or **ending_before** can be provided to request your **workflowVersions**
         */
        get: operations["findManyWorkflowVersions"];
        put?: never;
        /** Create One workflowVersion */
        post: operations["createOneWorkflowVersion"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/batch/workflowVersions": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Create Many workflowVersions */
        post: operations["createManyWorkflowVersions"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/workflowVersions/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Find One workflowVersion
         * @description **depth** can be provided to request your **workflowVersion**
         */
        get: operations["findOneWorkflowVersion"];
        put?: never;
        post?: never;
        /** Delete One workflowVersion */
        delete: operations["deleteOneWorkflowVersion"];
        options?: never;
        head?: never;
        /** Update One workflowVersion */
        patch: operations["UpdateOneWorkflowVersion"];
        trace?: never;
    };
    "/workflowVersions/duplicates": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Find workflowVersion Duplicates
         * @description **depth** can be provided to request your **workflowVersion**
         */
        post: operations["findWorkflowVersionDuplicates"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/workspaceMembers": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Find Many workspaceMembers
         * @description **order_by**, **filter**, **limit**, **depth**, **starting_after** or **ending_before** can be provided to request your **workspaceMembers**
         */
        get: operations["findManyWorkspaceMembers"];
        put?: never;
        /** Create One workspaceMember */
        post: operations["createOneWorkspaceMember"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/batch/workspaceMembers": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Create Many workspaceMembers */
        post: operations["createManyWorkspaceMembers"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/workspaceMembers/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Find One workspaceMember
         * @description **depth** can be provided to request your **workspaceMember**
         */
        get: operations["findOneWorkspaceMember"];
        put?: never;
        post?: never;
        /** Delete One workspaceMember */
        delete: operations["deleteOneWorkspaceMember"];
        options?: never;
        head?: never;
        /** Update One workspaceMember */
        patch: operations["UpdateOneWorkspaceMember"];
        trace?: never;
    };
    "/workspaceMembers/duplicates": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Find workspaceMember Duplicates
         * @description **depth** can be provided to request your **workspaceMember**
         */
        post: operations["findWorkspaceMemberDuplicates"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export interface webhooks {
    "Attachment Created": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description HMAC SHA256 signature of the request payload using the webhook secret. To compute the signature:
                     *     1. Concatenate `X-Twenty-Webhook-Timestamp`, a colon (:), and the JSON string of the request payload.
                     *     2. Compute the HMAC SHA256 hash using the shared secret as the key.
                     *     3. Send the resulting hex digest as this header value.
                     *     Example (Node.js):
                     *     ```javascript
                     *     const crypto = require("crypto");
                     *     const timestamp = "1735066639761";
                     *     const payload = JSON.stringify({...});
                     *     const secret = "your-secret";
                     *     const stringToSign = `${timestamp}:${JSON.stringify(payload)}`;
                     *     const signature = crypto.createHmac("sha256", secret)
                     *       .update(stringToSign)
                     *       .digest("hex");
                     *     ``` */
                    "X-Twenty-Webhook-Signature"?: string;
                    /** @description Unix timestamp of when the webhook was sent. This timestamp is included in the HMAC signature generation to prevent replay attacks. */
                    "X-Twenty-Webhook-Timestamp"?: string;
                    /** @description Unique identifier for this webhook request to prevent replay attacks. Consumers should ensure this nonce is not reused. */
                    "X-Twenty-Webhook-Nonce"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @example https://example.com/incomingWebhook */
                        targetUrl?: string;
                        /** @example attachment.created */
                        eventName?: string;
                        objectMetadata?: {
                            /** @example 370985db-22d8-4463-8e5f-2271d30913bd */
                            id?: string;
                            /** @enum {string} */
                            nameSingular?: "attachment";
                        };
                        /** @example 872cfcf1-c79f-42bc-877d-5829f06eb3f9 */
                        workspaceId?: string;
                        /** @example 90056586-1228-4e03-a507-70140aa85c05 */
                        webhookId?: string;
                        /** @example 2024-02-14T11:27:01.779Z */
                        eventDate?: string;
                        record?: components["schemas"]["AttachmentForResponse"];
                    };
                };
            };
            responses: {
                /** @description Return a 200 status to indicate that the data was received successfully */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "Attachment Updated": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description HMAC SHA256 signature of the request payload using the webhook secret. To compute the signature:
                     *     1. Concatenate `X-Twenty-Webhook-Timestamp`, a colon (:), and the JSON string of the request payload.
                     *     2. Compute the HMAC SHA256 hash using the shared secret as the key.
                     *     3. Send the resulting hex digest as this header value.
                     *     Example (Node.js):
                     *     ```javascript
                     *     const crypto = require("crypto");
                     *     const timestamp = "1735066639761";
                     *     const payload = JSON.stringify({...});
                     *     const secret = "your-secret";
                     *     const stringToSign = `${timestamp}:${JSON.stringify(payload)}`;
                     *     const signature = crypto.createHmac("sha256", secret)
                     *       .update(stringToSign)
                     *       .digest("hex");
                     *     ``` */
                    "X-Twenty-Webhook-Signature"?: string;
                    /** @description Unix timestamp of when the webhook was sent. This timestamp is included in the HMAC signature generation to prevent replay attacks. */
                    "X-Twenty-Webhook-Timestamp"?: string;
                    /** @description Unique identifier for this webhook request to prevent replay attacks. Consumers should ensure this nonce is not reused. */
                    "X-Twenty-Webhook-Nonce"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @example https://example.com/incomingWebhook */
                        targetUrl?: string;
                        /** @example attachment.updated */
                        eventName?: string;
                        objectMetadata?: {
                            /** @example 370985db-22d8-4463-8e5f-2271d30913bd */
                            id?: string;
                            /** @enum {string} */
                            nameSingular?: "attachment";
                        };
                        /** @example 872cfcf1-c79f-42bc-877d-5829f06eb3f9 */
                        workspaceId?: string;
                        /** @example 90056586-1228-4e03-a507-70140aa85c05 */
                        webhookId?: string;
                        /** @example 2024-02-14T11:27:01.779Z */
                        eventDate?: string;
                        record?: components["schemas"]["AttachmentForResponse"];
                        updatedFields?: string[];
                    };
                };
            };
            responses: {
                /** @description Return a 200 status to indicate that the data was received successfully */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "Attachment Deleted": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description HMAC SHA256 signature of the request payload using the webhook secret. To compute the signature:
                     *     1. Concatenate `X-Twenty-Webhook-Timestamp`, a colon (:), and the JSON string of the request payload.
                     *     2. Compute the HMAC SHA256 hash using the shared secret as the key.
                     *     3. Send the resulting hex digest as this header value.
                     *     Example (Node.js):
                     *     ```javascript
                     *     const crypto = require("crypto");
                     *     const timestamp = "1735066639761";
                     *     const payload = JSON.stringify({...});
                     *     const secret = "your-secret";
                     *     const stringToSign = `${timestamp}:${JSON.stringify(payload)}`;
                     *     const signature = crypto.createHmac("sha256", secret)
                     *       .update(stringToSign)
                     *       .digest("hex");
                     *     ``` */
                    "X-Twenty-Webhook-Signature"?: string;
                    /** @description Unix timestamp of when the webhook was sent. This timestamp is included in the HMAC signature generation to prevent replay attacks. */
                    "X-Twenty-Webhook-Timestamp"?: string;
                    /** @description Unique identifier for this webhook request to prevent replay attacks. Consumers should ensure this nonce is not reused. */
                    "X-Twenty-Webhook-Nonce"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @example https://example.com/incomingWebhook */
                        targetUrl?: string;
                        /** @example attachment.deleted */
                        eventName?: string;
                        objectMetadata?: {
                            /** @example 370985db-22d8-4463-8e5f-2271d30913bd */
                            id?: string;
                            /** @enum {string} */
                            nameSingular?: "attachment";
                        };
                        /** @example 872cfcf1-c79f-42bc-877d-5829f06eb3f9 */
                        workspaceId?: string;
                        /** @example 90056586-1228-4e03-a507-70140aa85c05 */
                        webhookId?: string;
                        /** @example 2024-02-14T11:27:01.779Z */
                        eventDate?: string;
                        record?: components["schemas"]["AttachmentForResponse"];
                    };
                };
            };
            responses: {
                /** @description Return a 200 status to indicate that the data was received successfully */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "Blocklist Created": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description HMAC SHA256 signature of the request payload using the webhook secret. To compute the signature:
                     *     1. Concatenate `X-Twenty-Webhook-Timestamp`, a colon (:), and the JSON string of the request payload.
                     *     2. Compute the HMAC SHA256 hash using the shared secret as the key.
                     *     3. Send the resulting hex digest as this header value.
                     *     Example (Node.js):
                     *     ```javascript
                     *     const crypto = require("crypto");
                     *     const timestamp = "1735066639761";
                     *     const payload = JSON.stringify({...});
                     *     const secret = "your-secret";
                     *     const stringToSign = `${timestamp}:${JSON.stringify(payload)}`;
                     *     const signature = crypto.createHmac("sha256", secret)
                     *       .update(stringToSign)
                     *       .digest("hex");
                     *     ``` */
                    "X-Twenty-Webhook-Signature"?: string;
                    /** @description Unix timestamp of when the webhook was sent. This timestamp is included in the HMAC signature generation to prevent replay attacks. */
                    "X-Twenty-Webhook-Timestamp"?: string;
                    /** @description Unique identifier for this webhook request to prevent replay attacks. Consumers should ensure this nonce is not reused. */
                    "X-Twenty-Webhook-Nonce"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @example https://example.com/incomingWebhook */
                        targetUrl?: string;
                        /** @example blocklist.created */
                        eventName?: string;
                        objectMetadata?: {
                            /** @example 370985db-22d8-4463-8e5f-2271d30913bd */
                            id?: string;
                            /** @enum {string} */
                            nameSingular?: "blocklist";
                        };
                        /** @example 872cfcf1-c79f-42bc-877d-5829f06eb3f9 */
                        workspaceId?: string;
                        /** @example 90056586-1228-4e03-a507-70140aa85c05 */
                        webhookId?: string;
                        /** @example 2024-02-14T11:27:01.779Z */
                        eventDate?: string;
                        record?: components["schemas"]["BlocklistForResponse"];
                    };
                };
            };
            responses: {
                /** @description Return a 200 status to indicate that the data was received successfully */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "Blocklist Updated": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description HMAC SHA256 signature of the request payload using the webhook secret. To compute the signature:
                     *     1. Concatenate `X-Twenty-Webhook-Timestamp`, a colon (:), and the JSON string of the request payload.
                     *     2. Compute the HMAC SHA256 hash using the shared secret as the key.
                     *     3. Send the resulting hex digest as this header value.
                     *     Example (Node.js):
                     *     ```javascript
                     *     const crypto = require("crypto");
                     *     const timestamp = "1735066639761";
                     *     const payload = JSON.stringify({...});
                     *     const secret = "your-secret";
                     *     const stringToSign = `${timestamp}:${JSON.stringify(payload)}`;
                     *     const signature = crypto.createHmac("sha256", secret)
                     *       .update(stringToSign)
                     *       .digest("hex");
                     *     ``` */
                    "X-Twenty-Webhook-Signature"?: string;
                    /** @description Unix timestamp of when the webhook was sent. This timestamp is included in the HMAC signature generation to prevent replay attacks. */
                    "X-Twenty-Webhook-Timestamp"?: string;
                    /** @description Unique identifier for this webhook request to prevent replay attacks. Consumers should ensure this nonce is not reused. */
                    "X-Twenty-Webhook-Nonce"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @example https://example.com/incomingWebhook */
                        targetUrl?: string;
                        /** @example blocklist.updated */
                        eventName?: string;
                        objectMetadata?: {
                            /** @example 370985db-22d8-4463-8e5f-2271d30913bd */
                            id?: string;
                            /** @enum {string} */
                            nameSingular?: "blocklist";
                        };
                        /** @example 872cfcf1-c79f-42bc-877d-5829f06eb3f9 */
                        workspaceId?: string;
                        /** @example 90056586-1228-4e03-a507-70140aa85c05 */
                        webhookId?: string;
                        /** @example 2024-02-14T11:27:01.779Z */
                        eventDate?: string;
                        record?: components["schemas"]["BlocklistForResponse"];
                        updatedFields?: string[];
                    };
                };
            };
            responses: {
                /** @description Return a 200 status to indicate that the data was received successfully */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "Blocklist Deleted": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description HMAC SHA256 signature of the request payload using the webhook secret. To compute the signature:
                     *     1. Concatenate `X-Twenty-Webhook-Timestamp`, a colon (:), and the JSON string of the request payload.
                     *     2. Compute the HMAC SHA256 hash using the shared secret as the key.
                     *     3. Send the resulting hex digest as this header value.
                     *     Example (Node.js):
                     *     ```javascript
                     *     const crypto = require("crypto");
                     *     const timestamp = "1735066639761";
                     *     const payload = JSON.stringify({...});
                     *     const secret = "your-secret";
                     *     const stringToSign = `${timestamp}:${JSON.stringify(payload)}`;
                     *     const signature = crypto.createHmac("sha256", secret)
                     *       .update(stringToSign)
                     *       .digest("hex");
                     *     ``` */
                    "X-Twenty-Webhook-Signature"?: string;
                    /** @description Unix timestamp of when the webhook was sent. This timestamp is included in the HMAC signature generation to prevent replay attacks. */
                    "X-Twenty-Webhook-Timestamp"?: string;
                    /** @description Unique identifier for this webhook request to prevent replay attacks. Consumers should ensure this nonce is not reused. */
                    "X-Twenty-Webhook-Nonce"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @example https://example.com/incomingWebhook */
                        targetUrl?: string;
                        /** @example blocklist.deleted */
                        eventName?: string;
                        objectMetadata?: {
                            /** @example 370985db-22d8-4463-8e5f-2271d30913bd */
                            id?: string;
                            /** @enum {string} */
                            nameSingular?: "blocklist";
                        };
                        /** @example 872cfcf1-c79f-42bc-877d-5829f06eb3f9 */
                        workspaceId?: string;
                        /** @example 90056586-1228-4e03-a507-70140aa85c05 */
                        webhookId?: string;
                        /** @example 2024-02-14T11:27:01.779Z */
                        eventDate?: string;
                        record?: components["schemas"]["BlocklistForResponse"];
                    };
                };
            };
            responses: {
                /** @description Return a 200 status to indicate that the data was received successfully */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "CalendarChannelEventAssociation Created": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description HMAC SHA256 signature of the request payload using the webhook secret. To compute the signature:
                     *     1. Concatenate `X-Twenty-Webhook-Timestamp`, a colon (:), and the JSON string of the request payload.
                     *     2. Compute the HMAC SHA256 hash using the shared secret as the key.
                     *     3. Send the resulting hex digest as this header value.
                     *     Example (Node.js):
                     *     ```javascript
                     *     const crypto = require("crypto");
                     *     const timestamp = "1735066639761";
                     *     const payload = JSON.stringify({...});
                     *     const secret = "your-secret";
                     *     const stringToSign = `${timestamp}:${JSON.stringify(payload)}`;
                     *     const signature = crypto.createHmac("sha256", secret)
                     *       .update(stringToSign)
                     *       .digest("hex");
                     *     ``` */
                    "X-Twenty-Webhook-Signature"?: string;
                    /** @description Unix timestamp of when the webhook was sent. This timestamp is included in the HMAC signature generation to prevent replay attacks. */
                    "X-Twenty-Webhook-Timestamp"?: string;
                    /** @description Unique identifier for this webhook request to prevent replay attacks. Consumers should ensure this nonce is not reused. */
                    "X-Twenty-Webhook-Nonce"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @example https://example.com/incomingWebhook */
                        targetUrl?: string;
                        /** @example calendarChannelEventAssociation.created */
                        eventName?: string;
                        objectMetadata?: {
                            /** @example 370985db-22d8-4463-8e5f-2271d30913bd */
                            id?: string;
                            /** @enum {string} */
                            nameSingular?: "calendarChannelEventAssociation";
                        };
                        /** @example 872cfcf1-c79f-42bc-877d-5829f06eb3f9 */
                        workspaceId?: string;
                        /** @example 90056586-1228-4e03-a507-70140aa85c05 */
                        webhookId?: string;
                        /** @example 2024-02-14T11:27:01.779Z */
                        eventDate?: string;
                        record?: components["schemas"]["CalendarChannelEventAssociationForResponse"];
                    };
                };
            };
            responses: {
                /** @description Return a 200 status to indicate that the data was received successfully */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "CalendarChannelEventAssociation Updated": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description HMAC SHA256 signature of the request payload using the webhook secret. To compute the signature:
                     *     1. Concatenate `X-Twenty-Webhook-Timestamp`, a colon (:), and the JSON string of the request payload.
                     *     2. Compute the HMAC SHA256 hash using the shared secret as the key.
                     *     3. Send the resulting hex digest as this header value.
                     *     Example (Node.js):
                     *     ```javascript
                     *     const crypto = require("crypto");
                     *     const timestamp = "1735066639761";
                     *     const payload = JSON.stringify({...});
                     *     const secret = "your-secret";
                     *     const stringToSign = `${timestamp}:${JSON.stringify(payload)}`;
                     *     const signature = crypto.createHmac("sha256", secret)
                     *       .update(stringToSign)
                     *       .digest("hex");
                     *     ``` */
                    "X-Twenty-Webhook-Signature"?: string;
                    /** @description Unix timestamp of when the webhook was sent. This timestamp is included in the HMAC signature generation to prevent replay attacks. */
                    "X-Twenty-Webhook-Timestamp"?: string;
                    /** @description Unique identifier for this webhook request to prevent replay attacks. Consumers should ensure this nonce is not reused. */
                    "X-Twenty-Webhook-Nonce"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @example https://example.com/incomingWebhook */
                        targetUrl?: string;
                        /** @example calendarChannelEventAssociation.updated */
                        eventName?: string;
                        objectMetadata?: {
                            /** @example 370985db-22d8-4463-8e5f-2271d30913bd */
                            id?: string;
                            /** @enum {string} */
                            nameSingular?: "calendarChannelEventAssociation";
                        };
                        /** @example 872cfcf1-c79f-42bc-877d-5829f06eb3f9 */
                        workspaceId?: string;
                        /** @example 90056586-1228-4e03-a507-70140aa85c05 */
                        webhookId?: string;
                        /** @example 2024-02-14T11:27:01.779Z */
                        eventDate?: string;
                        record?: components["schemas"]["CalendarChannelEventAssociationForResponse"];
                        updatedFields?: string[];
                    };
                };
            };
            responses: {
                /** @description Return a 200 status to indicate that the data was received successfully */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "CalendarChannelEventAssociation Deleted": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description HMAC SHA256 signature of the request payload using the webhook secret. To compute the signature:
                     *     1. Concatenate `X-Twenty-Webhook-Timestamp`, a colon (:), and the JSON string of the request payload.
                     *     2. Compute the HMAC SHA256 hash using the shared secret as the key.
                     *     3. Send the resulting hex digest as this header value.
                     *     Example (Node.js):
                     *     ```javascript
                     *     const crypto = require("crypto");
                     *     const timestamp = "1735066639761";
                     *     const payload = JSON.stringify({...});
                     *     const secret = "your-secret";
                     *     const stringToSign = `${timestamp}:${JSON.stringify(payload)}`;
                     *     const signature = crypto.createHmac("sha256", secret)
                     *       .update(stringToSign)
                     *       .digest("hex");
                     *     ``` */
                    "X-Twenty-Webhook-Signature"?: string;
                    /** @description Unix timestamp of when the webhook was sent. This timestamp is included in the HMAC signature generation to prevent replay attacks. */
                    "X-Twenty-Webhook-Timestamp"?: string;
                    /** @description Unique identifier for this webhook request to prevent replay attacks. Consumers should ensure this nonce is not reused. */
                    "X-Twenty-Webhook-Nonce"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @example https://example.com/incomingWebhook */
                        targetUrl?: string;
                        /** @example calendarChannelEventAssociation.deleted */
                        eventName?: string;
                        objectMetadata?: {
                            /** @example 370985db-22d8-4463-8e5f-2271d30913bd */
                            id?: string;
                            /** @enum {string} */
                            nameSingular?: "calendarChannelEventAssociation";
                        };
                        /** @example 872cfcf1-c79f-42bc-877d-5829f06eb3f9 */
                        workspaceId?: string;
                        /** @example 90056586-1228-4e03-a507-70140aa85c05 */
                        webhookId?: string;
                        /** @example 2024-02-14T11:27:01.779Z */
                        eventDate?: string;
                        record?: components["schemas"]["CalendarChannelEventAssociationForResponse"];
                    };
                };
            };
            responses: {
                /** @description Return a 200 status to indicate that the data was received successfully */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "CalendarChannel Created": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description HMAC SHA256 signature of the request payload using the webhook secret. To compute the signature:
                     *     1. Concatenate `X-Twenty-Webhook-Timestamp`, a colon (:), and the JSON string of the request payload.
                     *     2. Compute the HMAC SHA256 hash using the shared secret as the key.
                     *     3. Send the resulting hex digest as this header value.
                     *     Example (Node.js):
                     *     ```javascript
                     *     const crypto = require("crypto");
                     *     const timestamp = "1735066639761";
                     *     const payload = JSON.stringify({...});
                     *     const secret = "your-secret";
                     *     const stringToSign = `${timestamp}:${JSON.stringify(payload)}`;
                     *     const signature = crypto.createHmac("sha256", secret)
                     *       .update(stringToSign)
                     *       .digest("hex");
                     *     ``` */
                    "X-Twenty-Webhook-Signature"?: string;
                    /** @description Unix timestamp of when the webhook was sent. This timestamp is included in the HMAC signature generation to prevent replay attacks. */
                    "X-Twenty-Webhook-Timestamp"?: string;
                    /** @description Unique identifier for this webhook request to prevent replay attacks. Consumers should ensure this nonce is not reused. */
                    "X-Twenty-Webhook-Nonce"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @example https://example.com/incomingWebhook */
                        targetUrl?: string;
                        /** @example calendarChannel.created */
                        eventName?: string;
                        objectMetadata?: {
                            /** @example 370985db-22d8-4463-8e5f-2271d30913bd */
                            id?: string;
                            /** @enum {string} */
                            nameSingular?: "calendarChannel";
                        };
                        /** @example 872cfcf1-c79f-42bc-877d-5829f06eb3f9 */
                        workspaceId?: string;
                        /** @example 90056586-1228-4e03-a507-70140aa85c05 */
                        webhookId?: string;
                        /** @example 2024-02-14T11:27:01.779Z */
                        eventDate?: string;
                        record?: components["schemas"]["CalendarChannelForResponse"];
                    };
                };
            };
            responses: {
                /** @description Return a 200 status to indicate that the data was received successfully */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "CalendarChannel Updated": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description HMAC SHA256 signature of the request payload using the webhook secret. To compute the signature:
                     *     1. Concatenate `X-Twenty-Webhook-Timestamp`, a colon (:), and the JSON string of the request payload.
                     *     2. Compute the HMAC SHA256 hash using the shared secret as the key.
                     *     3. Send the resulting hex digest as this header value.
                     *     Example (Node.js):
                     *     ```javascript
                     *     const crypto = require("crypto");
                     *     const timestamp = "1735066639761";
                     *     const payload = JSON.stringify({...});
                     *     const secret = "your-secret";
                     *     const stringToSign = `${timestamp}:${JSON.stringify(payload)}`;
                     *     const signature = crypto.createHmac("sha256", secret)
                     *       .update(stringToSign)
                     *       .digest("hex");
                     *     ``` */
                    "X-Twenty-Webhook-Signature"?: string;
                    /** @description Unix timestamp of when the webhook was sent. This timestamp is included in the HMAC signature generation to prevent replay attacks. */
                    "X-Twenty-Webhook-Timestamp"?: string;
                    /** @description Unique identifier for this webhook request to prevent replay attacks. Consumers should ensure this nonce is not reused. */
                    "X-Twenty-Webhook-Nonce"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @example https://example.com/incomingWebhook */
                        targetUrl?: string;
                        /** @example calendarChannel.updated */
                        eventName?: string;
                        objectMetadata?: {
                            /** @example 370985db-22d8-4463-8e5f-2271d30913bd */
                            id?: string;
                            /** @enum {string} */
                            nameSingular?: "calendarChannel";
                        };
                        /** @example 872cfcf1-c79f-42bc-877d-5829f06eb3f9 */
                        workspaceId?: string;
                        /** @example 90056586-1228-4e03-a507-70140aa85c05 */
                        webhookId?: string;
                        /** @example 2024-02-14T11:27:01.779Z */
                        eventDate?: string;
                        record?: components["schemas"]["CalendarChannelForResponse"];
                        updatedFields?: string[];
                    };
                };
            };
            responses: {
                /** @description Return a 200 status to indicate that the data was received successfully */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "CalendarChannel Deleted": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description HMAC SHA256 signature of the request payload using the webhook secret. To compute the signature:
                     *     1. Concatenate `X-Twenty-Webhook-Timestamp`, a colon (:), and the JSON string of the request payload.
                     *     2. Compute the HMAC SHA256 hash using the shared secret as the key.
                     *     3. Send the resulting hex digest as this header value.
                     *     Example (Node.js):
                     *     ```javascript
                     *     const crypto = require("crypto");
                     *     const timestamp = "1735066639761";
                     *     const payload = JSON.stringify({...});
                     *     const secret = "your-secret";
                     *     const stringToSign = `${timestamp}:${JSON.stringify(payload)}`;
                     *     const signature = crypto.createHmac("sha256", secret)
                     *       .update(stringToSign)
                     *       .digest("hex");
                     *     ``` */
                    "X-Twenty-Webhook-Signature"?: string;
                    /** @description Unix timestamp of when the webhook was sent. This timestamp is included in the HMAC signature generation to prevent replay attacks. */
                    "X-Twenty-Webhook-Timestamp"?: string;
                    /** @description Unique identifier for this webhook request to prevent replay attacks. Consumers should ensure this nonce is not reused. */
                    "X-Twenty-Webhook-Nonce"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @example https://example.com/incomingWebhook */
                        targetUrl?: string;
                        /** @example calendarChannel.deleted */
                        eventName?: string;
                        objectMetadata?: {
                            /** @example 370985db-22d8-4463-8e5f-2271d30913bd */
                            id?: string;
                            /** @enum {string} */
                            nameSingular?: "calendarChannel";
                        };
                        /** @example 872cfcf1-c79f-42bc-877d-5829f06eb3f9 */
                        workspaceId?: string;
                        /** @example 90056586-1228-4e03-a507-70140aa85c05 */
                        webhookId?: string;
                        /** @example 2024-02-14T11:27:01.779Z */
                        eventDate?: string;
                        record?: components["schemas"]["CalendarChannelForResponse"];
                    };
                };
            };
            responses: {
                /** @description Return a 200 status to indicate that the data was received successfully */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "CalendarEventParticipant Created": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description HMAC SHA256 signature of the request payload using the webhook secret. To compute the signature:
                     *     1. Concatenate `X-Twenty-Webhook-Timestamp`, a colon (:), and the JSON string of the request payload.
                     *     2. Compute the HMAC SHA256 hash using the shared secret as the key.
                     *     3. Send the resulting hex digest as this header value.
                     *     Example (Node.js):
                     *     ```javascript
                     *     const crypto = require("crypto");
                     *     const timestamp = "1735066639761";
                     *     const payload = JSON.stringify({...});
                     *     const secret = "your-secret";
                     *     const stringToSign = `${timestamp}:${JSON.stringify(payload)}`;
                     *     const signature = crypto.createHmac("sha256", secret)
                     *       .update(stringToSign)
                     *       .digest("hex");
                     *     ``` */
                    "X-Twenty-Webhook-Signature"?: string;
                    /** @description Unix timestamp of when the webhook was sent. This timestamp is included in the HMAC signature generation to prevent replay attacks. */
                    "X-Twenty-Webhook-Timestamp"?: string;
                    /** @description Unique identifier for this webhook request to prevent replay attacks. Consumers should ensure this nonce is not reused. */
                    "X-Twenty-Webhook-Nonce"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @example https://example.com/incomingWebhook */
                        targetUrl?: string;
                        /** @example calendarEventParticipant.created */
                        eventName?: string;
                        objectMetadata?: {
                            /** @example 370985db-22d8-4463-8e5f-2271d30913bd */
                            id?: string;
                            /** @enum {string} */
                            nameSingular?: "calendarEventParticipant";
                        };
                        /** @example 872cfcf1-c79f-42bc-877d-5829f06eb3f9 */
                        workspaceId?: string;
                        /** @example 90056586-1228-4e03-a507-70140aa85c05 */
                        webhookId?: string;
                        /** @example 2024-02-14T11:27:01.779Z */
                        eventDate?: string;
                        record?: components["schemas"]["CalendarEventParticipantForResponse"];
                    };
                };
            };
            responses: {
                /** @description Return a 200 status to indicate that the data was received successfully */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "CalendarEventParticipant Updated": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description HMAC SHA256 signature of the request payload using the webhook secret. To compute the signature:
                     *     1. Concatenate `X-Twenty-Webhook-Timestamp`, a colon (:), and the JSON string of the request payload.
                     *     2. Compute the HMAC SHA256 hash using the shared secret as the key.
                     *     3. Send the resulting hex digest as this header value.
                     *     Example (Node.js):
                     *     ```javascript
                     *     const crypto = require("crypto");
                     *     const timestamp = "1735066639761";
                     *     const payload = JSON.stringify({...});
                     *     const secret = "your-secret";
                     *     const stringToSign = `${timestamp}:${JSON.stringify(payload)}`;
                     *     const signature = crypto.createHmac("sha256", secret)
                     *       .update(stringToSign)
                     *       .digest("hex");
                     *     ``` */
                    "X-Twenty-Webhook-Signature"?: string;
                    /** @description Unix timestamp of when the webhook was sent. This timestamp is included in the HMAC signature generation to prevent replay attacks. */
                    "X-Twenty-Webhook-Timestamp"?: string;
                    /** @description Unique identifier for this webhook request to prevent replay attacks. Consumers should ensure this nonce is not reused. */
                    "X-Twenty-Webhook-Nonce"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @example https://example.com/incomingWebhook */
                        targetUrl?: string;
                        /** @example calendarEventParticipant.updated */
                        eventName?: string;
                        objectMetadata?: {
                            /** @example 370985db-22d8-4463-8e5f-2271d30913bd */
                            id?: string;
                            /** @enum {string} */
                            nameSingular?: "calendarEventParticipant";
                        };
                        /** @example 872cfcf1-c79f-42bc-877d-5829f06eb3f9 */
                        workspaceId?: string;
                        /** @example 90056586-1228-4e03-a507-70140aa85c05 */
                        webhookId?: string;
                        /** @example 2024-02-14T11:27:01.779Z */
                        eventDate?: string;
                        record?: components["schemas"]["CalendarEventParticipantForResponse"];
                        updatedFields?: string[];
                    };
                };
            };
            responses: {
                /** @description Return a 200 status to indicate that the data was received successfully */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "CalendarEventParticipant Deleted": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description HMAC SHA256 signature of the request payload using the webhook secret. To compute the signature:
                     *     1. Concatenate `X-Twenty-Webhook-Timestamp`, a colon (:), and the JSON string of the request payload.
                     *     2. Compute the HMAC SHA256 hash using the shared secret as the key.
                     *     3. Send the resulting hex digest as this header value.
                     *     Example (Node.js):
                     *     ```javascript
                     *     const crypto = require("crypto");
                     *     const timestamp = "1735066639761";
                     *     const payload = JSON.stringify({...});
                     *     const secret = "your-secret";
                     *     const stringToSign = `${timestamp}:${JSON.stringify(payload)}`;
                     *     const signature = crypto.createHmac("sha256", secret)
                     *       .update(stringToSign)
                     *       .digest("hex");
                     *     ``` */
                    "X-Twenty-Webhook-Signature"?: string;
                    /** @description Unix timestamp of when the webhook was sent. This timestamp is included in the HMAC signature generation to prevent replay attacks. */
                    "X-Twenty-Webhook-Timestamp"?: string;
                    /** @description Unique identifier for this webhook request to prevent replay attacks. Consumers should ensure this nonce is not reused. */
                    "X-Twenty-Webhook-Nonce"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @example https://example.com/incomingWebhook */
                        targetUrl?: string;
                        /** @example calendarEventParticipant.deleted */
                        eventName?: string;
                        objectMetadata?: {
                            /** @example 370985db-22d8-4463-8e5f-2271d30913bd */
                            id?: string;
                            /** @enum {string} */
                            nameSingular?: "calendarEventParticipant";
                        };
                        /** @example 872cfcf1-c79f-42bc-877d-5829f06eb3f9 */
                        workspaceId?: string;
                        /** @example 90056586-1228-4e03-a507-70140aa85c05 */
                        webhookId?: string;
                        /** @example 2024-02-14T11:27:01.779Z */
                        eventDate?: string;
                        record?: components["schemas"]["CalendarEventParticipantForResponse"];
                    };
                };
            };
            responses: {
                /** @description Return a 200 status to indicate that the data was received successfully */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "CalendarEvent Created": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description HMAC SHA256 signature of the request payload using the webhook secret. To compute the signature:
                     *     1. Concatenate `X-Twenty-Webhook-Timestamp`, a colon (:), and the JSON string of the request payload.
                     *     2. Compute the HMAC SHA256 hash using the shared secret as the key.
                     *     3. Send the resulting hex digest as this header value.
                     *     Example (Node.js):
                     *     ```javascript
                     *     const crypto = require("crypto");
                     *     const timestamp = "1735066639761";
                     *     const payload = JSON.stringify({...});
                     *     const secret = "your-secret";
                     *     const stringToSign = `${timestamp}:${JSON.stringify(payload)}`;
                     *     const signature = crypto.createHmac("sha256", secret)
                     *       .update(stringToSign)
                     *       .digest("hex");
                     *     ``` */
                    "X-Twenty-Webhook-Signature"?: string;
                    /** @description Unix timestamp of when the webhook was sent. This timestamp is included in the HMAC signature generation to prevent replay attacks. */
                    "X-Twenty-Webhook-Timestamp"?: string;
                    /** @description Unique identifier for this webhook request to prevent replay attacks. Consumers should ensure this nonce is not reused. */
                    "X-Twenty-Webhook-Nonce"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @example https://example.com/incomingWebhook */
                        targetUrl?: string;
                        /** @example calendarEvent.created */
                        eventName?: string;
                        objectMetadata?: {
                            /** @example 370985db-22d8-4463-8e5f-2271d30913bd */
                            id?: string;
                            /** @enum {string} */
                            nameSingular?: "calendarEvent";
                        };
                        /** @example 872cfcf1-c79f-42bc-877d-5829f06eb3f9 */
                        workspaceId?: string;
                        /** @example 90056586-1228-4e03-a507-70140aa85c05 */
                        webhookId?: string;
                        /** @example 2024-02-14T11:27:01.779Z */
                        eventDate?: string;
                        record?: components["schemas"]["CalendarEventForResponse"];
                    };
                };
            };
            responses: {
                /** @description Return a 200 status to indicate that the data was received successfully */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "CalendarEvent Updated": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description HMAC SHA256 signature of the request payload using the webhook secret. To compute the signature:
                     *     1. Concatenate `X-Twenty-Webhook-Timestamp`, a colon (:), and the JSON string of the request payload.
                     *     2. Compute the HMAC SHA256 hash using the shared secret as the key.
                     *     3. Send the resulting hex digest as this header value.
                     *     Example (Node.js):
                     *     ```javascript
                     *     const crypto = require("crypto");
                     *     const timestamp = "1735066639761";
                     *     const payload = JSON.stringify({...});
                     *     const secret = "your-secret";
                     *     const stringToSign = `${timestamp}:${JSON.stringify(payload)}`;
                     *     const signature = crypto.createHmac("sha256", secret)
                     *       .update(stringToSign)
                     *       .digest("hex");
                     *     ``` */
                    "X-Twenty-Webhook-Signature"?: string;
                    /** @description Unix timestamp of when the webhook was sent. This timestamp is included in the HMAC signature generation to prevent replay attacks. */
                    "X-Twenty-Webhook-Timestamp"?: string;
                    /** @description Unique identifier for this webhook request to prevent replay attacks. Consumers should ensure this nonce is not reused. */
                    "X-Twenty-Webhook-Nonce"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @example https://example.com/incomingWebhook */
                        targetUrl?: string;
                        /** @example calendarEvent.updated */
                        eventName?: string;
                        objectMetadata?: {
                            /** @example 370985db-22d8-4463-8e5f-2271d30913bd */
                            id?: string;
                            /** @enum {string} */
                            nameSingular?: "calendarEvent";
                        };
                        /** @example 872cfcf1-c79f-42bc-877d-5829f06eb3f9 */
                        workspaceId?: string;
                        /** @example 90056586-1228-4e03-a507-70140aa85c05 */
                        webhookId?: string;
                        /** @example 2024-02-14T11:27:01.779Z */
                        eventDate?: string;
                        record?: components["schemas"]["CalendarEventForResponse"];
                        updatedFields?: string[];
                    };
                };
            };
            responses: {
                /** @description Return a 200 status to indicate that the data was received successfully */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "CalendarEvent Deleted": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description HMAC SHA256 signature of the request payload using the webhook secret. To compute the signature:
                     *     1. Concatenate `X-Twenty-Webhook-Timestamp`, a colon (:), and the JSON string of the request payload.
                     *     2. Compute the HMAC SHA256 hash using the shared secret as the key.
                     *     3. Send the resulting hex digest as this header value.
                     *     Example (Node.js):
                     *     ```javascript
                     *     const crypto = require("crypto");
                     *     const timestamp = "1735066639761";
                     *     const payload = JSON.stringify({...});
                     *     const secret = "your-secret";
                     *     const stringToSign = `${timestamp}:${JSON.stringify(payload)}`;
                     *     const signature = crypto.createHmac("sha256", secret)
                     *       .update(stringToSign)
                     *       .digest("hex");
                     *     ``` */
                    "X-Twenty-Webhook-Signature"?: string;
                    /** @description Unix timestamp of when the webhook was sent. This timestamp is included in the HMAC signature generation to prevent replay attacks. */
                    "X-Twenty-Webhook-Timestamp"?: string;
                    /** @description Unique identifier for this webhook request to prevent replay attacks. Consumers should ensure this nonce is not reused. */
                    "X-Twenty-Webhook-Nonce"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @example https://example.com/incomingWebhook */
                        targetUrl?: string;
                        /** @example calendarEvent.deleted */
                        eventName?: string;
                        objectMetadata?: {
                            /** @example 370985db-22d8-4463-8e5f-2271d30913bd */
                            id?: string;
                            /** @enum {string} */
                            nameSingular?: "calendarEvent";
                        };
                        /** @example 872cfcf1-c79f-42bc-877d-5829f06eb3f9 */
                        workspaceId?: string;
                        /** @example 90056586-1228-4e03-a507-70140aa85c05 */
                        webhookId?: string;
                        /** @example 2024-02-14T11:27:01.779Z */
                        eventDate?: string;
                        record?: components["schemas"]["CalendarEventForResponse"];
                    };
                };
            };
            responses: {
                /** @description Return a 200 status to indicate that the data was received successfully */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "Company Created": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description HMAC SHA256 signature of the request payload using the webhook secret. To compute the signature:
                     *     1. Concatenate `X-Twenty-Webhook-Timestamp`, a colon (:), and the JSON string of the request payload.
                     *     2. Compute the HMAC SHA256 hash using the shared secret as the key.
                     *     3. Send the resulting hex digest as this header value.
                     *     Example (Node.js):
                     *     ```javascript
                     *     const crypto = require("crypto");
                     *     const timestamp = "1735066639761";
                     *     const payload = JSON.stringify({...});
                     *     const secret = "your-secret";
                     *     const stringToSign = `${timestamp}:${JSON.stringify(payload)}`;
                     *     const signature = crypto.createHmac("sha256", secret)
                     *       .update(stringToSign)
                     *       .digest("hex");
                     *     ``` */
                    "X-Twenty-Webhook-Signature"?: string;
                    /** @description Unix timestamp of when the webhook was sent. This timestamp is included in the HMAC signature generation to prevent replay attacks. */
                    "X-Twenty-Webhook-Timestamp"?: string;
                    /** @description Unique identifier for this webhook request to prevent replay attacks. Consumers should ensure this nonce is not reused. */
                    "X-Twenty-Webhook-Nonce"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @example https://example.com/incomingWebhook */
                        targetUrl?: string;
                        /** @example company.created */
                        eventName?: string;
                        objectMetadata?: {
                            /** @example 370985db-22d8-4463-8e5f-2271d30913bd */
                            id?: string;
                            /** @enum {string} */
                            nameSingular?: "company";
                        };
                        /** @example 872cfcf1-c79f-42bc-877d-5829f06eb3f9 */
                        workspaceId?: string;
                        /** @example 90056586-1228-4e03-a507-70140aa85c05 */
                        webhookId?: string;
                        /** @example 2024-02-14T11:27:01.779Z */
                        eventDate?: string;
                        record?: components["schemas"]["CompanyForResponse"];
                    };
                };
            };
            responses: {
                /** @description Return a 200 status to indicate that the data was received successfully */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "Company Updated": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description HMAC SHA256 signature of the request payload using the webhook secret. To compute the signature:
                     *     1. Concatenate `X-Twenty-Webhook-Timestamp`, a colon (:), and the JSON string of the request payload.
                     *     2. Compute the HMAC SHA256 hash using the shared secret as the key.
                     *     3. Send the resulting hex digest as this header value.
                     *     Example (Node.js):
                     *     ```javascript
                     *     const crypto = require("crypto");
                     *     const timestamp = "1735066639761";
                     *     const payload = JSON.stringify({...});
                     *     const secret = "your-secret";
                     *     const stringToSign = `${timestamp}:${JSON.stringify(payload)}`;
                     *     const signature = crypto.createHmac("sha256", secret)
                     *       .update(stringToSign)
                     *       .digest("hex");
                     *     ``` */
                    "X-Twenty-Webhook-Signature"?: string;
                    /** @description Unix timestamp of when the webhook was sent. This timestamp is included in the HMAC signature generation to prevent replay attacks. */
                    "X-Twenty-Webhook-Timestamp"?: string;
                    /** @description Unique identifier for this webhook request to prevent replay attacks. Consumers should ensure this nonce is not reused. */
                    "X-Twenty-Webhook-Nonce"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @example https://example.com/incomingWebhook */
                        targetUrl?: string;
                        /** @example company.updated */
                        eventName?: string;
                        objectMetadata?: {
                            /** @example 370985db-22d8-4463-8e5f-2271d30913bd */
                            id?: string;
                            /** @enum {string} */
                            nameSingular?: "company";
                        };
                        /** @example 872cfcf1-c79f-42bc-877d-5829f06eb3f9 */
                        workspaceId?: string;
                        /** @example 90056586-1228-4e03-a507-70140aa85c05 */
                        webhookId?: string;
                        /** @example 2024-02-14T11:27:01.779Z */
                        eventDate?: string;
                        record?: components["schemas"]["CompanyForResponse"];
                        updatedFields?: string[];
                    };
                };
            };
            responses: {
                /** @description Return a 200 status to indicate that the data was received successfully */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "Company Deleted": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description HMAC SHA256 signature of the request payload using the webhook secret. To compute the signature:
                     *     1. Concatenate `X-Twenty-Webhook-Timestamp`, a colon (:), and the JSON string of the request payload.
                     *     2. Compute the HMAC SHA256 hash using the shared secret as the key.
                     *     3. Send the resulting hex digest as this header value.
                     *     Example (Node.js):
                     *     ```javascript
                     *     const crypto = require("crypto");
                     *     const timestamp = "1735066639761";
                     *     const payload = JSON.stringify({...});
                     *     const secret = "your-secret";
                     *     const stringToSign = `${timestamp}:${JSON.stringify(payload)}`;
                     *     const signature = crypto.createHmac("sha256", secret)
                     *       .update(stringToSign)
                     *       .digest("hex");
                     *     ``` */
                    "X-Twenty-Webhook-Signature"?: string;
                    /** @description Unix timestamp of when the webhook was sent. This timestamp is included in the HMAC signature generation to prevent replay attacks. */
                    "X-Twenty-Webhook-Timestamp"?: string;
                    /** @description Unique identifier for this webhook request to prevent replay attacks. Consumers should ensure this nonce is not reused. */
                    "X-Twenty-Webhook-Nonce"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @example https://example.com/incomingWebhook */
                        targetUrl?: string;
                        /** @example company.deleted */
                        eventName?: string;
                        objectMetadata?: {
                            /** @example 370985db-22d8-4463-8e5f-2271d30913bd */
                            id?: string;
                            /** @enum {string} */
                            nameSingular?: "company";
                        };
                        /** @example 872cfcf1-c79f-42bc-877d-5829f06eb3f9 */
                        workspaceId?: string;
                        /** @example 90056586-1228-4e03-a507-70140aa85c05 */
                        webhookId?: string;
                        /** @example 2024-02-14T11:27:01.779Z */
                        eventDate?: string;
                        record?: components["schemas"]["CompanyForResponse"];
                    };
                };
            };
            responses: {
                /** @description Return a 200 status to indicate that the data was received successfully */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "ConnectedAccount Created": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description HMAC SHA256 signature of the request payload using the webhook secret. To compute the signature:
                     *     1. Concatenate `X-Twenty-Webhook-Timestamp`, a colon (:), and the JSON string of the request payload.
                     *     2. Compute the HMAC SHA256 hash using the shared secret as the key.
                     *     3. Send the resulting hex digest as this header value.
                     *     Example (Node.js):
                     *     ```javascript
                     *     const crypto = require("crypto");
                     *     const timestamp = "1735066639761";
                     *     const payload = JSON.stringify({...});
                     *     const secret = "your-secret";
                     *     const stringToSign = `${timestamp}:${JSON.stringify(payload)}`;
                     *     const signature = crypto.createHmac("sha256", secret)
                     *       .update(stringToSign)
                     *       .digest("hex");
                     *     ``` */
                    "X-Twenty-Webhook-Signature"?: string;
                    /** @description Unix timestamp of when the webhook was sent. This timestamp is included in the HMAC signature generation to prevent replay attacks. */
                    "X-Twenty-Webhook-Timestamp"?: string;
                    /** @description Unique identifier for this webhook request to prevent replay attacks. Consumers should ensure this nonce is not reused. */
                    "X-Twenty-Webhook-Nonce"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @example https://example.com/incomingWebhook */
                        targetUrl?: string;
                        /** @example connectedAccount.created */
                        eventName?: string;
                        objectMetadata?: {
                            /** @example 370985db-22d8-4463-8e5f-2271d30913bd */
                            id?: string;
                            /** @enum {string} */
                            nameSingular?: "connectedAccount";
                        };
                        /** @example 872cfcf1-c79f-42bc-877d-5829f06eb3f9 */
                        workspaceId?: string;
                        /** @example 90056586-1228-4e03-a507-70140aa85c05 */
                        webhookId?: string;
                        /** @example 2024-02-14T11:27:01.779Z */
                        eventDate?: string;
                        record?: components["schemas"]["ConnectedAccountForResponse"];
                    };
                };
            };
            responses: {
                /** @description Return a 200 status to indicate that the data was received successfully */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "ConnectedAccount Updated": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description HMAC SHA256 signature of the request payload using the webhook secret. To compute the signature:
                     *     1. Concatenate `X-Twenty-Webhook-Timestamp`, a colon (:), and the JSON string of the request payload.
                     *     2. Compute the HMAC SHA256 hash using the shared secret as the key.
                     *     3. Send the resulting hex digest as this header value.
                     *     Example (Node.js):
                     *     ```javascript
                     *     const crypto = require("crypto");
                     *     const timestamp = "1735066639761";
                     *     const payload = JSON.stringify({...});
                     *     const secret = "your-secret";
                     *     const stringToSign = `${timestamp}:${JSON.stringify(payload)}`;
                     *     const signature = crypto.createHmac("sha256", secret)
                     *       .update(stringToSign)
                     *       .digest("hex");
                     *     ``` */
                    "X-Twenty-Webhook-Signature"?: string;
                    /** @description Unix timestamp of when the webhook was sent. This timestamp is included in the HMAC signature generation to prevent replay attacks. */
                    "X-Twenty-Webhook-Timestamp"?: string;
                    /** @description Unique identifier for this webhook request to prevent replay attacks. Consumers should ensure this nonce is not reused. */
                    "X-Twenty-Webhook-Nonce"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @example https://example.com/incomingWebhook */
                        targetUrl?: string;
                        /** @example connectedAccount.updated */
                        eventName?: string;
                        objectMetadata?: {
                            /** @example 370985db-22d8-4463-8e5f-2271d30913bd */
                            id?: string;
                            /** @enum {string} */
                            nameSingular?: "connectedAccount";
                        };
                        /** @example 872cfcf1-c79f-42bc-877d-5829f06eb3f9 */
                        workspaceId?: string;
                        /** @example 90056586-1228-4e03-a507-70140aa85c05 */
                        webhookId?: string;
                        /** @example 2024-02-14T11:27:01.779Z */
                        eventDate?: string;
                        record?: components["schemas"]["ConnectedAccountForResponse"];
                        updatedFields?: string[];
                    };
                };
            };
            responses: {
                /** @description Return a 200 status to indicate that the data was received successfully */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "ConnectedAccount Deleted": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description HMAC SHA256 signature of the request payload using the webhook secret. To compute the signature:
                     *     1. Concatenate `X-Twenty-Webhook-Timestamp`, a colon (:), and the JSON string of the request payload.
                     *     2. Compute the HMAC SHA256 hash using the shared secret as the key.
                     *     3. Send the resulting hex digest as this header value.
                     *     Example (Node.js):
                     *     ```javascript
                     *     const crypto = require("crypto");
                     *     const timestamp = "1735066639761";
                     *     const payload = JSON.stringify({...});
                     *     const secret = "your-secret";
                     *     const stringToSign = `${timestamp}:${JSON.stringify(payload)}`;
                     *     const signature = crypto.createHmac("sha256", secret)
                     *       .update(stringToSign)
                     *       .digest("hex");
                     *     ``` */
                    "X-Twenty-Webhook-Signature"?: string;
                    /** @description Unix timestamp of when the webhook was sent. This timestamp is included in the HMAC signature generation to prevent replay attacks. */
                    "X-Twenty-Webhook-Timestamp"?: string;
                    /** @description Unique identifier for this webhook request to prevent replay attacks. Consumers should ensure this nonce is not reused. */
                    "X-Twenty-Webhook-Nonce"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @example https://example.com/incomingWebhook */
                        targetUrl?: string;
                        /** @example connectedAccount.deleted */
                        eventName?: string;
                        objectMetadata?: {
                            /** @example 370985db-22d8-4463-8e5f-2271d30913bd */
                            id?: string;
                            /** @enum {string} */
                            nameSingular?: "connectedAccount";
                        };
                        /** @example 872cfcf1-c79f-42bc-877d-5829f06eb3f9 */
                        workspaceId?: string;
                        /** @example 90056586-1228-4e03-a507-70140aa85c05 */
                        webhookId?: string;
                        /** @example 2024-02-14T11:27:01.779Z */
                        eventDate?: string;
                        record?: components["schemas"]["ConnectedAccountForResponse"];
                    };
                };
            };
            responses: {
                /** @description Return a 200 status to indicate that the data was received successfully */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "FavoriteFolder Created": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description HMAC SHA256 signature of the request payload using the webhook secret. To compute the signature:
                     *     1. Concatenate `X-Twenty-Webhook-Timestamp`, a colon (:), and the JSON string of the request payload.
                     *     2. Compute the HMAC SHA256 hash using the shared secret as the key.
                     *     3. Send the resulting hex digest as this header value.
                     *     Example (Node.js):
                     *     ```javascript
                     *     const crypto = require("crypto");
                     *     const timestamp = "1735066639761";
                     *     const payload = JSON.stringify({...});
                     *     const secret = "your-secret";
                     *     const stringToSign = `${timestamp}:${JSON.stringify(payload)}`;
                     *     const signature = crypto.createHmac("sha256", secret)
                     *       .update(stringToSign)
                     *       .digest("hex");
                     *     ``` */
                    "X-Twenty-Webhook-Signature"?: string;
                    /** @description Unix timestamp of when the webhook was sent. This timestamp is included in the HMAC signature generation to prevent replay attacks. */
                    "X-Twenty-Webhook-Timestamp"?: string;
                    /** @description Unique identifier for this webhook request to prevent replay attacks. Consumers should ensure this nonce is not reused. */
                    "X-Twenty-Webhook-Nonce"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @example https://example.com/incomingWebhook */
                        targetUrl?: string;
                        /** @example favoriteFolder.created */
                        eventName?: string;
                        objectMetadata?: {
                            /** @example 370985db-22d8-4463-8e5f-2271d30913bd */
                            id?: string;
                            /** @enum {string} */
                            nameSingular?: "favoriteFolder";
                        };
                        /** @example 872cfcf1-c79f-42bc-877d-5829f06eb3f9 */
                        workspaceId?: string;
                        /** @example 90056586-1228-4e03-a507-70140aa85c05 */
                        webhookId?: string;
                        /** @example 2024-02-14T11:27:01.779Z */
                        eventDate?: string;
                        record?: components["schemas"]["FavoriteFolderForResponse"];
                    };
                };
            };
            responses: {
                /** @description Return a 200 status to indicate that the data was received successfully */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "FavoriteFolder Updated": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description HMAC SHA256 signature of the request payload using the webhook secret. To compute the signature:
                     *     1. Concatenate `X-Twenty-Webhook-Timestamp`, a colon (:), and the JSON string of the request payload.
                     *     2. Compute the HMAC SHA256 hash using the shared secret as the key.
                     *     3. Send the resulting hex digest as this header value.
                     *     Example (Node.js):
                     *     ```javascript
                     *     const crypto = require("crypto");
                     *     const timestamp = "1735066639761";
                     *     const payload = JSON.stringify({...});
                     *     const secret = "your-secret";
                     *     const stringToSign = `${timestamp}:${JSON.stringify(payload)}`;
                     *     const signature = crypto.createHmac("sha256", secret)
                     *       .update(stringToSign)
                     *       .digest("hex");
                     *     ``` */
                    "X-Twenty-Webhook-Signature"?: string;
                    /** @description Unix timestamp of when the webhook was sent. This timestamp is included in the HMAC signature generation to prevent replay attacks. */
                    "X-Twenty-Webhook-Timestamp"?: string;
                    /** @description Unique identifier for this webhook request to prevent replay attacks. Consumers should ensure this nonce is not reused. */
                    "X-Twenty-Webhook-Nonce"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @example https://example.com/incomingWebhook */
                        targetUrl?: string;
                        /** @example favoriteFolder.updated */
                        eventName?: string;
                        objectMetadata?: {
                            /** @example 370985db-22d8-4463-8e5f-2271d30913bd */
                            id?: string;
                            /** @enum {string} */
                            nameSingular?: "favoriteFolder";
                        };
                        /** @example 872cfcf1-c79f-42bc-877d-5829f06eb3f9 */
                        workspaceId?: string;
                        /** @example 90056586-1228-4e03-a507-70140aa85c05 */
                        webhookId?: string;
                        /** @example 2024-02-14T11:27:01.779Z */
                        eventDate?: string;
                        record?: components["schemas"]["FavoriteFolderForResponse"];
                        updatedFields?: string[];
                    };
                };
            };
            responses: {
                /** @description Return a 200 status to indicate that the data was received successfully */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "FavoriteFolder Deleted": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description HMAC SHA256 signature of the request payload using the webhook secret. To compute the signature:
                     *     1. Concatenate `X-Twenty-Webhook-Timestamp`, a colon (:), and the JSON string of the request payload.
                     *     2. Compute the HMAC SHA256 hash using the shared secret as the key.
                     *     3. Send the resulting hex digest as this header value.
                     *     Example (Node.js):
                     *     ```javascript
                     *     const crypto = require("crypto");
                     *     const timestamp = "1735066639761";
                     *     const payload = JSON.stringify({...});
                     *     const secret = "your-secret";
                     *     const stringToSign = `${timestamp}:${JSON.stringify(payload)}`;
                     *     const signature = crypto.createHmac("sha256", secret)
                     *       .update(stringToSign)
                     *       .digest("hex");
                     *     ``` */
                    "X-Twenty-Webhook-Signature"?: string;
                    /** @description Unix timestamp of when the webhook was sent. This timestamp is included in the HMAC signature generation to prevent replay attacks. */
                    "X-Twenty-Webhook-Timestamp"?: string;
                    /** @description Unique identifier for this webhook request to prevent replay attacks. Consumers should ensure this nonce is not reused. */
                    "X-Twenty-Webhook-Nonce"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @example https://example.com/incomingWebhook */
                        targetUrl?: string;
                        /** @example favoriteFolder.deleted */
                        eventName?: string;
                        objectMetadata?: {
                            /** @example 370985db-22d8-4463-8e5f-2271d30913bd */
                            id?: string;
                            /** @enum {string} */
                            nameSingular?: "favoriteFolder";
                        };
                        /** @example 872cfcf1-c79f-42bc-877d-5829f06eb3f9 */
                        workspaceId?: string;
                        /** @example 90056586-1228-4e03-a507-70140aa85c05 */
                        webhookId?: string;
                        /** @example 2024-02-14T11:27:01.779Z */
                        eventDate?: string;
                        record?: components["schemas"]["FavoriteFolderForResponse"];
                    };
                };
            };
            responses: {
                /** @description Return a 200 status to indicate that the data was received successfully */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "Favorite Created": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description HMAC SHA256 signature of the request payload using the webhook secret. To compute the signature:
                     *     1. Concatenate `X-Twenty-Webhook-Timestamp`, a colon (:), and the JSON string of the request payload.
                     *     2. Compute the HMAC SHA256 hash using the shared secret as the key.
                     *     3. Send the resulting hex digest as this header value.
                     *     Example (Node.js):
                     *     ```javascript
                     *     const crypto = require("crypto");
                     *     const timestamp = "1735066639761";
                     *     const payload = JSON.stringify({...});
                     *     const secret = "your-secret";
                     *     const stringToSign = `${timestamp}:${JSON.stringify(payload)}`;
                     *     const signature = crypto.createHmac("sha256", secret)
                     *       .update(stringToSign)
                     *       .digest("hex");
                     *     ``` */
                    "X-Twenty-Webhook-Signature"?: string;
                    /** @description Unix timestamp of when the webhook was sent. This timestamp is included in the HMAC signature generation to prevent replay attacks. */
                    "X-Twenty-Webhook-Timestamp"?: string;
                    /** @description Unique identifier for this webhook request to prevent replay attacks. Consumers should ensure this nonce is not reused. */
                    "X-Twenty-Webhook-Nonce"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @example https://example.com/incomingWebhook */
                        targetUrl?: string;
                        /** @example favorite.created */
                        eventName?: string;
                        objectMetadata?: {
                            /** @example 370985db-22d8-4463-8e5f-2271d30913bd */
                            id?: string;
                            /** @enum {string} */
                            nameSingular?: "favorite";
                        };
                        /** @example 872cfcf1-c79f-42bc-877d-5829f06eb3f9 */
                        workspaceId?: string;
                        /** @example 90056586-1228-4e03-a507-70140aa85c05 */
                        webhookId?: string;
                        /** @example 2024-02-14T11:27:01.779Z */
                        eventDate?: string;
                        record?: components["schemas"]["FavoriteForResponse"];
                    };
                };
            };
            responses: {
                /** @description Return a 200 status to indicate that the data was received successfully */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "Favorite Updated": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description HMAC SHA256 signature of the request payload using the webhook secret. To compute the signature:
                     *     1. Concatenate `X-Twenty-Webhook-Timestamp`, a colon (:), and the JSON string of the request payload.
                     *     2. Compute the HMAC SHA256 hash using the shared secret as the key.
                     *     3. Send the resulting hex digest as this header value.
                     *     Example (Node.js):
                     *     ```javascript
                     *     const crypto = require("crypto");
                     *     const timestamp = "1735066639761";
                     *     const payload = JSON.stringify({...});
                     *     const secret = "your-secret";
                     *     const stringToSign = `${timestamp}:${JSON.stringify(payload)}`;
                     *     const signature = crypto.createHmac("sha256", secret)
                     *       .update(stringToSign)
                     *       .digest("hex");
                     *     ``` */
                    "X-Twenty-Webhook-Signature"?: string;
                    /** @description Unix timestamp of when the webhook was sent. This timestamp is included in the HMAC signature generation to prevent replay attacks. */
                    "X-Twenty-Webhook-Timestamp"?: string;
                    /** @description Unique identifier for this webhook request to prevent replay attacks. Consumers should ensure this nonce is not reused. */
                    "X-Twenty-Webhook-Nonce"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @example https://example.com/incomingWebhook */
                        targetUrl?: string;
                        /** @example favorite.updated */
                        eventName?: string;
                        objectMetadata?: {
                            /** @example 370985db-22d8-4463-8e5f-2271d30913bd */
                            id?: string;
                            /** @enum {string} */
                            nameSingular?: "favorite";
                        };
                        /** @example 872cfcf1-c79f-42bc-877d-5829f06eb3f9 */
                        workspaceId?: string;
                        /** @example 90056586-1228-4e03-a507-70140aa85c05 */
                        webhookId?: string;
                        /** @example 2024-02-14T11:27:01.779Z */
                        eventDate?: string;
                        record?: components["schemas"]["FavoriteForResponse"];
                        updatedFields?: string[];
                    };
                };
            };
            responses: {
                /** @description Return a 200 status to indicate that the data was received successfully */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "Favorite Deleted": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description HMAC SHA256 signature of the request payload using the webhook secret. To compute the signature:
                     *     1. Concatenate `X-Twenty-Webhook-Timestamp`, a colon (:), and the JSON string of the request payload.
                     *     2. Compute the HMAC SHA256 hash using the shared secret as the key.
                     *     3. Send the resulting hex digest as this header value.
                     *     Example (Node.js):
                     *     ```javascript
                     *     const crypto = require("crypto");
                     *     const timestamp = "1735066639761";
                     *     const payload = JSON.stringify({...});
                     *     const secret = "your-secret";
                     *     const stringToSign = `${timestamp}:${JSON.stringify(payload)}`;
                     *     const signature = crypto.createHmac("sha256", secret)
                     *       .update(stringToSign)
                     *       .digest("hex");
                     *     ``` */
                    "X-Twenty-Webhook-Signature"?: string;
                    /** @description Unix timestamp of when the webhook was sent. This timestamp is included in the HMAC signature generation to prevent replay attacks. */
                    "X-Twenty-Webhook-Timestamp"?: string;
                    /** @description Unique identifier for this webhook request to prevent replay attacks. Consumers should ensure this nonce is not reused. */
                    "X-Twenty-Webhook-Nonce"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @example https://example.com/incomingWebhook */
                        targetUrl?: string;
                        /** @example favorite.deleted */
                        eventName?: string;
                        objectMetadata?: {
                            /** @example 370985db-22d8-4463-8e5f-2271d30913bd */
                            id?: string;
                            /** @enum {string} */
                            nameSingular?: "favorite";
                        };
                        /** @example 872cfcf1-c79f-42bc-877d-5829f06eb3f9 */
                        workspaceId?: string;
                        /** @example 90056586-1228-4e03-a507-70140aa85c05 */
                        webhookId?: string;
                        /** @example 2024-02-14T11:27:01.779Z */
                        eventDate?: string;
                        record?: components["schemas"]["FavoriteForResponse"];
                    };
                };
            };
            responses: {
                /** @description Return a 200 status to indicate that the data was received successfully */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "MessageChannelMessageAssociation Created": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description HMAC SHA256 signature of the request payload using the webhook secret. To compute the signature:
                     *     1. Concatenate `X-Twenty-Webhook-Timestamp`, a colon (:), and the JSON string of the request payload.
                     *     2. Compute the HMAC SHA256 hash using the shared secret as the key.
                     *     3. Send the resulting hex digest as this header value.
                     *     Example (Node.js):
                     *     ```javascript
                     *     const crypto = require("crypto");
                     *     const timestamp = "1735066639761";
                     *     const payload = JSON.stringify({...});
                     *     const secret = "your-secret";
                     *     const stringToSign = `${timestamp}:${JSON.stringify(payload)}`;
                     *     const signature = crypto.createHmac("sha256", secret)
                     *       .update(stringToSign)
                     *       .digest("hex");
                     *     ``` */
                    "X-Twenty-Webhook-Signature"?: string;
                    /** @description Unix timestamp of when the webhook was sent. This timestamp is included in the HMAC signature generation to prevent replay attacks. */
                    "X-Twenty-Webhook-Timestamp"?: string;
                    /** @description Unique identifier for this webhook request to prevent replay attacks. Consumers should ensure this nonce is not reused. */
                    "X-Twenty-Webhook-Nonce"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @example https://example.com/incomingWebhook */
                        targetUrl?: string;
                        /** @example messageChannelMessageAssociation.created */
                        eventName?: string;
                        objectMetadata?: {
                            /** @example 370985db-22d8-4463-8e5f-2271d30913bd */
                            id?: string;
                            /** @enum {string} */
                            nameSingular?: "messageChannelMessageAssociation";
                        };
                        /** @example 872cfcf1-c79f-42bc-877d-5829f06eb3f9 */
                        workspaceId?: string;
                        /** @example 90056586-1228-4e03-a507-70140aa85c05 */
                        webhookId?: string;
                        /** @example 2024-02-14T11:27:01.779Z */
                        eventDate?: string;
                        record?: components["schemas"]["MessageChannelMessageAssociationForResponse"];
                    };
                };
            };
            responses: {
                /** @description Return a 200 status to indicate that the data was received successfully */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "MessageChannelMessageAssociation Updated": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description HMAC SHA256 signature of the request payload using the webhook secret. To compute the signature:
                     *     1. Concatenate `X-Twenty-Webhook-Timestamp`, a colon (:), and the JSON string of the request payload.
                     *     2. Compute the HMAC SHA256 hash using the shared secret as the key.
                     *     3. Send the resulting hex digest as this header value.
                     *     Example (Node.js):
                     *     ```javascript
                     *     const crypto = require("crypto");
                     *     const timestamp = "1735066639761";
                     *     const payload = JSON.stringify({...});
                     *     const secret = "your-secret";
                     *     const stringToSign = `${timestamp}:${JSON.stringify(payload)}`;
                     *     const signature = crypto.createHmac("sha256", secret)
                     *       .update(stringToSign)
                     *       .digest("hex");
                     *     ``` */
                    "X-Twenty-Webhook-Signature"?: string;
                    /** @description Unix timestamp of when the webhook was sent. This timestamp is included in the HMAC signature generation to prevent replay attacks. */
                    "X-Twenty-Webhook-Timestamp"?: string;
                    /** @description Unique identifier for this webhook request to prevent replay attacks. Consumers should ensure this nonce is not reused. */
                    "X-Twenty-Webhook-Nonce"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @example https://example.com/incomingWebhook */
                        targetUrl?: string;
                        /** @example messageChannelMessageAssociation.updated */
                        eventName?: string;
                        objectMetadata?: {
                            /** @example 370985db-22d8-4463-8e5f-2271d30913bd */
                            id?: string;
                            /** @enum {string} */
                            nameSingular?: "messageChannelMessageAssociation";
                        };
                        /** @example 872cfcf1-c79f-42bc-877d-5829f06eb3f9 */
                        workspaceId?: string;
                        /** @example 90056586-1228-4e03-a507-70140aa85c05 */
                        webhookId?: string;
                        /** @example 2024-02-14T11:27:01.779Z */
                        eventDate?: string;
                        record?: components["schemas"]["MessageChannelMessageAssociationForResponse"];
                        updatedFields?: string[];
                    };
                };
            };
            responses: {
                /** @description Return a 200 status to indicate that the data was received successfully */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "MessageChannelMessageAssociation Deleted": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description HMAC SHA256 signature of the request payload using the webhook secret. To compute the signature:
                     *     1. Concatenate `X-Twenty-Webhook-Timestamp`, a colon (:), and the JSON string of the request payload.
                     *     2. Compute the HMAC SHA256 hash using the shared secret as the key.
                     *     3. Send the resulting hex digest as this header value.
                     *     Example (Node.js):
                     *     ```javascript
                     *     const crypto = require("crypto");
                     *     const timestamp = "1735066639761";
                     *     const payload = JSON.stringify({...});
                     *     const secret = "your-secret";
                     *     const stringToSign = `${timestamp}:${JSON.stringify(payload)}`;
                     *     const signature = crypto.createHmac("sha256", secret)
                     *       .update(stringToSign)
                     *       .digest("hex");
                     *     ``` */
                    "X-Twenty-Webhook-Signature"?: string;
                    /** @description Unix timestamp of when the webhook was sent. This timestamp is included in the HMAC signature generation to prevent replay attacks. */
                    "X-Twenty-Webhook-Timestamp"?: string;
                    /** @description Unique identifier for this webhook request to prevent replay attacks. Consumers should ensure this nonce is not reused. */
                    "X-Twenty-Webhook-Nonce"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @example https://example.com/incomingWebhook */
                        targetUrl?: string;
                        /** @example messageChannelMessageAssociation.deleted */
                        eventName?: string;
                        objectMetadata?: {
                            /** @example 370985db-22d8-4463-8e5f-2271d30913bd */
                            id?: string;
                            /** @enum {string} */
                            nameSingular?: "messageChannelMessageAssociation";
                        };
                        /** @example 872cfcf1-c79f-42bc-877d-5829f06eb3f9 */
                        workspaceId?: string;
                        /** @example 90056586-1228-4e03-a507-70140aa85c05 */
                        webhookId?: string;
                        /** @example 2024-02-14T11:27:01.779Z */
                        eventDate?: string;
                        record?: components["schemas"]["MessageChannelMessageAssociationForResponse"];
                    };
                };
            };
            responses: {
                /** @description Return a 200 status to indicate that the data was received successfully */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "MessageChannel Created": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description HMAC SHA256 signature of the request payload using the webhook secret. To compute the signature:
                     *     1. Concatenate `X-Twenty-Webhook-Timestamp`, a colon (:), and the JSON string of the request payload.
                     *     2. Compute the HMAC SHA256 hash using the shared secret as the key.
                     *     3. Send the resulting hex digest as this header value.
                     *     Example (Node.js):
                     *     ```javascript
                     *     const crypto = require("crypto");
                     *     const timestamp = "1735066639761";
                     *     const payload = JSON.stringify({...});
                     *     const secret = "your-secret";
                     *     const stringToSign = `${timestamp}:${JSON.stringify(payload)}`;
                     *     const signature = crypto.createHmac("sha256", secret)
                     *       .update(stringToSign)
                     *       .digest("hex");
                     *     ``` */
                    "X-Twenty-Webhook-Signature"?: string;
                    /** @description Unix timestamp of when the webhook was sent. This timestamp is included in the HMAC signature generation to prevent replay attacks. */
                    "X-Twenty-Webhook-Timestamp"?: string;
                    /** @description Unique identifier for this webhook request to prevent replay attacks. Consumers should ensure this nonce is not reused. */
                    "X-Twenty-Webhook-Nonce"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @example https://example.com/incomingWebhook */
                        targetUrl?: string;
                        /** @example messageChannel.created */
                        eventName?: string;
                        objectMetadata?: {
                            /** @example 370985db-22d8-4463-8e5f-2271d30913bd */
                            id?: string;
                            /** @enum {string} */
                            nameSingular?: "messageChannel";
                        };
                        /** @example 872cfcf1-c79f-42bc-877d-5829f06eb3f9 */
                        workspaceId?: string;
                        /** @example 90056586-1228-4e03-a507-70140aa85c05 */
                        webhookId?: string;
                        /** @example 2024-02-14T11:27:01.779Z */
                        eventDate?: string;
                        record?: components["schemas"]["MessageChannelForResponse"];
                    };
                };
            };
            responses: {
                /** @description Return a 200 status to indicate that the data was received successfully */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "MessageChannel Updated": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description HMAC SHA256 signature of the request payload using the webhook secret. To compute the signature:
                     *     1. Concatenate `X-Twenty-Webhook-Timestamp`, a colon (:), and the JSON string of the request payload.
                     *     2. Compute the HMAC SHA256 hash using the shared secret as the key.
                     *     3. Send the resulting hex digest as this header value.
                     *     Example (Node.js):
                     *     ```javascript
                     *     const crypto = require("crypto");
                     *     const timestamp = "1735066639761";
                     *     const payload = JSON.stringify({...});
                     *     const secret = "your-secret";
                     *     const stringToSign = `${timestamp}:${JSON.stringify(payload)}`;
                     *     const signature = crypto.createHmac("sha256", secret)
                     *       .update(stringToSign)
                     *       .digest("hex");
                     *     ``` */
                    "X-Twenty-Webhook-Signature"?: string;
                    /** @description Unix timestamp of when the webhook was sent. This timestamp is included in the HMAC signature generation to prevent replay attacks. */
                    "X-Twenty-Webhook-Timestamp"?: string;
                    /** @description Unique identifier for this webhook request to prevent replay attacks. Consumers should ensure this nonce is not reused. */
                    "X-Twenty-Webhook-Nonce"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @example https://example.com/incomingWebhook */
                        targetUrl?: string;
                        /** @example messageChannel.updated */
                        eventName?: string;
                        objectMetadata?: {
                            /** @example 370985db-22d8-4463-8e5f-2271d30913bd */
                            id?: string;
                            /** @enum {string} */
                            nameSingular?: "messageChannel";
                        };
                        /** @example 872cfcf1-c79f-42bc-877d-5829f06eb3f9 */
                        workspaceId?: string;
                        /** @example 90056586-1228-4e03-a507-70140aa85c05 */
                        webhookId?: string;
                        /** @example 2024-02-14T11:27:01.779Z */
                        eventDate?: string;
                        record?: components["schemas"]["MessageChannelForResponse"];
                        updatedFields?: string[];
                    };
                };
            };
            responses: {
                /** @description Return a 200 status to indicate that the data was received successfully */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "MessageChannel Deleted": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description HMAC SHA256 signature of the request payload using the webhook secret. To compute the signature:
                     *     1. Concatenate `X-Twenty-Webhook-Timestamp`, a colon (:), and the JSON string of the request payload.
                     *     2. Compute the HMAC SHA256 hash using the shared secret as the key.
                     *     3. Send the resulting hex digest as this header value.
                     *     Example (Node.js):
                     *     ```javascript
                     *     const crypto = require("crypto");
                     *     const timestamp = "1735066639761";
                     *     const payload = JSON.stringify({...});
                     *     const secret = "your-secret";
                     *     const stringToSign = `${timestamp}:${JSON.stringify(payload)}`;
                     *     const signature = crypto.createHmac("sha256", secret)
                     *       .update(stringToSign)
                     *       .digest("hex");
                     *     ``` */
                    "X-Twenty-Webhook-Signature"?: string;
                    /** @description Unix timestamp of when the webhook was sent. This timestamp is included in the HMAC signature generation to prevent replay attacks. */
                    "X-Twenty-Webhook-Timestamp"?: string;
                    /** @description Unique identifier for this webhook request to prevent replay attacks. Consumers should ensure this nonce is not reused. */
                    "X-Twenty-Webhook-Nonce"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @example https://example.com/incomingWebhook */
                        targetUrl?: string;
                        /** @example messageChannel.deleted */
                        eventName?: string;
                        objectMetadata?: {
                            /** @example 370985db-22d8-4463-8e5f-2271d30913bd */
                            id?: string;
                            /** @enum {string} */
                            nameSingular?: "messageChannel";
                        };
                        /** @example 872cfcf1-c79f-42bc-877d-5829f06eb3f9 */
                        workspaceId?: string;
                        /** @example 90056586-1228-4e03-a507-70140aa85c05 */
                        webhookId?: string;
                        /** @example 2024-02-14T11:27:01.779Z */
                        eventDate?: string;
                        record?: components["schemas"]["MessageChannelForResponse"];
                    };
                };
            };
            responses: {
                /** @description Return a 200 status to indicate that the data was received successfully */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "MessageFolder Created": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description HMAC SHA256 signature of the request payload using the webhook secret. To compute the signature:
                     *     1. Concatenate `X-Twenty-Webhook-Timestamp`, a colon (:), and the JSON string of the request payload.
                     *     2. Compute the HMAC SHA256 hash using the shared secret as the key.
                     *     3. Send the resulting hex digest as this header value.
                     *     Example (Node.js):
                     *     ```javascript
                     *     const crypto = require("crypto");
                     *     const timestamp = "1735066639761";
                     *     const payload = JSON.stringify({...});
                     *     const secret = "your-secret";
                     *     const stringToSign = `${timestamp}:${JSON.stringify(payload)}`;
                     *     const signature = crypto.createHmac("sha256", secret)
                     *       .update(stringToSign)
                     *       .digest("hex");
                     *     ``` */
                    "X-Twenty-Webhook-Signature"?: string;
                    /** @description Unix timestamp of when the webhook was sent. This timestamp is included in the HMAC signature generation to prevent replay attacks. */
                    "X-Twenty-Webhook-Timestamp"?: string;
                    /** @description Unique identifier for this webhook request to prevent replay attacks. Consumers should ensure this nonce is not reused. */
                    "X-Twenty-Webhook-Nonce"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @example https://example.com/incomingWebhook */
                        targetUrl?: string;
                        /** @example messageFolder.created */
                        eventName?: string;
                        objectMetadata?: {
                            /** @example 370985db-22d8-4463-8e5f-2271d30913bd */
                            id?: string;
                            /** @enum {string} */
                            nameSingular?: "messageFolder";
                        };
                        /** @example 872cfcf1-c79f-42bc-877d-5829f06eb3f9 */
                        workspaceId?: string;
                        /** @example 90056586-1228-4e03-a507-70140aa85c05 */
                        webhookId?: string;
                        /** @example 2024-02-14T11:27:01.779Z */
                        eventDate?: string;
                        record?: components["schemas"]["MessageFolderForResponse"];
                    };
                };
            };
            responses: {
                /** @description Return a 200 status to indicate that the data was received successfully */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "MessageFolder Updated": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description HMAC SHA256 signature of the request payload using the webhook secret. To compute the signature:
                     *     1. Concatenate `X-Twenty-Webhook-Timestamp`, a colon (:), and the JSON string of the request payload.
                     *     2. Compute the HMAC SHA256 hash using the shared secret as the key.
                     *     3. Send the resulting hex digest as this header value.
                     *     Example (Node.js):
                     *     ```javascript
                     *     const crypto = require("crypto");
                     *     const timestamp = "1735066639761";
                     *     const payload = JSON.stringify({...});
                     *     const secret = "your-secret";
                     *     const stringToSign = `${timestamp}:${JSON.stringify(payload)}`;
                     *     const signature = crypto.createHmac("sha256", secret)
                     *       .update(stringToSign)
                     *       .digest("hex");
                     *     ``` */
                    "X-Twenty-Webhook-Signature"?: string;
                    /** @description Unix timestamp of when the webhook was sent. This timestamp is included in the HMAC signature generation to prevent replay attacks. */
                    "X-Twenty-Webhook-Timestamp"?: string;
                    /** @description Unique identifier for this webhook request to prevent replay attacks. Consumers should ensure this nonce is not reused. */
                    "X-Twenty-Webhook-Nonce"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @example https://example.com/incomingWebhook */
                        targetUrl?: string;
                        /** @example messageFolder.updated */
                        eventName?: string;
                        objectMetadata?: {
                            /** @example 370985db-22d8-4463-8e5f-2271d30913bd */
                            id?: string;
                            /** @enum {string} */
                            nameSingular?: "messageFolder";
                        };
                        /** @example 872cfcf1-c79f-42bc-877d-5829f06eb3f9 */
                        workspaceId?: string;
                        /** @example 90056586-1228-4e03-a507-70140aa85c05 */
                        webhookId?: string;
                        /** @example 2024-02-14T11:27:01.779Z */
                        eventDate?: string;
                        record?: components["schemas"]["MessageFolderForResponse"];
                        updatedFields?: string[];
                    };
                };
            };
            responses: {
                /** @description Return a 200 status to indicate that the data was received successfully */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "MessageFolder Deleted": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description HMAC SHA256 signature of the request payload using the webhook secret. To compute the signature:
                     *     1. Concatenate `X-Twenty-Webhook-Timestamp`, a colon (:), and the JSON string of the request payload.
                     *     2. Compute the HMAC SHA256 hash using the shared secret as the key.
                     *     3. Send the resulting hex digest as this header value.
                     *     Example (Node.js):
                     *     ```javascript
                     *     const crypto = require("crypto");
                     *     const timestamp = "1735066639761";
                     *     const payload = JSON.stringify({...});
                     *     const secret = "your-secret";
                     *     const stringToSign = `${timestamp}:${JSON.stringify(payload)}`;
                     *     const signature = crypto.createHmac("sha256", secret)
                     *       .update(stringToSign)
                     *       .digest("hex");
                     *     ``` */
                    "X-Twenty-Webhook-Signature"?: string;
                    /** @description Unix timestamp of when the webhook was sent. This timestamp is included in the HMAC signature generation to prevent replay attacks. */
                    "X-Twenty-Webhook-Timestamp"?: string;
                    /** @description Unique identifier for this webhook request to prevent replay attacks. Consumers should ensure this nonce is not reused. */
                    "X-Twenty-Webhook-Nonce"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @example https://example.com/incomingWebhook */
                        targetUrl?: string;
                        /** @example messageFolder.deleted */
                        eventName?: string;
                        objectMetadata?: {
                            /** @example 370985db-22d8-4463-8e5f-2271d30913bd */
                            id?: string;
                            /** @enum {string} */
                            nameSingular?: "messageFolder";
                        };
                        /** @example 872cfcf1-c79f-42bc-877d-5829f06eb3f9 */
                        workspaceId?: string;
                        /** @example 90056586-1228-4e03-a507-70140aa85c05 */
                        webhookId?: string;
                        /** @example 2024-02-14T11:27:01.779Z */
                        eventDate?: string;
                        record?: components["schemas"]["MessageFolderForResponse"];
                    };
                };
            };
            responses: {
                /** @description Return a 200 status to indicate that the data was received successfully */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "MessageParticipant Created": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description HMAC SHA256 signature of the request payload using the webhook secret. To compute the signature:
                     *     1. Concatenate `X-Twenty-Webhook-Timestamp`, a colon (:), and the JSON string of the request payload.
                     *     2. Compute the HMAC SHA256 hash using the shared secret as the key.
                     *     3. Send the resulting hex digest as this header value.
                     *     Example (Node.js):
                     *     ```javascript
                     *     const crypto = require("crypto");
                     *     const timestamp = "1735066639761";
                     *     const payload = JSON.stringify({...});
                     *     const secret = "your-secret";
                     *     const stringToSign = `${timestamp}:${JSON.stringify(payload)}`;
                     *     const signature = crypto.createHmac("sha256", secret)
                     *       .update(stringToSign)
                     *       .digest("hex");
                     *     ``` */
                    "X-Twenty-Webhook-Signature"?: string;
                    /** @description Unix timestamp of when the webhook was sent. This timestamp is included in the HMAC signature generation to prevent replay attacks. */
                    "X-Twenty-Webhook-Timestamp"?: string;
                    /** @description Unique identifier for this webhook request to prevent replay attacks. Consumers should ensure this nonce is not reused. */
                    "X-Twenty-Webhook-Nonce"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @example https://example.com/incomingWebhook */
                        targetUrl?: string;
                        /** @example messageParticipant.created */
                        eventName?: string;
                        objectMetadata?: {
                            /** @example 370985db-22d8-4463-8e5f-2271d30913bd */
                            id?: string;
                            /** @enum {string} */
                            nameSingular?: "messageParticipant";
                        };
                        /** @example 872cfcf1-c79f-42bc-877d-5829f06eb3f9 */
                        workspaceId?: string;
                        /** @example 90056586-1228-4e03-a507-70140aa85c05 */
                        webhookId?: string;
                        /** @example 2024-02-14T11:27:01.779Z */
                        eventDate?: string;
                        record?: components["schemas"]["MessageParticipantForResponse"];
                    };
                };
            };
            responses: {
                /** @description Return a 200 status to indicate that the data was received successfully */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "MessageParticipant Updated": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description HMAC SHA256 signature of the request payload using the webhook secret. To compute the signature:
                     *     1. Concatenate `X-Twenty-Webhook-Timestamp`, a colon (:), and the JSON string of the request payload.
                     *     2. Compute the HMAC SHA256 hash using the shared secret as the key.
                     *     3. Send the resulting hex digest as this header value.
                     *     Example (Node.js):
                     *     ```javascript
                     *     const crypto = require("crypto");
                     *     const timestamp = "1735066639761";
                     *     const payload = JSON.stringify({...});
                     *     const secret = "your-secret";
                     *     const stringToSign = `${timestamp}:${JSON.stringify(payload)}`;
                     *     const signature = crypto.createHmac("sha256", secret)
                     *       .update(stringToSign)
                     *       .digest("hex");
                     *     ``` */
                    "X-Twenty-Webhook-Signature"?: string;
                    /** @description Unix timestamp of when the webhook was sent. This timestamp is included in the HMAC signature generation to prevent replay attacks. */
                    "X-Twenty-Webhook-Timestamp"?: string;
                    /** @description Unique identifier for this webhook request to prevent replay attacks. Consumers should ensure this nonce is not reused. */
                    "X-Twenty-Webhook-Nonce"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @example https://example.com/incomingWebhook */
                        targetUrl?: string;
                        /** @example messageParticipant.updated */
                        eventName?: string;
                        objectMetadata?: {
                            /** @example 370985db-22d8-4463-8e5f-2271d30913bd */
                            id?: string;
                            /** @enum {string} */
                            nameSingular?: "messageParticipant";
                        };
                        /** @example 872cfcf1-c79f-42bc-877d-5829f06eb3f9 */
                        workspaceId?: string;
                        /** @example 90056586-1228-4e03-a507-70140aa85c05 */
                        webhookId?: string;
                        /** @example 2024-02-14T11:27:01.779Z */
                        eventDate?: string;
                        record?: components["schemas"]["MessageParticipantForResponse"];
                        updatedFields?: string[];
                    };
                };
            };
            responses: {
                /** @description Return a 200 status to indicate that the data was received successfully */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "MessageParticipant Deleted": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description HMAC SHA256 signature of the request payload using the webhook secret. To compute the signature:
                     *     1. Concatenate `X-Twenty-Webhook-Timestamp`, a colon (:), and the JSON string of the request payload.
                     *     2. Compute the HMAC SHA256 hash using the shared secret as the key.
                     *     3. Send the resulting hex digest as this header value.
                     *     Example (Node.js):
                     *     ```javascript
                     *     const crypto = require("crypto");
                     *     const timestamp = "1735066639761";
                     *     const payload = JSON.stringify({...});
                     *     const secret = "your-secret";
                     *     const stringToSign = `${timestamp}:${JSON.stringify(payload)}`;
                     *     const signature = crypto.createHmac("sha256", secret)
                     *       .update(stringToSign)
                     *       .digest("hex");
                     *     ``` */
                    "X-Twenty-Webhook-Signature"?: string;
                    /** @description Unix timestamp of when the webhook was sent. This timestamp is included in the HMAC signature generation to prevent replay attacks. */
                    "X-Twenty-Webhook-Timestamp"?: string;
                    /** @description Unique identifier for this webhook request to prevent replay attacks. Consumers should ensure this nonce is not reused. */
                    "X-Twenty-Webhook-Nonce"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @example https://example.com/incomingWebhook */
                        targetUrl?: string;
                        /** @example messageParticipant.deleted */
                        eventName?: string;
                        objectMetadata?: {
                            /** @example 370985db-22d8-4463-8e5f-2271d30913bd */
                            id?: string;
                            /** @enum {string} */
                            nameSingular?: "messageParticipant";
                        };
                        /** @example 872cfcf1-c79f-42bc-877d-5829f06eb3f9 */
                        workspaceId?: string;
                        /** @example 90056586-1228-4e03-a507-70140aa85c05 */
                        webhookId?: string;
                        /** @example 2024-02-14T11:27:01.779Z */
                        eventDate?: string;
                        record?: components["schemas"]["MessageParticipantForResponse"];
                    };
                };
            };
            responses: {
                /** @description Return a 200 status to indicate that the data was received successfully */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "Message Created": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description HMAC SHA256 signature of the request payload using the webhook secret. To compute the signature:
                     *     1. Concatenate `X-Twenty-Webhook-Timestamp`, a colon (:), and the JSON string of the request payload.
                     *     2. Compute the HMAC SHA256 hash using the shared secret as the key.
                     *     3. Send the resulting hex digest as this header value.
                     *     Example (Node.js):
                     *     ```javascript
                     *     const crypto = require("crypto");
                     *     const timestamp = "1735066639761";
                     *     const payload = JSON.stringify({...});
                     *     const secret = "your-secret";
                     *     const stringToSign = `${timestamp}:${JSON.stringify(payload)}`;
                     *     const signature = crypto.createHmac("sha256", secret)
                     *       .update(stringToSign)
                     *       .digest("hex");
                     *     ``` */
                    "X-Twenty-Webhook-Signature"?: string;
                    /** @description Unix timestamp of when the webhook was sent. This timestamp is included in the HMAC signature generation to prevent replay attacks. */
                    "X-Twenty-Webhook-Timestamp"?: string;
                    /** @description Unique identifier for this webhook request to prevent replay attacks. Consumers should ensure this nonce is not reused. */
                    "X-Twenty-Webhook-Nonce"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @example https://example.com/incomingWebhook */
                        targetUrl?: string;
                        /** @example message.created */
                        eventName?: string;
                        objectMetadata?: {
                            /** @example 370985db-22d8-4463-8e5f-2271d30913bd */
                            id?: string;
                            /** @enum {string} */
                            nameSingular?: "message";
                        };
                        /** @example 872cfcf1-c79f-42bc-877d-5829f06eb3f9 */
                        workspaceId?: string;
                        /** @example 90056586-1228-4e03-a507-70140aa85c05 */
                        webhookId?: string;
                        /** @example 2024-02-14T11:27:01.779Z */
                        eventDate?: string;
                        record?: components["schemas"]["MessageForResponse"];
                    };
                };
            };
            responses: {
                /** @description Return a 200 status to indicate that the data was received successfully */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "Message Updated": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description HMAC SHA256 signature of the request payload using the webhook secret. To compute the signature:
                     *     1. Concatenate `X-Twenty-Webhook-Timestamp`, a colon (:), and the JSON string of the request payload.
                     *     2. Compute the HMAC SHA256 hash using the shared secret as the key.
                     *     3. Send the resulting hex digest as this header value.
                     *     Example (Node.js):
                     *     ```javascript
                     *     const crypto = require("crypto");
                     *     const timestamp = "1735066639761";
                     *     const payload = JSON.stringify({...});
                     *     const secret = "your-secret";
                     *     const stringToSign = `${timestamp}:${JSON.stringify(payload)}`;
                     *     const signature = crypto.createHmac("sha256", secret)
                     *       .update(stringToSign)
                     *       .digest("hex");
                     *     ``` */
                    "X-Twenty-Webhook-Signature"?: string;
                    /** @description Unix timestamp of when the webhook was sent. This timestamp is included in the HMAC signature generation to prevent replay attacks. */
                    "X-Twenty-Webhook-Timestamp"?: string;
                    /** @description Unique identifier for this webhook request to prevent replay attacks. Consumers should ensure this nonce is not reused. */
                    "X-Twenty-Webhook-Nonce"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @example https://example.com/incomingWebhook */
                        targetUrl?: string;
                        /** @example message.updated */
                        eventName?: string;
                        objectMetadata?: {
                            /** @example 370985db-22d8-4463-8e5f-2271d30913bd */
                            id?: string;
                            /** @enum {string} */
                            nameSingular?: "message";
                        };
                        /** @example 872cfcf1-c79f-42bc-877d-5829f06eb3f9 */
                        workspaceId?: string;
                        /** @example 90056586-1228-4e03-a507-70140aa85c05 */
                        webhookId?: string;
                        /** @example 2024-02-14T11:27:01.779Z */
                        eventDate?: string;
                        record?: components["schemas"]["MessageForResponse"];
                        updatedFields?: string[];
                    };
                };
            };
            responses: {
                /** @description Return a 200 status to indicate that the data was received successfully */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "Message Deleted": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description HMAC SHA256 signature of the request payload using the webhook secret. To compute the signature:
                     *     1. Concatenate `X-Twenty-Webhook-Timestamp`, a colon (:), and the JSON string of the request payload.
                     *     2. Compute the HMAC SHA256 hash using the shared secret as the key.
                     *     3. Send the resulting hex digest as this header value.
                     *     Example (Node.js):
                     *     ```javascript
                     *     const crypto = require("crypto");
                     *     const timestamp = "1735066639761";
                     *     const payload = JSON.stringify({...});
                     *     const secret = "your-secret";
                     *     const stringToSign = `${timestamp}:${JSON.stringify(payload)}`;
                     *     const signature = crypto.createHmac("sha256", secret)
                     *       .update(stringToSign)
                     *       .digest("hex");
                     *     ``` */
                    "X-Twenty-Webhook-Signature"?: string;
                    /** @description Unix timestamp of when the webhook was sent. This timestamp is included in the HMAC signature generation to prevent replay attacks. */
                    "X-Twenty-Webhook-Timestamp"?: string;
                    /** @description Unique identifier for this webhook request to prevent replay attacks. Consumers should ensure this nonce is not reused. */
                    "X-Twenty-Webhook-Nonce"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @example https://example.com/incomingWebhook */
                        targetUrl?: string;
                        /** @example message.deleted */
                        eventName?: string;
                        objectMetadata?: {
                            /** @example 370985db-22d8-4463-8e5f-2271d30913bd */
                            id?: string;
                            /** @enum {string} */
                            nameSingular?: "message";
                        };
                        /** @example 872cfcf1-c79f-42bc-877d-5829f06eb3f9 */
                        workspaceId?: string;
                        /** @example 90056586-1228-4e03-a507-70140aa85c05 */
                        webhookId?: string;
                        /** @example 2024-02-14T11:27:01.779Z */
                        eventDate?: string;
                        record?: components["schemas"]["MessageForResponse"];
                    };
                };
            };
            responses: {
                /** @description Return a 200 status to indicate that the data was received successfully */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "MessageThread Created": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description HMAC SHA256 signature of the request payload using the webhook secret. To compute the signature:
                     *     1. Concatenate `X-Twenty-Webhook-Timestamp`, a colon (:), and the JSON string of the request payload.
                     *     2. Compute the HMAC SHA256 hash using the shared secret as the key.
                     *     3. Send the resulting hex digest as this header value.
                     *     Example (Node.js):
                     *     ```javascript
                     *     const crypto = require("crypto");
                     *     const timestamp = "1735066639761";
                     *     const payload = JSON.stringify({...});
                     *     const secret = "your-secret";
                     *     const stringToSign = `${timestamp}:${JSON.stringify(payload)}`;
                     *     const signature = crypto.createHmac("sha256", secret)
                     *       .update(stringToSign)
                     *       .digest("hex");
                     *     ``` */
                    "X-Twenty-Webhook-Signature"?: string;
                    /** @description Unix timestamp of when the webhook was sent. This timestamp is included in the HMAC signature generation to prevent replay attacks. */
                    "X-Twenty-Webhook-Timestamp"?: string;
                    /** @description Unique identifier for this webhook request to prevent replay attacks. Consumers should ensure this nonce is not reused. */
                    "X-Twenty-Webhook-Nonce"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @example https://example.com/incomingWebhook */
                        targetUrl?: string;
                        /** @example messageThread.created */
                        eventName?: string;
                        objectMetadata?: {
                            /** @example 370985db-22d8-4463-8e5f-2271d30913bd */
                            id?: string;
                            /** @enum {string} */
                            nameSingular?: "messageThread";
                        };
                        /** @example 872cfcf1-c79f-42bc-877d-5829f06eb3f9 */
                        workspaceId?: string;
                        /** @example 90056586-1228-4e03-a507-70140aa85c05 */
                        webhookId?: string;
                        /** @example 2024-02-14T11:27:01.779Z */
                        eventDate?: string;
                        record?: components["schemas"]["MessageThreadForResponse"];
                    };
                };
            };
            responses: {
                /** @description Return a 200 status to indicate that the data was received successfully */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "MessageThread Updated": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description HMAC SHA256 signature of the request payload using the webhook secret. To compute the signature:
                     *     1. Concatenate `X-Twenty-Webhook-Timestamp`, a colon (:), and the JSON string of the request payload.
                     *     2. Compute the HMAC SHA256 hash using the shared secret as the key.
                     *     3. Send the resulting hex digest as this header value.
                     *     Example (Node.js):
                     *     ```javascript
                     *     const crypto = require("crypto");
                     *     const timestamp = "1735066639761";
                     *     const payload = JSON.stringify({...});
                     *     const secret = "your-secret";
                     *     const stringToSign = `${timestamp}:${JSON.stringify(payload)}`;
                     *     const signature = crypto.createHmac("sha256", secret)
                     *       .update(stringToSign)
                     *       .digest("hex");
                     *     ``` */
                    "X-Twenty-Webhook-Signature"?: string;
                    /** @description Unix timestamp of when the webhook was sent. This timestamp is included in the HMAC signature generation to prevent replay attacks. */
                    "X-Twenty-Webhook-Timestamp"?: string;
                    /** @description Unique identifier for this webhook request to prevent replay attacks. Consumers should ensure this nonce is not reused. */
                    "X-Twenty-Webhook-Nonce"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @example https://example.com/incomingWebhook */
                        targetUrl?: string;
                        /** @example messageThread.updated */
                        eventName?: string;
                        objectMetadata?: {
                            /** @example 370985db-22d8-4463-8e5f-2271d30913bd */
                            id?: string;
                            /** @enum {string} */
                            nameSingular?: "messageThread";
                        };
                        /** @example 872cfcf1-c79f-42bc-877d-5829f06eb3f9 */
                        workspaceId?: string;
                        /** @example 90056586-1228-4e03-a507-70140aa85c05 */
                        webhookId?: string;
                        /** @example 2024-02-14T11:27:01.779Z */
                        eventDate?: string;
                        record?: components["schemas"]["MessageThreadForResponse"];
                        updatedFields?: string[];
                    };
                };
            };
            responses: {
                /** @description Return a 200 status to indicate that the data was received successfully */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "MessageThread Deleted": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description HMAC SHA256 signature of the request payload using the webhook secret. To compute the signature:
                     *     1. Concatenate `X-Twenty-Webhook-Timestamp`, a colon (:), and the JSON string of the request payload.
                     *     2. Compute the HMAC SHA256 hash using the shared secret as the key.
                     *     3. Send the resulting hex digest as this header value.
                     *     Example (Node.js):
                     *     ```javascript
                     *     const crypto = require("crypto");
                     *     const timestamp = "1735066639761";
                     *     const payload = JSON.stringify({...});
                     *     const secret = "your-secret";
                     *     const stringToSign = `${timestamp}:${JSON.stringify(payload)}`;
                     *     const signature = crypto.createHmac("sha256", secret)
                     *       .update(stringToSign)
                     *       .digest("hex");
                     *     ``` */
                    "X-Twenty-Webhook-Signature"?: string;
                    /** @description Unix timestamp of when the webhook was sent. This timestamp is included in the HMAC signature generation to prevent replay attacks. */
                    "X-Twenty-Webhook-Timestamp"?: string;
                    /** @description Unique identifier for this webhook request to prevent replay attacks. Consumers should ensure this nonce is not reused. */
                    "X-Twenty-Webhook-Nonce"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @example https://example.com/incomingWebhook */
                        targetUrl?: string;
                        /** @example messageThread.deleted */
                        eventName?: string;
                        objectMetadata?: {
                            /** @example 370985db-22d8-4463-8e5f-2271d30913bd */
                            id?: string;
                            /** @enum {string} */
                            nameSingular?: "messageThread";
                        };
                        /** @example 872cfcf1-c79f-42bc-877d-5829f06eb3f9 */
                        workspaceId?: string;
                        /** @example 90056586-1228-4e03-a507-70140aa85c05 */
                        webhookId?: string;
                        /** @example 2024-02-14T11:27:01.779Z */
                        eventDate?: string;
                        record?: components["schemas"]["MessageThreadForResponse"];
                    };
                };
            };
            responses: {
                /** @description Return a 200 status to indicate that the data was received successfully */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "Note Created": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description HMAC SHA256 signature of the request payload using the webhook secret. To compute the signature:
                     *     1. Concatenate `X-Twenty-Webhook-Timestamp`, a colon (:), and the JSON string of the request payload.
                     *     2. Compute the HMAC SHA256 hash using the shared secret as the key.
                     *     3. Send the resulting hex digest as this header value.
                     *     Example (Node.js):
                     *     ```javascript
                     *     const crypto = require("crypto");
                     *     const timestamp = "1735066639761";
                     *     const payload = JSON.stringify({...});
                     *     const secret = "your-secret";
                     *     const stringToSign = `${timestamp}:${JSON.stringify(payload)}`;
                     *     const signature = crypto.createHmac("sha256", secret)
                     *       .update(stringToSign)
                     *       .digest("hex");
                     *     ``` */
                    "X-Twenty-Webhook-Signature"?: string;
                    /** @description Unix timestamp of when the webhook was sent. This timestamp is included in the HMAC signature generation to prevent replay attacks. */
                    "X-Twenty-Webhook-Timestamp"?: string;
                    /** @description Unique identifier for this webhook request to prevent replay attacks. Consumers should ensure this nonce is not reused. */
                    "X-Twenty-Webhook-Nonce"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @example https://example.com/incomingWebhook */
                        targetUrl?: string;
                        /** @example note.created */
                        eventName?: string;
                        objectMetadata?: {
                            /** @example 370985db-22d8-4463-8e5f-2271d30913bd */
                            id?: string;
                            /** @enum {string} */
                            nameSingular?: "note";
                        };
                        /** @example 872cfcf1-c79f-42bc-877d-5829f06eb3f9 */
                        workspaceId?: string;
                        /** @example 90056586-1228-4e03-a507-70140aa85c05 */
                        webhookId?: string;
                        /** @example 2024-02-14T11:27:01.779Z */
                        eventDate?: string;
                        record?: components["schemas"]["NoteForResponse"];
                    };
                };
            };
            responses: {
                /** @description Return a 200 status to indicate that the data was received successfully */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "Note Updated": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description HMAC SHA256 signature of the request payload using the webhook secret. To compute the signature:
                     *     1. Concatenate `X-Twenty-Webhook-Timestamp`, a colon (:), and the JSON string of the request payload.
                     *     2. Compute the HMAC SHA256 hash using the shared secret as the key.
                     *     3. Send the resulting hex digest as this header value.
                     *     Example (Node.js):
                     *     ```javascript
                     *     const crypto = require("crypto");
                     *     const timestamp = "1735066639761";
                     *     const payload = JSON.stringify({...});
                     *     const secret = "your-secret";
                     *     const stringToSign = `${timestamp}:${JSON.stringify(payload)}`;
                     *     const signature = crypto.createHmac("sha256", secret)
                     *       .update(stringToSign)
                     *       .digest("hex");
                     *     ``` */
                    "X-Twenty-Webhook-Signature"?: string;
                    /** @description Unix timestamp of when the webhook was sent. This timestamp is included in the HMAC signature generation to prevent replay attacks. */
                    "X-Twenty-Webhook-Timestamp"?: string;
                    /** @description Unique identifier for this webhook request to prevent replay attacks. Consumers should ensure this nonce is not reused. */
                    "X-Twenty-Webhook-Nonce"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @example https://example.com/incomingWebhook */
                        targetUrl?: string;
                        /** @example note.updated */
                        eventName?: string;
                        objectMetadata?: {
                            /** @example 370985db-22d8-4463-8e5f-2271d30913bd */
                            id?: string;
                            /** @enum {string} */
                            nameSingular?: "note";
                        };
                        /** @example 872cfcf1-c79f-42bc-877d-5829f06eb3f9 */
                        workspaceId?: string;
                        /** @example 90056586-1228-4e03-a507-70140aa85c05 */
                        webhookId?: string;
                        /** @example 2024-02-14T11:27:01.779Z */
                        eventDate?: string;
                        record?: components["schemas"]["NoteForResponse"];
                        updatedFields?: string[];
                    };
                };
            };
            responses: {
                /** @description Return a 200 status to indicate that the data was received successfully */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "Note Deleted": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description HMAC SHA256 signature of the request payload using the webhook secret. To compute the signature:
                     *     1. Concatenate `X-Twenty-Webhook-Timestamp`, a colon (:), and the JSON string of the request payload.
                     *     2. Compute the HMAC SHA256 hash using the shared secret as the key.
                     *     3. Send the resulting hex digest as this header value.
                     *     Example (Node.js):
                     *     ```javascript
                     *     const crypto = require("crypto");
                     *     const timestamp = "1735066639761";
                     *     const payload = JSON.stringify({...});
                     *     const secret = "your-secret";
                     *     const stringToSign = `${timestamp}:${JSON.stringify(payload)}`;
                     *     const signature = crypto.createHmac("sha256", secret)
                     *       .update(stringToSign)
                     *       .digest("hex");
                     *     ``` */
                    "X-Twenty-Webhook-Signature"?: string;
                    /** @description Unix timestamp of when the webhook was sent. This timestamp is included in the HMAC signature generation to prevent replay attacks. */
                    "X-Twenty-Webhook-Timestamp"?: string;
                    /** @description Unique identifier for this webhook request to prevent replay attacks. Consumers should ensure this nonce is not reused. */
                    "X-Twenty-Webhook-Nonce"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @example https://example.com/incomingWebhook */
                        targetUrl?: string;
                        /** @example note.deleted */
                        eventName?: string;
                        objectMetadata?: {
                            /** @example 370985db-22d8-4463-8e5f-2271d30913bd */
                            id?: string;
                            /** @enum {string} */
                            nameSingular?: "note";
                        };
                        /** @example 872cfcf1-c79f-42bc-877d-5829f06eb3f9 */
                        workspaceId?: string;
                        /** @example 90056586-1228-4e03-a507-70140aa85c05 */
                        webhookId?: string;
                        /** @example 2024-02-14T11:27:01.779Z */
                        eventDate?: string;
                        record?: components["schemas"]["NoteForResponse"];
                    };
                };
            };
            responses: {
                /** @description Return a 200 status to indicate that the data was received successfully */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "NoteTarget Created": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description HMAC SHA256 signature of the request payload using the webhook secret. To compute the signature:
                     *     1. Concatenate `X-Twenty-Webhook-Timestamp`, a colon (:), and the JSON string of the request payload.
                     *     2. Compute the HMAC SHA256 hash using the shared secret as the key.
                     *     3. Send the resulting hex digest as this header value.
                     *     Example (Node.js):
                     *     ```javascript
                     *     const crypto = require("crypto");
                     *     const timestamp = "1735066639761";
                     *     const payload = JSON.stringify({...});
                     *     const secret = "your-secret";
                     *     const stringToSign = `${timestamp}:${JSON.stringify(payload)}`;
                     *     const signature = crypto.createHmac("sha256", secret)
                     *       .update(stringToSign)
                     *       .digest("hex");
                     *     ``` */
                    "X-Twenty-Webhook-Signature"?: string;
                    /** @description Unix timestamp of when the webhook was sent. This timestamp is included in the HMAC signature generation to prevent replay attacks. */
                    "X-Twenty-Webhook-Timestamp"?: string;
                    /** @description Unique identifier for this webhook request to prevent replay attacks. Consumers should ensure this nonce is not reused. */
                    "X-Twenty-Webhook-Nonce"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @example https://example.com/incomingWebhook */
                        targetUrl?: string;
                        /** @example noteTarget.created */
                        eventName?: string;
                        objectMetadata?: {
                            /** @example 370985db-22d8-4463-8e5f-2271d30913bd */
                            id?: string;
                            /** @enum {string} */
                            nameSingular?: "noteTarget";
                        };
                        /** @example 872cfcf1-c79f-42bc-877d-5829f06eb3f9 */
                        workspaceId?: string;
                        /** @example 90056586-1228-4e03-a507-70140aa85c05 */
                        webhookId?: string;
                        /** @example 2024-02-14T11:27:01.779Z */
                        eventDate?: string;
                        record?: components["schemas"]["NoteTargetForResponse"];
                    };
                };
            };
            responses: {
                /** @description Return a 200 status to indicate that the data was received successfully */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "NoteTarget Updated": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description HMAC SHA256 signature of the request payload using the webhook secret. To compute the signature:
                     *     1. Concatenate `X-Twenty-Webhook-Timestamp`, a colon (:), and the JSON string of the request payload.
                     *     2. Compute the HMAC SHA256 hash using the shared secret as the key.
                     *     3. Send the resulting hex digest as this header value.
                     *     Example (Node.js):
                     *     ```javascript
                     *     const crypto = require("crypto");
                     *     const timestamp = "1735066639761";
                     *     const payload = JSON.stringify({...});
                     *     const secret = "your-secret";
                     *     const stringToSign = `${timestamp}:${JSON.stringify(payload)}`;
                     *     const signature = crypto.createHmac("sha256", secret)
                     *       .update(stringToSign)
                     *       .digest("hex");
                     *     ``` */
                    "X-Twenty-Webhook-Signature"?: string;
                    /** @description Unix timestamp of when the webhook was sent. This timestamp is included in the HMAC signature generation to prevent replay attacks. */
                    "X-Twenty-Webhook-Timestamp"?: string;
                    /** @description Unique identifier for this webhook request to prevent replay attacks. Consumers should ensure this nonce is not reused. */
                    "X-Twenty-Webhook-Nonce"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @example https://example.com/incomingWebhook */
                        targetUrl?: string;
                        /** @example noteTarget.updated */
                        eventName?: string;
                        objectMetadata?: {
                            /** @example 370985db-22d8-4463-8e5f-2271d30913bd */
                            id?: string;
                            /** @enum {string} */
                            nameSingular?: "noteTarget";
                        };
                        /** @example 872cfcf1-c79f-42bc-877d-5829f06eb3f9 */
                        workspaceId?: string;
                        /** @example 90056586-1228-4e03-a507-70140aa85c05 */
                        webhookId?: string;
                        /** @example 2024-02-14T11:27:01.779Z */
                        eventDate?: string;
                        record?: components["schemas"]["NoteTargetForResponse"];
                        updatedFields?: string[];
                    };
                };
            };
            responses: {
                /** @description Return a 200 status to indicate that the data was received successfully */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "NoteTarget Deleted": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description HMAC SHA256 signature of the request payload using the webhook secret. To compute the signature:
                     *     1. Concatenate `X-Twenty-Webhook-Timestamp`, a colon (:), and the JSON string of the request payload.
                     *     2. Compute the HMAC SHA256 hash using the shared secret as the key.
                     *     3. Send the resulting hex digest as this header value.
                     *     Example (Node.js):
                     *     ```javascript
                     *     const crypto = require("crypto");
                     *     const timestamp = "1735066639761";
                     *     const payload = JSON.stringify({...});
                     *     const secret = "your-secret";
                     *     const stringToSign = `${timestamp}:${JSON.stringify(payload)}`;
                     *     const signature = crypto.createHmac("sha256", secret)
                     *       .update(stringToSign)
                     *       .digest("hex");
                     *     ``` */
                    "X-Twenty-Webhook-Signature"?: string;
                    /** @description Unix timestamp of when the webhook was sent. This timestamp is included in the HMAC signature generation to prevent replay attacks. */
                    "X-Twenty-Webhook-Timestamp"?: string;
                    /** @description Unique identifier for this webhook request to prevent replay attacks. Consumers should ensure this nonce is not reused. */
                    "X-Twenty-Webhook-Nonce"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @example https://example.com/incomingWebhook */
                        targetUrl?: string;
                        /** @example noteTarget.deleted */
                        eventName?: string;
                        objectMetadata?: {
                            /** @example 370985db-22d8-4463-8e5f-2271d30913bd */
                            id?: string;
                            /** @enum {string} */
                            nameSingular?: "noteTarget";
                        };
                        /** @example 872cfcf1-c79f-42bc-877d-5829f06eb3f9 */
                        workspaceId?: string;
                        /** @example 90056586-1228-4e03-a507-70140aa85c05 */
                        webhookId?: string;
                        /** @example 2024-02-14T11:27:01.779Z */
                        eventDate?: string;
                        record?: components["schemas"]["NoteTargetForResponse"];
                    };
                };
            };
            responses: {
                /** @description Return a 200 status to indicate that the data was received successfully */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "Opportunity Created": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description HMAC SHA256 signature of the request payload using the webhook secret. To compute the signature:
                     *     1. Concatenate `X-Twenty-Webhook-Timestamp`, a colon (:), and the JSON string of the request payload.
                     *     2. Compute the HMAC SHA256 hash using the shared secret as the key.
                     *     3. Send the resulting hex digest as this header value.
                     *     Example (Node.js):
                     *     ```javascript
                     *     const crypto = require("crypto");
                     *     const timestamp = "1735066639761";
                     *     const payload = JSON.stringify({...});
                     *     const secret = "your-secret";
                     *     const stringToSign = `${timestamp}:${JSON.stringify(payload)}`;
                     *     const signature = crypto.createHmac("sha256", secret)
                     *       .update(stringToSign)
                     *       .digest("hex");
                     *     ``` */
                    "X-Twenty-Webhook-Signature"?: string;
                    /** @description Unix timestamp of when the webhook was sent. This timestamp is included in the HMAC signature generation to prevent replay attacks. */
                    "X-Twenty-Webhook-Timestamp"?: string;
                    /** @description Unique identifier for this webhook request to prevent replay attacks. Consumers should ensure this nonce is not reused. */
                    "X-Twenty-Webhook-Nonce"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @example https://example.com/incomingWebhook */
                        targetUrl?: string;
                        /** @example opportunity.created */
                        eventName?: string;
                        objectMetadata?: {
                            /** @example 370985db-22d8-4463-8e5f-2271d30913bd */
                            id?: string;
                            /** @enum {string} */
                            nameSingular?: "opportunity";
                        };
                        /** @example 872cfcf1-c79f-42bc-877d-5829f06eb3f9 */
                        workspaceId?: string;
                        /** @example 90056586-1228-4e03-a507-70140aa85c05 */
                        webhookId?: string;
                        /** @example 2024-02-14T11:27:01.779Z */
                        eventDate?: string;
                        record?: components["schemas"]["OpportunityForResponse"];
                    };
                };
            };
            responses: {
                /** @description Return a 200 status to indicate that the data was received successfully */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "Opportunity Updated": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description HMAC SHA256 signature of the request payload using the webhook secret. To compute the signature:
                     *     1. Concatenate `X-Twenty-Webhook-Timestamp`, a colon (:), and the JSON string of the request payload.
                     *     2. Compute the HMAC SHA256 hash using the shared secret as the key.
                     *     3. Send the resulting hex digest as this header value.
                     *     Example (Node.js):
                     *     ```javascript
                     *     const crypto = require("crypto");
                     *     const timestamp = "1735066639761";
                     *     const payload = JSON.stringify({...});
                     *     const secret = "your-secret";
                     *     const stringToSign = `${timestamp}:${JSON.stringify(payload)}`;
                     *     const signature = crypto.createHmac("sha256", secret)
                     *       .update(stringToSign)
                     *       .digest("hex");
                     *     ``` */
                    "X-Twenty-Webhook-Signature"?: string;
                    /** @description Unix timestamp of when the webhook was sent. This timestamp is included in the HMAC signature generation to prevent replay attacks. */
                    "X-Twenty-Webhook-Timestamp"?: string;
                    /** @description Unique identifier for this webhook request to prevent replay attacks. Consumers should ensure this nonce is not reused. */
                    "X-Twenty-Webhook-Nonce"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @example https://example.com/incomingWebhook */
                        targetUrl?: string;
                        /** @example opportunity.updated */
                        eventName?: string;
                        objectMetadata?: {
                            /** @example 370985db-22d8-4463-8e5f-2271d30913bd */
                            id?: string;
                            /** @enum {string} */
                            nameSingular?: "opportunity";
                        };
                        /** @example 872cfcf1-c79f-42bc-877d-5829f06eb3f9 */
                        workspaceId?: string;
                        /** @example 90056586-1228-4e03-a507-70140aa85c05 */
                        webhookId?: string;
                        /** @example 2024-02-14T11:27:01.779Z */
                        eventDate?: string;
                        record?: components["schemas"]["OpportunityForResponse"];
                        updatedFields?: string[];
                    };
                };
            };
            responses: {
                /** @description Return a 200 status to indicate that the data was received successfully */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "Opportunity Deleted": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description HMAC SHA256 signature of the request payload using the webhook secret. To compute the signature:
                     *     1. Concatenate `X-Twenty-Webhook-Timestamp`, a colon (:), and the JSON string of the request payload.
                     *     2. Compute the HMAC SHA256 hash using the shared secret as the key.
                     *     3. Send the resulting hex digest as this header value.
                     *     Example (Node.js):
                     *     ```javascript
                     *     const crypto = require("crypto");
                     *     const timestamp = "1735066639761";
                     *     const payload = JSON.stringify({...});
                     *     const secret = "your-secret";
                     *     const stringToSign = `${timestamp}:${JSON.stringify(payload)}`;
                     *     const signature = crypto.createHmac("sha256", secret)
                     *       .update(stringToSign)
                     *       .digest("hex");
                     *     ``` */
                    "X-Twenty-Webhook-Signature"?: string;
                    /** @description Unix timestamp of when the webhook was sent. This timestamp is included in the HMAC signature generation to prevent replay attacks. */
                    "X-Twenty-Webhook-Timestamp"?: string;
                    /** @description Unique identifier for this webhook request to prevent replay attacks. Consumers should ensure this nonce is not reused. */
                    "X-Twenty-Webhook-Nonce"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @example https://example.com/incomingWebhook */
                        targetUrl?: string;
                        /** @example opportunity.deleted */
                        eventName?: string;
                        objectMetadata?: {
                            /** @example 370985db-22d8-4463-8e5f-2271d30913bd */
                            id?: string;
                            /** @enum {string} */
                            nameSingular?: "opportunity";
                        };
                        /** @example 872cfcf1-c79f-42bc-877d-5829f06eb3f9 */
                        workspaceId?: string;
                        /** @example 90056586-1228-4e03-a507-70140aa85c05 */
                        webhookId?: string;
                        /** @example 2024-02-14T11:27:01.779Z */
                        eventDate?: string;
                        record?: components["schemas"]["OpportunityForResponse"];
                    };
                };
            };
            responses: {
                /** @description Return a 200 status to indicate that the data was received successfully */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "Person Created": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description HMAC SHA256 signature of the request payload using the webhook secret. To compute the signature:
                     *     1. Concatenate `X-Twenty-Webhook-Timestamp`, a colon (:), and the JSON string of the request payload.
                     *     2. Compute the HMAC SHA256 hash using the shared secret as the key.
                     *     3. Send the resulting hex digest as this header value.
                     *     Example (Node.js):
                     *     ```javascript
                     *     const crypto = require("crypto");
                     *     const timestamp = "1735066639761";
                     *     const payload = JSON.stringify({...});
                     *     const secret = "your-secret";
                     *     const stringToSign = `${timestamp}:${JSON.stringify(payload)}`;
                     *     const signature = crypto.createHmac("sha256", secret)
                     *       .update(stringToSign)
                     *       .digest("hex");
                     *     ``` */
                    "X-Twenty-Webhook-Signature"?: string;
                    /** @description Unix timestamp of when the webhook was sent. This timestamp is included in the HMAC signature generation to prevent replay attacks. */
                    "X-Twenty-Webhook-Timestamp"?: string;
                    /** @description Unique identifier for this webhook request to prevent replay attacks. Consumers should ensure this nonce is not reused. */
                    "X-Twenty-Webhook-Nonce"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @example https://example.com/incomingWebhook */
                        targetUrl?: string;
                        /** @example person.created */
                        eventName?: string;
                        objectMetadata?: {
                            /** @example 370985db-22d8-4463-8e5f-2271d30913bd */
                            id?: string;
                            /** @enum {string} */
                            nameSingular?: "person";
                        };
                        /** @example 872cfcf1-c79f-42bc-877d-5829f06eb3f9 */
                        workspaceId?: string;
                        /** @example 90056586-1228-4e03-a507-70140aa85c05 */
                        webhookId?: string;
                        /** @example 2024-02-14T11:27:01.779Z */
                        eventDate?: string;
                        record?: components["schemas"]["PersonForResponse"];
                    };
                };
            };
            responses: {
                /** @description Return a 200 status to indicate that the data was received successfully */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "Person Updated": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description HMAC SHA256 signature of the request payload using the webhook secret. To compute the signature:
                     *     1. Concatenate `X-Twenty-Webhook-Timestamp`, a colon (:), and the JSON string of the request payload.
                     *     2. Compute the HMAC SHA256 hash using the shared secret as the key.
                     *     3. Send the resulting hex digest as this header value.
                     *     Example (Node.js):
                     *     ```javascript
                     *     const crypto = require("crypto");
                     *     const timestamp = "1735066639761";
                     *     const payload = JSON.stringify({...});
                     *     const secret = "your-secret";
                     *     const stringToSign = `${timestamp}:${JSON.stringify(payload)}`;
                     *     const signature = crypto.createHmac("sha256", secret)
                     *       .update(stringToSign)
                     *       .digest("hex");
                     *     ``` */
                    "X-Twenty-Webhook-Signature"?: string;
                    /** @description Unix timestamp of when the webhook was sent. This timestamp is included in the HMAC signature generation to prevent replay attacks. */
                    "X-Twenty-Webhook-Timestamp"?: string;
                    /** @description Unique identifier for this webhook request to prevent replay attacks. Consumers should ensure this nonce is not reused. */
                    "X-Twenty-Webhook-Nonce"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @example https://example.com/incomingWebhook */
                        targetUrl?: string;
                        /** @example person.updated */
                        eventName?: string;
                        objectMetadata?: {
                            /** @example 370985db-22d8-4463-8e5f-2271d30913bd */
                            id?: string;
                            /** @enum {string} */
                            nameSingular?: "person";
                        };
                        /** @example 872cfcf1-c79f-42bc-877d-5829f06eb3f9 */
                        workspaceId?: string;
                        /** @example 90056586-1228-4e03-a507-70140aa85c05 */
                        webhookId?: string;
                        /** @example 2024-02-14T11:27:01.779Z */
                        eventDate?: string;
                        record?: components["schemas"]["PersonForResponse"];
                        updatedFields?: string[];
                    };
                };
            };
            responses: {
                /** @description Return a 200 status to indicate that the data was received successfully */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "Person Deleted": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description HMAC SHA256 signature of the request payload using the webhook secret. To compute the signature:
                     *     1. Concatenate `X-Twenty-Webhook-Timestamp`, a colon (:), and the JSON string of the request payload.
                     *     2. Compute the HMAC SHA256 hash using the shared secret as the key.
                     *     3. Send the resulting hex digest as this header value.
                     *     Example (Node.js):
                     *     ```javascript
                     *     const crypto = require("crypto");
                     *     const timestamp = "1735066639761";
                     *     const payload = JSON.stringify({...});
                     *     const secret = "your-secret";
                     *     const stringToSign = `${timestamp}:${JSON.stringify(payload)}`;
                     *     const signature = crypto.createHmac("sha256", secret)
                     *       .update(stringToSign)
                     *       .digest("hex");
                     *     ``` */
                    "X-Twenty-Webhook-Signature"?: string;
                    /** @description Unix timestamp of when the webhook was sent. This timestamp is included in the HMAC signature generation to prevent replay attacks. */
                    "X-Twenty-Webhook-Timestamp"?: string;
                    /** @description Unique identifier for this webhook request to prevent replay attacks. Consumers should ensure this nonce is not reused. */
                    "X-Twenty-Webhook-Nonce"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @example https://example.com/incomingWebhook */
                        targetUrl?: string;
                        /** @example person.deleted */
                        eventName?: string;
                        objectMetadata?: {
                            /** @example 370985db-22d8-4463-8e5f-2271d30913bd */
                            id?: string;
                            /** @enum {string} */
                            nameSingular?: "person";
                        };
                        /** @example 872cfcf1-c79f-42bc-877d-5829f06eb3f9 */
                        workspaceId?: string;
                        /** @example 90056586-1228-4e03-a507-70140aa85c05 */
                        webhookId?: string;
                        /** @example 2024-02-14T11:27:01.779Z */
                        eventDate?: string;
                        record?: components["schemas"]["PersonForResponse"];
                    };
                };
            };
            responses: {
                /** @description Return a 200 status to indicate that the data was received successfully */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "Task Created": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description HMAC SHA256 signature of the request payload using the webhook secret. To compute the signature:
                     *     1. Concatenate `X-Twenty-Webhook-Timestamp`, a colon (:), and the JSON string of the request payload.
                     *     2. Compute the HMAC SHA256 hash using the shared secret as the key.
                     *     3. Send the resulting hex digest as this header value.
                     *     Example (Node.js):
                     *     ```javascript
                     *     const crypto = require("crypto");
                     *     const timestamp = "1735066639761";
                     *     const payload = JSON.stringify({...});
                     *     const secret = "your-secret";
                     *     const stringToSign = `${timestamp}:${JSON.stringify(payload)}`;
                     *     const signature = crypto.createHmac("sha256", secret)
                     *       .update(stringToSign)
                     *       .digest("hex");
                     *     ``` */
                    "X-Twenty-Webhook-Signature"?: string;
                    /** @description Unix timestamp of when the webhook was sent. This timestamp is included in the HMAC signature generation to prevent replay attacks. */
                    "X-Twenty-Webhook-Timestamp"?: string;
                    /** @description Unique identifier for this webhook request to prevent replay attacks. Consumers should ensure this nonce is not reused. */
                    "X-Twenty-Webhook-Nonce"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @example https://example.com/incomingWebhook */
                        targetUrl?: string;
                        /** @example task.created */
                        eventName?: string;
                        objectMetadata?: {
                            /** @example 370985db-22d8-4463-8e5f-2271d30913bd */
                            id?: string;
                            /** @enum {string} */
                            nameSingular?: "task";
                        };
                        /** @example 872cfcf1-c79f-42bc-877d-5829f06eb3f9 */
                        workspaceId?: string;
                        /** @example 90056586-1228-4e03-a507-70140aa85c05 */
                        webhookId?: string;
                        /** @example 2024-02-14T11:27:01.779Z */
                        eventDate?: string;
                        record?: components["schemas"]["TaskForResponse"];
                    };
                };
            };
            responses: {
                /** @description Return a 200 status to indicate that the data was received successfully */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "Task Updated": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description HMAC SHA256 signature of the request payload using the webhook secret. To compute the signature:
                     *     1. Concatenate `X-Twenty-Webhook-Timestamp`, a colon (:), and the JSON string of the request payload.
                     *     2. Compute the HMAC SHA256 hash using the shared secret as the key.
                     *     3. Send the resulting hex digest as this header value.
                     *     Example (Node.js):
                     *     ```javascript
                     *     const crypto = require("crypto");
                     *     const timestamp = "1735066639761";
                     *     const payload = JSON.stringify({...});
                     *     const secret = "your-secret";
                     *     const stringToSign = `${timestamp}:${JSON.stringify(payload)}`;
                     *     const signature = crypto.createHmac("sha256", secret)
                     *       .update(stringToSign)
                     *       .digest("hex");
                     *     ``` */
                    "X-Twenty-Webhook-Signature"?: string;
                    /** @description Unix timestamp of when the webhook was sent. This timestamp is included in the HMAC signature generation to prevent replay attacks. */
                    "X-Twenty-Webhook-Timestamp"?: string;
                    /** @description Unique identifier for this webhook request to prevent replay attacks. Consumers should ensure this nonce is not reused. */
                    "X-Twenty-Webhook-Nonce"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @example https://example.com/incomingWebhook */
                        targetUrl?: string;
                        /** @example task.updated */
                        eventName?: string;
                        objectMetadata?: {
                            /** @example 370985db-22d8-4463-8e5f-2271d30913bd */
                            id?: string;
                            /** @enum {string} */
                            nameSingular?: "task";
                        };
                        /** @example 872cfcf1-c79f-42bc-877d-5829f06eb3f9 */
                        workspaceId?: string;
                        /** @example 90056586-1228-4e03-a507-70140aa85c05 */
                        webhookId?: string;
                        /** @example 2024-02-14T11:27:01.779Z */
                        eventDate?: string;
                        record?: components["schemas"]["TaskForResponse"];
                        updatedFields?: string[];
                    };
                };
            };
            responses: {
                /** @description Return a 200 status to indicate that the data was received successfully */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "Task Deleted": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description HMAC SHA256 signature of the request payload using the webhook secret. To compute the signature:
                     *     1. Concatenate `X-Twenty-Webhook-Timestamp`, a colon (:), and the JSON string of the request payload.
                     *     2. Compute the HMAC SHA256 hash using the shared secret as the key.
                     *     3. Send the resulting hex digest as this header value.
                     *     Example (Node.js):
                     *     ```javascript
                     *     const crypto = require("crypto");
                     *     const timestamp = "1735066639761";
                     *     const payload = JSON.stringify({...});
                     *     const secret = "your-secret";
                     *     const stringToSign = `${timestamp}:${JSON.stringify(payload)}`;
                     *     const signature = crypto.createHmac("sha256", secret)
                     *       .update(stringToSign)
                     *       .digest("hex");
                     *     ``` */
                    "X-Twenty-Webhook-Signature"?: string;
                    /** @description Unix timestamp of when the webhook was sent. This timestamp is included in the HMAC signature generation to prevent replay attacks. */
                    "X-Twenty-Webhook-Timestamp"?: string;
                    /** @description Unique identifier for this webhook request to prevent replay attacks. Consumers should ensure this nonce is not reused. */
                    "X-Twenty-Webhook-Nonce"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @example https://example.com/incomingWebhook */
                        targetUrl?: string;
                        /** @example task.deleted */
                        eventName?: string;
                        objectMetadata?: {
                            /** @example 370985db-22d8-4463-8e5f-2271d30913bd */
                            id?: string;
                            /** @enum {string} */
                            nameSingular?: "task";
                        };
                        /** @example 872cfcf1-c79f-42bc-877d-5829f06eb3f9 */
                        workspaceId?: string;
                        /** @example 90056586-1228-4e03-a507-70140aa85c05 */
                        webhookId?: string;
                        /** @example 2024-02-14T11:27:01.779Z */
                        eventDate?: string;
                        record?: components["schemas"]["TaskForResponse"];
                    };
                };
            };
            responses: {
                /** @description Return a 200 status to indicate that the data was received successfully */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "TaskTarget Created": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description HMAC SHA256 signature of the request payload using the webhook secret. To compute the signature:
                     *     1. Concatenate `X-Twenty-Webhook-Timestamp`, a colon (:), and the JSON string of the request payload.
                     *     2. Compute the HMAC SHA256 hash using the shared secret as the key.
                     *     3. Send the resulting hex digest as this header value.
                     *     Example (Node.js):
                     *     ```javascript
                     *     const crypto = require("crypto");
                     *     const timestamp = "1735066639761";
                     *     const payload = JSON.stringify({...});
                     *     const secret = "your-secret";
                     *     const stringToSign = `${timestamp}:${JSON.stringify(payload)}`;
                     *     const signature = crypto.createHmac("sha256", secret)
                     *       .update(stringToSign)
                     *       .digest("hex");
                     *     ``` */
                    "X-Twenty-Webhook-Signature"?: string;
                    /** @description Unix timestamp of when the webhook was sent. This timestamp is included in the HMAC signature generation to prevent replay attacks. */
                    "X-Twenty-Webhook-Timestamp"?: string;
                    /** @description Unique identifier for this webhook request to prevent replay attacks. Consumers should ensure this nonce is not reused. */
                    "X-Twenty-Webhook-Nonce"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @example https://example.com/incomingWebhook */
                        targetUrl?: string;
                        /** @example taskTarget.created */
                        eventName?: string;
                        objectMetadata?: {
                            /** @example 370985db-22d8-4463-8e5f-2271d30913bd */
                            id?: string;
                            /** @enum {string} */
                            nameSingular?: "taskTarget";
                        };
                        /** @example 872cfcf1-c79f-42bc-877d-5829f06eb3f9 */
                        workspaceId?: string;
                        /** @example 90056586-1228-4e03-a507-70140aa85c05 */
                        webhookId?: string;
                        /** @example 2024-02-14T11:27:01.779Z */
                        eventDate?: string;
                        record?: components["schemas"]["TaskTargetForResponse"];
                    };
                };
            };
            responses: {
                /** @description Return a 200 status to indicate that the data was received successfully */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "TaskTarget Updated": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description HMAC SHA256 signature of the request payload using the webhook secret. To compute the signature:
                     *     1. Concatenate `X-Twenty-Webhook-Timestamp`, a colon (:), and the JSON string of the request payload.
                     *     2. Compute the HMAC SHA256 hash using the shared secret as the key.
                     *     3. Send the resulting hex digest as this header value.
                     *     Example (Node.js):
                     *     ```javascript
                     *     const crypto = require("crypto");
                     *     const timestamp = "1735066639761";
                     *     const payload = JSON.stringify({...});
                     *     const secret = "your-secret";
                     *     const stringToSign = `${timestamp}:${JSON.stringify(payload)}`;
                     *     const signature = crypto.createHmac("sha256", secret)
                     *       .update(stringToSign)
                     *       .digest("hex");
                     *     ``` */
                    "X-Twenty-Webhook-Signature"?: string;
                    /** @description Unix timestamp of when the webhook was sent. This timestamp is included in the HMAC signature generation to prevent replay attacks. */
                    "X-Twenty-Webhook-Timestamp"?: string;
                    /** @description Unique identifier for this webhook request to prevent replay attacks. Consumers should ensure this nonce is not reused. */
                    "X-Twenty-Webhook-Nonce"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @example https://example.com/incomingWebhook */
                        targetUrl?: string;
                        /** @example taskTarget.updated */
                        eventName?: string;
                        objectMetadata?: {
                            /** @example 370985db-22d8-4463-8e5f-2271d30913bd */
                            id?: string;
                            /** @enum {string} */
                            nameSingular?: "taskTarget";
                        };
                        /** @example 872cfcf1-c79f-42bc-877d-5829f06eb3f9 */
                        workspaceId?: string;
                        /** @example 90056586-1228-4e03-a507-70140aa85c05 */
                        webhookId?: string;
                        /** @example 2024-02-14T11:27:01.779Z */
                        eventDate?: string;
                        record?: components["schemas"]["TaskTargetForResponse"];
                        updatedFields?: string[];
                    };
                };
            };
            responses: {
                /** @description Return a 200 status to indicate that the data was received successfully */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "TaskTarget Deleted": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description HMAC SHA256 signature of the request payload using the webhook secret. To compute the signature:
                     *     1. Concatenate `X-Twenty-Webhook-Timestamp`, a colon (:), and the JSON string of the request payload.
                     *     2. Compute the HMAC SHA256 hash using the shared secret as the key.
                     *     3. Send the resulting hex digest as this header value.
                     *     Example (Node.js):
                     *     ```javascript
                     *     const crypto = require("crypto");
                     *     const timestamp = "1735066639761";
                     *     const payload = JSON.stringify({...});
                     *     const secret = "your-secret";
                     *     const stringToSign = `${timestamp}:${JSON.stringify(payload)}`;
                     *     const signature = crypto.createHmac("sha256", secret)
                     *       .update(stringToSign)
                     *       .digest("hex");
                     *     ``` */
                    "X-Twenty-Webhook-Signature"?: string;
                    /** @description Unix timestamp of when the webhook was sent. This timestamp is included in the HMAC signature generation to prevent replay attacks. */
                    "X-Twenty-Webhook-Timestamp"?: string;
                    /** @description Unique identifier for this webhook request to prevent replay attacks. Consumers should ensure this nonce is not reused. */
                    "X-Twenty-Webhook-Nonce"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @example https://example.com/incomingWebhook */
                        targetUrl?: string;
                        /** @example taskTarget.deleted */
                        eventName?: string;
                        objectMetadata?: {
                            /** @example 370985db-22d8-4463-8e5f-2271d30913bd */
                            id?: string;
                            /** @enum {string} */
                            nameSingular?: "taskTarget";
                        };
                        /** @example 872cfcf1-c79f-42bc-877d-5829f06eb3f9 */
                        workspaceId?: string;
                        /** @example 90056586-1228-4e03-a507-70140aa85c05 */
                        webhookId?: string;
                        /** @example 2024-02-14T11:27:01.779Z */
                        eventDate?: string;
                        record?: components["schemas"]["TaskTargetForResponse"];
                    };
                };
            };
            responses: {
                /** @description Return a 200 status to indicate that the data was received successfully */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "TimelineActivity Created": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description HMAC SHA256 signature of the request payload using the webhook secret. To compute the signature:
                     *     1. Concatenate `X-Twenty-Webhook-Timestamp`, a colon (:), and the JSON string of the request payload.
                     *     2. Compute the HMAC SHA256 hash using the shared secret as the key.
                     *     3. Send the resulting hex digest as this header value.
                     *     Example (Node.js):
                     *     ```javascript
                     *     const crypto = require("crypto");
                     *     const timestamp = "1735066639761";
                     *     const payload = JSON.stringify({...});
                     *     const secret = "your-secret";
                     *     const stringToSign = `${timestamp}:${JSON.stringify(payload)}`;
                     *     const signature = crypto.createHmac("sha256", secret)
                     *       .update(stringToSign)
                     *       .digest("hex");
                     *     ``` */
                    "X-Twenty-Webhook-Signature"?: string;
                    /** @description Unix timestamp of when the webhook was sent. This timestamp is included in the HMAC signature generation to prevent replay attacks. */
                    "X-Twenty-Webhook-Timestamp"?: string;
                    /** @description Unique identifier for this webhook request to prevent replay attacks. Consumers should ensure this nonce is not reused. */
                    "X-Twenty-Webhook-Nonce"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @example https://example.com/incomingWebhook */
                        targetUrl?: string;
                        /** @example timelineActivity.created */
                        eventName?: string;
                        objectMetadata?: {
                            /** @example 370985db-22d8-4463-8e5f-2271d30913bd */
                            id?: string;
                            /** @enum {string} */
                            nameSingular?: "timelineActivity";
                        };
                        /** @example 872cfcf1-c79f-42bc-877d-5829f06eb3f9 */
                        workspaceId?: string;
                        /** @example 90056586-1228-4e03-a507-70140aa85c05 */
                        webhookId?: string;
                        /** @example 2024-02-14T11:27:01.779Z */
                        eventDate?: string;
                        record?: components["schemas"]["TimelineActivityForResponse"];
                    };
                };
            };
            responses: {
                /** @description Return a 200 status to indicate that the data was received successfully */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "TimelineActivity Updated": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description HMAC SHA256 signature of the request payload using the webhook secret. To compute the signature:
                     *     1. Concatenate `X-Twenty-Webhook-Timestamp`, a colon (:), and the JSON string of the request payload.
                     *     2. Compute the HMAC SHA256 hash using the shared secret as the key.
                     *     3. Send the resulting hex digest as this header value.
                     *     Example (Node.js):
                     *     ```javascript
                     *     const crypto = require("crypto");
                     *     const timestamp = "1735066639761";
                     *     const payload = JSON.stringify({...});
                     *     const secret = "your-secret";
                     *     const stringToSign = `${timestamp}:${JSON.stringify(payload)}`;
                     *     const signature = crypto.createHmac("sha256", secret)
                     *       .update(stringToSign)
                     *       .digest("hex");
                     *     ``` */
                    "X-Twenty-Webhook-Signature"?: string;
                    /** @description Unix timestamp of when the webhook was sent. This timestamp is included in the HMAC signature generation to prevent replay attacks. */
                    "X-Twenty-Webhook-Timestamp"?: string;
                    /** @description Unique identifier for this webhook request to prevent replay attacks. Consumers should ensure this nonce is not reused. */
                    "X-Twenty-Webhook-Nonce"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @example https://example.com/incomingWebhook */
                        targetUrl?: string;
                        /** @example timelineActivity.updated */
                        eventName?: string;
                        objectMetadata?: {
                            /** @example 370985db-22d8-4463-8e5f-2271d30913bd */
                            id?: string;
                            /** @enum {string} */
                            nameSingular?: "timelineActivity";
                        };
                        /** @example 872cfcf1-c79f-42bc-877d-5829f06eb3f9 */
                        workspaceId?: string;
                        /** @example 90056586-1228-4e03-a507-70140aa85c05 */
                        webhookId?: string;
                        /** @example 2024-02-14T11:27:01.779Z */
                        eventDate?: string;
                        record?: components["schemas"]["TimelineActivityForResponse"];
                        updatedFields?: string[];
                    };
                };
            };
            responses: {
                /** @description Return a 200 status to indicate that the data was received successfully */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "TimelineActivity Deleted": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description HMAC SHA256 signature of the request payload using the webhook secret. To compute the signature:
                     *     1. Concatenate `X-Twenty-Webhook-Timestamp`, a colon (:), and the JSON string of the request payload.
                     *     2. Compute the HMAC SHA256 hash using the shared secret as the key.
                     *     3. Send the resulting hex digest as this header value.
                     *     Example (Node.js):
                     *     ```javascript
                     *     const crypto = require("crypto");
                     *     const timestamp = "1735066639761";
                     *     const payload = JSON.stringify({...});
                     *     const secret = "your-secret";
                     *     const stringToSign = `${timestamp}:${JSON.stringify(payload)}`;
                     *     const signature = crypto.createHmac("sha256", secret)
                     *       .update(stringToSign)
                     *       .digest("hex");
                     *     ``` */
                    "X-Twenty-Webhook-Signature"?: string;
                    /** @description Unix timestamp of when the webhook was sent. This timestamp is included in the HMAC signature generation to prevent replay attacks. */
                    "X-Twenty-Webhook-Timestamp"?: string;
                    /** @description Unique identifier for this webhook request to prevent replay attacks. Consumers should ensure this nonce is not reused. */
                    "X-Twenty-Webhook-Nonce"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @example https://example.com/incomingWebhook */
                        targetUrl?: string;
                        /** @example timelineActivity.deleted */
                        eventName?: string;
                        objectMetadata?: {
                            /** @example 370985db-22d8-4463-8e5f-2271d30913bd */
                            id?: string;
                            /** @enum {string} */
                            nameSingular?: "timelineActivity";
                        };
                        /** @example 872cfcf1-c79f-42bc-877d-5829f06eb3f9 */
                        workspaceId?: string;
                        /** @example 90056586-1228-4e03-a507-70140aa85c05 */
                        webhookId?: string;
                        /** @example 2024-02-14T11:27:01.779Z */
                        eventDate?: string;
                        record?: components["schemas"]["TimelineActivityForResponse"];
                    };
                };
            };
            responses: {
                /** @description Return a 200 status to indicate that the data was received successfully */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "ViewField Created": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description HMAC SHA256 signature of the request payload using the webhook secret. To compute the signature:
                     *     1. Concatenate `X-Twenty-Webhook-Timestamp`, a colon (:), and the JSON string of the request payload.
                     *     2. Compute the HMAC SHA256 hash using the shared secret as the key.
                     *     3. Send the resulting hex digest as this header value.
                     *     Example (Node.js):
                     *     ```javascript
                     *     const crypto = require("crypto");
                     *     const timestamp = "1735066639761";
                     *     const payload = JSON.stringify({...});
                     *     const secret = "your-secret";
                     *     const stringToSign = `${timestamp}:${JSON.stringify(payload)}`;
                     *     const signature = crypto.createHmac("sha256", secret)
                     *       .update(stringToSign)
                     *       .digest("hex");
                     *     ``` */
                    "X-Twenty-Webhook-Signature"?: string;
                    /** @description Unix timestamp of when the webhook was sent. This timestamp is included in the HMAC signature generation to prevent replay attacks. */
                    "X-Twenty-Webhook-Timestamp"?: string;
                    /** @description Unique identifier for this webhook request to prevent replay attacks. Consumers should ensure this nonce is not reused. */
                    "X-Twenty-Webhook-Nonce"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @example https://example.com/incomingWebhook */
                        targetUrl?: string;
                        /** @example viewField.created */
                        eventName?: string;
                        objectMetadata?: {
                            /** @example 370985db-22d8-4463-8e5f-2271d30913bd */
                            id?: string;
                            /** @enum {string} */
                            nameSingular?: "viewField";
                        };
                        /** @example 872cfcf1-c79f-42bc-877d-5829f06eb3f9 */
                        workspaceId?: string;
                        /** @example 90056586-1228-4e03-a507-70140aa85c05 */
                        webhookId?: string;
                        /** @example 2024-02-14T11:27:01.779Z */
                        eventDate?: string;
                        record?: components["schemas"]["ViewFieldForResponse"];
                    };
                };
            };
            responses: {
                /** @description Return a 200 status to indicate that the data was received successfully */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "ViewField Updated": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description HMAC SHA256 signature of the request payload using the webhook secret. To compute the signature:
                     *     1. Concatenate `X-Twenty-Webhook-Timestamp`, a colon (:), and the JSON string of the request payload.
                     *     2. Compute the HMAC SHA256 hash using the shared secret as the key.
                     *     3. Send the resulting hex digest as this header value.
                     *     Example (Node.js):
                     *     ```javascript
                     *     const crypto = require("crypto");
                     *     const timestamp = "1735066639761";
                     *     const payload = JSON.stringify({...});
                     *     const secret = "your-secret";
                     *     const stringToSign = `${timestamp}:${JSON.stringify(payload)}`;
                     *     const signature = crypto.createHmac("sha256", secret)
                     *       .update(stringToSign)
                     *       .digest("hex");
                     *     ``` */
                    "X-Twenty-Webhook-Signature"?: string;
                    /** @description Unix timestamp of when the webhook was sent. This timestamp is included in the HMAC signature generation to prevent replay attacks. */
                    "X-Twenty-Webhook-Timestamp"?: string;
                    /** @description Unique identifier for this webhook request to prevent replay attacks. Consumers should ensure this nonce is not reused. */
                    "X-Twenty-Webhook-Nonce"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @example https://example.com/incomingWebhook */
                        targetUrl?: string;
                        /** @example viewField.updated */
                        eventName?: string;
                        objectMetadata?: {
                            /** @example 370985db-22d8-4463-8e5f-2271d30913bd */
                            id?: string;
                            /** @enum {string} */
                            nameSingular?: "viewField";
                        };
                        /** @example 872cfcf1-c79f-42bc-877d-5829f06eb3f9 */
                        workspaceId?: string;
                        /** @example 90056586-1228-4e03-a507-70140aa85c05 */
                        webhookId?: string;
                        /** @example 2024-02-14T11:27:01.779Z */
                        eventDate?: string;
                        record?: components["schemas"]["ViewFieldForResponse"];
                        updatedFields?: string[];
                    };
                };
            };
            responses: {
                /** @description Return a 200 status to indicate that the data was received successfully */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "ViewField Deleted": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description HMAC SHA256 signature of the request payload using the webhook secret. To compute the signature:
                     *     1. Concatenate `X-Twenty-Webhook-Timestamp`, a colon (:), and the JSON string of the request payload.
                     *     2. Compute the HMAC SHA256 hash using the shared secret as the key.
                     *     3. Send the resulting hex digest as this header value.
                     *     Example (Node.js):
                     *     ```javascript
                     *     const crypto = require("crypto");
                     *     const timestamp = "1735066639761";
                     *     const payload = JSON.stringify({...});
                     *     const secret = "your-secret";
                     *     const stringToSign = `${timestamp}:${JSON.stringify(payload)}`;
                     *     const signature = crypto.createHmac("sha256", secret)
                     *       .update(stringToSign)
                     *       .digest("hex");
                     *     ``` */
                    "X-Twenty-Webhook-Signature"?: string;
                    /** @description Unix timestamp of when the webhook was sent. This timestamp is included in the HMAC signature generation to prevent replay attacks. */
                    "X-Twenty-Webhook-Timestamp"?: string;
                    /** @description Unique identifier for this webhook request to prevent replay attacks. Consumers should ensure this nonce is not reused. */
                    "X-Twenty-Webhook-Nonce"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @example https://example.com/incomingWebhook */
                        targetUrl?: string;
                        /** @example viewField.deleted */
                        eventName?: string;
                        objectMetadata?: {
                            /** @example 370985db-22d8-4463-8e5f-2271d30913bd */
                            id?: string;
                            /** @enum {string} */
                            nameSingular?: "viewField";
                        };
                        /** @example 872cfcf1-c79f-42bc-877d-5829f06eb3f9 */
                        workspaceId?: string;
                        /** @example 90056586-1228-4e03-a507-70140aa85c05 */
                        webhookId?: string;
                        /** @example 2024-02-14T11:27:01.779Z */
                        eventDate?: string;
                        record?: components["schemas"]["ViewFieldForResponse"];
                    };
                };
            };
            responses: {
                /** @description Return a 200 status to indicate that the data was received successfully */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "ViewFilterGroup Created": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description HMAC SHA256 signature of the request payload using the webhook secret. To compute the signature:
                     *     1. Concatenate `X-Twenty-Webhook-Timestamp`, a colon (:), and the JSON string of the request payload.
                     *     2. Compute the HMAC SHA256 hash using the shared secret as the key.
                     *     3. Send the resulting hex digest as this header value.
                     *     Example (Node.js):
                     *     ```javascript
                     *     const crypto = require("crypto");
                     *     const timestamp = "1735066639761";
                     *     const payload = JSON.stringify({...});
                     *     const secret = "your-secret";
                     *     const stringToSign = `${timestamp}:${JSON.stringify(payload)}`;
                     *     const signature = crypto.createHmac("sha256", secret)
                     *       .update(stringToSign)
                     *       .digest("hex");
                     *     ``` */
                    "X-Twenty-Webhook-Signature"?: string;
                    /** @description Unix timestamp of when the webhook was sent. This timestamp is included in the HMAC signature generation to prevent replay attacks. */
                    "X-Twenty-Webhook-Timestamp"?: string;
                    /** @description Unique identifier for this webhook request to prevent replay attacks. Consumers should ensure this nonce is not reused. */
                    "X-Twenty-Webhook-Nonce"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @example https://example.com/incomingWebhook */
                        targetUrl?: string;
                        /** @example viewFilterGroup.created */
                        eventName?: string;
                        objectMetadata?: {
                            /** @example 370985db-22d8-4463-8e5f-2271d30913bd */
                            id?: string;
                            /** @enum {string} */
                            nameSingular?: "viewFilterGroup";
                        };
                        /** @example 872cfcf1-c79f-42bc-877d-5829f06eb3f9 */
                        workspaceId?: string;
                        /** @example 90056586-1228-4e03-a507-70140aa85c05 */
                        webhookId?: string;
                        /** @example 2024-02-14T11:27:01.779Z */
                        eventDate?: string;
                        record?: components["schemas"]["ViewFilterGroupForResponse"];
                    };
                };
            };
            responses: {
                /** @description Return a 200 status to indicate that the data was received successfully */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "ViewFilterGroup Updated": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description HMAC SHA256 signature of the request payload using the webhook secret. To compute the signature:
                     *     1. Concatenate `X-Twenty-Webhook-Timestamp`, a colon (:), and the JSON string of the request payload.
                     *     2. Compute the HMAC SHA256 hash using the shared secret as the key.
                     *     3. Send the resulting hex digest as this header value.
                     *     Example (Node.js):
                     *     ```javascript
                     *     const crypto = require("crypto");
                     *     const timestamp = "1735066639761";
                     *     const payload = JSON.stringify({...});
                     *     const secret = "your-secret";
                     *     const stringToSign = `${timestamp}:${JSON.stringify(payload)}`;
                     *     const signature = crypto.createHmac("sha256", secret)
                     *       .update(stringToSign)
                     *       .digest("hex");
                     *     ``` */
                    "X-Twenty-Webhook-Signature"?: string;
                    /** @description Unix timestamp of when the webhook was sent. This timestamp is included in the HMAC signature generation to prevent replay attacks. */
                    "X-Twenty-Webhook-Timestamp"?: string;
                    /** @description Unique identifier for this webhook request to prevent replay attacks. Consumers should ensure this nonce is not reused. */
                    "X-Twenty-Webhook-Nonce"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @example https://example.com/incomingWebhook */
                        targetUrl?: string;
                        /** @example viewFilterGroup.updated */
                        eventName?: string;
                        objectMetadata?: {
                            /** @example 370985db-22d8-4463-8e5f-2271d30913bd */
                            id?: string;
                            /** @enum {string} */
                            nameSingular?: "viewFilterGroup";
                        };
                        /** @example 872cfcf1-c79f-42bc-877d-5829f06eb3f9 */
                        workspaceId?: string;
                        /** @example 90056586-1228-4e03-a507-70140aa85c05 */
                        webhookId?: string;
                        /** @example 2024-02-14T11:27:01.779Z */
                        eventDate?: string;
                        record?: components["schemas"]["ViewFilterGroupForResponse"];
                        updatedFields?: string[];
                    };
                };
            };
            responses: {
                /** @description Return a 200 status to indicate that the data was received successfully */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "ViewFilterGroup Deleted": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description HMAC SHA256 signature of the request payload using the webhook secret. To compute the signature:
                     *     1. Concatenate `X-Twenty-Webhook-Timestamp`, a colon (:), and the JSON string of the request payload.
                     *     2. Compute the HMAC SHA256 hash using the shared secret as the key.
                     *     3. Send the resulting hex digest as this header value.
                     *     Example (Node.js):
                     *     ```javascript
                     *     const crypto = require("crypto");
                     *     const timestamp = "1735066639761";
                     *     const payload = JSON.stringify({...});
                     *     const secret = "your-secret";
                     *     const stringToSign = `${timestamp}:${JSON.stringify(payload)}`;
                     *     const signature = crypto.createHmac("sha256", secret)
                     *       .update(stringToSign)
                     *       .digest("hex");
                     *     ``` */
                    "X-Twenty-Webhook-Signature"?: string;
                    /** @description Unix timestamp of when the webhook was sent. This timestamp is included in the HMAC signature generation to prevent replay attacks. */
                    "X-Twenty-Webhook-Timestamp"?: string;
                    /** @description Unique identifier for this webhook request to prevent replay attacks. Consumers should ensure this nonce is not reused. */
                    "X-Twenty-Webhook-Nonce"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @example https://example.com/incomingWebhook */
                        targetUrl?: string;
                        /** @example viewFilterGroup.deleted */
                        eventName?: string;
                        objectMetadata?: {
                            /** @example 370985db-22d8-4463-8e5f-2271d30913bd */
                            id?: string;
                            /** @enum {string} */
                            nameSingular?: "viewFilterGroup";
                        };
                        /** @example 872cfcf1-c79f-42bc-877d-5829f06eb3f9 */
                        workspaceId?: string;
                        /** @example 90056586-1228-4e03-a507-70140aa85c05 */
                        webhookId?: string;
                        /** @example 2024-02-14T11:27:01.779Z */
                        eventDate?: string;
                        record?: components["schemas"]["ViewFilterGroupForResponse"];
                    };
                };
            };
            responses: {
                /** @description Return a 200 status to indicate that the data was received successfully */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "ViewFilter Created": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description HMAC SHA256 signature of the request payload using the webhook secret. To compute the signature:
                     *     1. Concatenate `X-Twenty-Webhook-Timestamp`, a colon (:), and the JSON string of the request payload.
                     *     2. Compute the HMAC SHA256 hash using the shared secret as the key.
                     *     3. Send the resulting hex digest as this header value.
                     *     Example (Node.js):
                     *     ```javascript
                     *     const crypto = require("crypto");
                     *     const timestamp = "1735066639761";
                     *     const payload = JSON.stringify({...});
                     *     const secret = "your-secret";
                     *     const stringToSign = `${timestamp}:${JSON.stringify(payload)}`;
                     *     const signature = crypto.createHmac("sha256", secret)
                     *       .update(stringToSign)
                     *       .digest("hex");
                     *     ``` */
                    "X-Twenty-Webhook-Signature"?: string;
                    /** @description Unix timestamp of when the webhook was sent. This timestamp is included in the HMAC signature generation to prevent replay attacks. */
                    "X-Twenty-Webhook-Timestamp"?: string;
                    /** @description Unique identifier for this webhook request to prevent replay attacks. Consumers should ensure this nonce is not reused. */
                    "X-Twenty-Webhook-Nonce"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @example https://example.com/incomingWebhook */
                        targetUrl?: string;
                        /** @example viewFilter.created */
                        eventName?: string;
                        objectMetadata?: {
                            /** @example 370985db-22d8-4463-8e5f-2271d30913bd */
                            id?: string;
                            /** @enum {string} */
                            nameSingular?: "viewFilter";
                        };
                        /** @example 872cfcf1-c79f-42bc-877d-5829f06eb3f9 */
                        workspaceId?: string;
                        /** @example 90056586-1228-4e03-a507-70140aa85c05 */
                        webhookId?: string;
                        /** @example 2024-02-14T11:27:01.779Z */
                        eventDate?: string;
                        record?: components["schemas"]["ViewFilterForResponse"];
                    };
                };
            };
            responses: {
                /** @description Return a 200 status to indicate that the data was received successfully */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "ViewFilter Updated": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description HMAC SHA256 signature of the request payload using the webhook secret. To compute the signature:
                     *     1. Concatenate `X-Twenty-Webhook-Timestamp`, a colon (:), and the JSON string of the request payload.
                     *     2. Compute the HMAC SHA256 hash using the shared secret as the key.
                     *     3. Send the resulting hex digest as this header value.
                     *     Example (Node.js):
                     *     ```javascript
                     *     const crypto = require("crypto");
                     *     const timestamp = "1735066639761";
                     *     const payload = JSON.stringify({...});
                     *     const secret = "your-secret";
                     *     const stringToSign = `${timestamp}:${JSON.stringify(payload)}`;
                     *     const signature = crypto.createHmac("sha256", secret)
                     *       .update(stringToSign)
                     *       .digest("hex");
                     *     ``` */
                    "X-Twenty-Webhook-Signature"?: string;
                    /** @description Unix timestamp of when the webhook was sent. This timestamp is included in the HMAC signature generation to prevent replay attacks. */
                    "X-Twenty-Webhook-Timestamp"?: string;
                    /** @description Unique identifier for this webhook request to prevent replay attacks. Consumers should ensure this nonce is not reused. */
                    "X-Twenty-Webhook-Nonce"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @example https://example.com/incomingWebhook */
                        targetUrl?: string;
                        /** @example viewFilter.updated */
                        eventName?: string;
                        objectMetadata?: {
                            /** @example 370985db-22d8-4463-8e5f-2271d30913bd */
                            id?: string;
                            /** @enum {string} */
                            nameSingular?: "viewFilter";
                        };
                        /** @example 872cfcf1-c79f-42bc-877d-5829f06eb3f9 */
                        workspaceId?: string;
                        /** @example 90056586-1228-4e03-a507-70140aa85c05 */
                        webhookId?: string;
                        /** @example 2024-02-14T11:27:01.779Z */
                        eventDate?: string;
                        record?: components["schemas"]["ViewFilterForResponse"];
                        updatedFields?: string[];
                    };
                };
            };
            responses: {
                /** @description Return a 200 status to indicate that the data was received successfully */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "ViewFilter Deleted": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description HMAC SHA256 signature of the request payload using the webhook secret. To compute the signature:
                     *     1. Concatenate `X-Twenty-Webhook-Timestamp`, a colon (:), and the JSON string of the request payload.
                     *     2. Compute the HMAC SHA256 hash using the shared secret as the key.
                     *     3. Send the resulting hex digest as this header value.
                     *     Example (Node.js):
                     *     ```javascript
                     *     const crypto = require("crypto");
                     *     const timestamp = "1735066639761";
                     *     const payload = JSON.stringify({...});
                     *     const secret = "your-secret";
                     *     const stringToSign = `${timestamp}:${JSON.stringify(payload)}`;
                     *     const signature = crypto.createHmac("sha256", secret)
                     *       .update(stringToSign)
                     *       .digest("hex");
                     *     ``` */
                    "X-Twenty-Webhook-Signature"?: string;
                    /** @description Unix timestamp of when the webhook was sent. This timestamp is included in the HMAC signature generation to prevent replay attacks. */
                    "X-Twenty-Webhook-Timestamp"?: string;
                    /** @description Unique identifier for this webhook request to prevent replay attacks. Consumers should ensure this nonce is not reused. */
                    "X-Twenty-Webhook-Nonce"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @example https://example.com/incomingWebhook */
                        targetUrl?: string;
                        /** @example viewFilter.deleted */
                        eventName?: string;
                        objectMetadata?: {
                            /** @example 370985db-22d8-4463-8e5f-2271d30913bd */
                            id?: string;
                            /** @enum {string} */
                            nameSingular?: "viewFilter";
                        };
                        /** @example 872cfcf1-c79f-42bc-877d-5829f06eb3f9 */
                        workspaceId?: string;
                        /** @example 90056586-1228-4e03-a507-70140aa85c05 */
                        webhookId?: string;
                        /** @example 2024-02-14T11:27:01.779Z */
                        eventDate?: string;
                        record?: components["schemas"]["ViewFilterForResponse"];
                    };
                };
            };
            responses: {
                /** @description Return a 200 status to indicate that the data was received successfully */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "ViewGroup Created": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description HMAC SHA256 signature of the request payload using the webhook secret. To compute the signature:
                     *     1. Concatenate `X-Twenty-Webhook-Timestamp`, a colon (:), and the JSON string of the request payload.
                     *     2. Compute the HMAC SHA256 hash using the shared secret as the key.
                     *     3. Send the resulting hex digest as this header value.
                     *     Example (Node.js):
                     *     ```javascript
                     *     const crypto = require("crypto");
                     *     const timestamp = "1735066639761";
                     *     const payload = JSON.stringify({...});
                     *     const secret = "your-secret";
                     *     const stringToSign = `${timestamp}:${JSON.stringify(payload)}`;
                     *     const signature = crypto.createHmac("sha256", secret)
                     *       .update(stringToSign)
                     *       .digest("hex");
                     *     ``` */
                    "X-Twenty-Webhook-Signature"?: string;
                    /** @description Unix timestamp of when the webhook was sent. This timestamp is included in the HMAC signature generation to prevent replay attacks. */
                    "X-Twenty-Webhook-Timestamp"?: string;
                    /** @description Unique identifier for this webhook request to prevent replay attacks. Consumers should ensure this nonce is not reused. */
                    "X-Twenty-Webhook-Nonce"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @example https://example.com/incomingWebhook */
                        targetUrl?: string;
                        /** @example viewGroup.created */
                        eventName?: string;
                        objectMetadata?: {
                            /** @example 370985db-22d8-4463-8e5f-2271d30913bd */
                            id?: string;
                            /** @enum {string} */
                            nameSingular?: "viewGroup";
                        };
                        /** @example 872cfcf1-c79f-42bc-877d-5829f06eb3f9 */
                        workspaceId?: string;
                        /** @example 90056586-1228-4e03-a507-70140aa85c05 */
                        webhookId?: string;
                        /** @example 2024-02-14T11:27:01.779Z */
                        eventDate?: string;
                        record?: components["schemas"]["ViewGroupForResponse"];
                    };
                };
            };
            responses: {
                /** @description Return a 200 status to indicate that the data was received successfully */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "ViewGroup Updated": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description HMAC SHA256 signature of the request payload using the webhook secret. To compute the signature:
                     *     1. Concatenate `X-Twenty-Webhook-Timestamp`, a colon (:), and the JSON string of the request payload.
                     *     2. Compute the HMAC SHA256 hash using the shared secret as the key.
                     *     3. Send the resulting hex digest as this header value.
                     *     Example (Node.js):
                     *     ```javascript
                     *     const crypto = require("crypto");
                     *     const timestamp = "1735066639761";
                     *     const payload = JSON.stringify({...});
                     *     const secret = "your-secret";
                     *     const stringToSign = `${timestamp}:${JSON.stringify(payload)}`;
                     *     const signature = crypto.createHmac("sha256", secret)
                     *       .update(stringToSign)
                     *       .digest("hex");
                     *     ``` */
                    "X-Twenty-Webhook-Signature"?: string;
                    /** @description Unix timestamp of when the webhook was sent. This timestamp is included in the HMAC signature generation to prevent replay attacks. */
                    "X-Twenty-Webhook-Timestamp"?: string;
                    /** @description Unique identifier for this webhook request to prevent replay attacks. Consumers should ensure this nonce is not reused. */
                    "X-Twenty-Webhook-Nonce"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @example https://example.com/incomingWebhook */
                        targetUrl?: string;
                        /** @example viewGroup.updated */
                        eventName?: string;
                        objectMetadata?: {
                            /** @example 370985db-22d8-4463-8e5f-2271d30913bd */
                            id?: string;
                            /** @enum {string} */
                            nameSingular?: "viewGroup";
                        };
                        /** @example 872cfcf1-c79f-42bc-877d-5829f06eb3f9 */
                        workspaceId?: string;
                        /** @example 90056586-1228-4e03-a507-70140aa85c05 */
                        webhookId?: string;
                        /** @example 2024-02-14T11:27:01.779Z */
                        eventDate?: string;
                        record?: components["schemas"]["ViewGroupForResponse"];
                        updatedFields?: string[];
                    };
                };
            };
            responses: {
                /** @description Return a 200 status to indicate that the data was received successfully */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "ViewGroup Deleted": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description HMAC SHA256 signature of the request payload using the webhook secret. To compute the signature:
                     *     1. Concatenate `X-Twenty-Webhook-Timestamp`, a colon (:), and the JSON string of the request payload.
                     *     2. Compute the HMAC SHA256 hash using the shared secret as the key.
                     *     3. Send the resulting hex digest as this header value.
                     *     Example (Node.js):
                     *     ```javascript
                     *     const crypto = require("crypto");
                     *     const timestamp = "1735066639761";
                     *     const payload = JSON.stringify({...});
                     *     const secret = "your-secret";
                     *     const stringToSign = `${timestamp}:${JSON.stringify(payload)}`;
                     *     const signature = crypto.createHmac("sha256", secret)
                     *       .update(stringToSign)
                     *       .digest("hex");
                     *     ``` */
                    "X-Twenty-Webhook-Signature"?: string;
                    /** @description Unix timestamp of when the webhook was sent. This timestamp is included in the HMAC signature generation to prevent replay attacks. */
                    "X-Twenty-Webhook-Timestamp"?: string;
                    /** @description Unique identifier for this webhook request to prevent replay attacks. Consumers should ensure this nonce is not reused. */
                    "X-Twenty-Webhook-Nonce"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @example https://example.com/incomingWebhook */
                        targetUrl?: string;
                        /** @example viewGroup.deleted */
                        eventName?: string;
                        objectMetadata?: {
                            /** @example 370985db-22d8-4463-8e5f-2271d30913bd */
                            id?: string;
                            /** @enum {string} */
                            nameSingular?: "viewGroup";
                        };
                        /** @example 872cfcf1-c79f-42bc-877d-5829f06eb3f9 */
                        workspaceId?: string;
                        /** @example 90056586-1228-4e03-a507-70140aa85c05 */
                        webhookId?: string;
                        /** @example 2024-02-14T11:27:01.779Z */
                        eventDate?: string;
                        record?: components["schemas"]["ViewGroupForResponse"];
                    };
                };
            };
            responses: {
                /** @description Return a 200 status to indicate that the data was received successfully */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "View Created": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description HMAC SHA256 signature of the request payload using the webhook secret. To compute the signature:
                     *     1. Concatenate `X-Twenty-Webhook-Timestamp`, a colon (:), and the JSON string of the request payload.
                     *     2. Compute the HMAC SHA256 hash using the shared secret as the key.
                     *     3. Send the resulting hex digest as this header value.
                     *     Example (Node.js):
                     *     ```javascript
                     *     const crypto = require("crypto");
                     *     const timestamp = "1735066639761";
                     *     const payload = JSON.stringify({...});
                     *     const secret = "your-secret";
                     *     const stringToSign = `${timestamp}:${JSON.stringify(payload)}`;
                     *     const signature = crypto.createHmac("sha256", secret)
                     *       .update(stringToSign)
                     *       .digest("hex");
                     *     ``` */
                    "X-Twenty-Webhook-Signature"?: string;
                    /** @description Unix timestamp of when the webhook was sent. This timestamp is included in the HMAC signature generation to prevent replay attacks. */
                    "X-Twenty-Webhook-Timestamp"?: string;
                    /** @description Unique identifier for this webhook request to prevent replay attacks. Consumers should ensure this nonce is not reused. */
                    "X-Twenty-Webhook-Nonce"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @example https://example.com/incomingWebhook */
                        targetUrl?: string;
                        /** @example view.created */
                        eventName?: string;
                        objectMetadata?: {
                            /** @example 370985db-22d8-4463-8e5f-2271d30913bd */
                            id?: string;
                            /** @enum {string} */
                            nameSingular?: "view";
                        };
                        /** @example 872cfcf1-c79f-42bc-877d-5829f06eb3f9 */
                        workspaceId?: string;
                        /** @example 90056586-1228-4e03-a507-70140aa85c05 */
                        webhookId?: string;
                        /** @example 2024-02-14T11:27:01.779Z */
                        eventDate?: string;
                        record?: components["schemas"]["ViewForResponse"];
                    };
                };
            };
            responses: {
                /** @description Return a 200 status to indicate that the data was received successfully */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "View Updated": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description HMAC SHA256 signature of the request payload using the webhook secret. To compute the signature:
                     *     1. Concatenate `X-Twenty-Webhook-Timestamp`, a colon (:), and the JSON string of the request payload.
                     *     2. Compute the HMAC SHA256 hash using the shared secret as the key.
                     *     3. Send the resulting hex digest as this header value.
                     *     Example (Node.js):
                     *     ```javascript
                     *     const crypto = require("crypto");
                     *     const timestamp = "1735066639761";
                     *     const payload = JSON.stringify({...});
                     *     const secret = "your-secret";
                     *     const stringToSign = `${timestamp}:${JSON.stringify(payload)}`;
                     *     const signature = crypto.createHmac("sha256", secret)
                     *       .update(stringToSign)
                     *       .digest("hex");
                     *     ``` */
                    "X-Twenty-Webhook-Signature"?: string;
                    /** @description Unix timestamp of when the webhook was sent. This timestamp is included in the HMAC signature generation to prevent replay attacks. */
                    "X-Twenty-Webhook-Timestamp"?: string;
                    /** @description Unique identifier for this webhook request to prevent replay attacks. Consumers should ensure this nonce is not reused. */
                    "X-Twenty-Webhook-Nonce"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @example https://example.com/incomingWebhook */
                        targetUrl?: string;
                        /** @example view.updated */
                        eventName?: string;
                        objectMetadata?: {
                            /** @example 370985db-22d8-4463-8e5f-2271d30913bd */
                            id?: string;
                            /** @enum {string} */
                            nameSingular?: "view";
                        };
                        /** @example 872cfcf1-c79f-42bc-877d-5829f06eb3f9 */
                        workspaceId?: string;
                        /** @example 90056586-1228-4e03-a507-70140aa85c05 */
                        webhookId?: string;
                        /** @example 2024-02-14T11:27:01.779Z */
                        eventDate?: string;
                        record?: components["schemas"]["ViewForResponse"];
                        updatedFields?: string[];
                    };
                };
            };
            responses: {
                /** @description Return a 200 status to indicate that the data was received successfully */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "View Deleted": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description HMAC SHA256 signature of the request payload using the webhook secret. To compute the signature:
                     *     1. Concatenate `X-Twenty-Webhook-Timestamp`, a colon (:), and the JSON string of the request payload.
                     *     2. Compute the HMAC SHA256 hash using the shared secret as the key.
                     *     3. Send the resulting hex digest as this header value.
                     *     Example (Node.js):
                     *     ```javascript
                     *     const crypto = require("crypto");
                     *     const timestamp = "1735066639761";
                     *     const payload = JSON.stringify({...});
                     *     const secret = "your-secret";
                     *     const stringToSign = `${timestamp}:${JSON.stringify(payload)}`;
                     *     const signature = crypto.createHmac("sha256", secret)
                     *       .update(stringToSign)
                     *       .digest("hex");
                     *     ``` */
                    "X-Twenty-Webhook-Signature"?: string;
                    /** @description Unix timestamp of when the webhook was sent. This timestamp is included in the HMAC signature generation to prevent replay attacks. */
                    "X-Twenty-Webhook-Timestamp"?: string;
                    /** @description Unique identifier for this webhook request to prevent replay attacks. Consumers should ensure this nonce is not reused. */
                    "X-Twenty-Webhook-Nonce"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @example https://example.com/incomingWebhook */
                        targetUrl?: string;
                        /** @example view.deleted */
                        eventName?: string;
                        objectMetadata?: {
                            /** @example 370985db-22d8-4463-8e5f-2271d30913bd */
                            id?: string;
                            /** @enum {string} */
                            nameSingular?: "view";
                        };
                        /** @example 872cfcf1-c79f-42bc-877d-5829f06eb3f9 */
                        workspaceId?: string;
                        /** @example 90056586-1228-4e03-a507-70140aa85c05 */
                        webhookId?: string;
                        /** @example 2024-02-14T11:27:01.779Z */
                        eventDate?: string;
                        record?: components["schemas"]["ViewForResponse"];
                    };
                };
            };
            responses: {
                /** @description Return a 200 status to indicate that the data was received successfully */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "ViewSort Created": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description HMAC SHA256 signature of the request payload using the webhook secret. To compute the signature:
                     *     1. Concatenate `X-Twenty-Webhook-Timestamp`, a colon (:), and the JSON string of the request payload.
                     *     2. Compute the HMAC SHA256 hash using the shared secret as the key.
                     *     3. Send the resulting hex digest as this header value.
                     *     Example (Node.js):
                     *     ```javascript
                     *     const crypto = require("crypto");
                     *     const timestamp = "1735066639761";
                     *     const payload = JSON.stringify({...});
                     *     const secret = "your-secret";
                     *     const stringToSign = `${timestamp}:${JSON.stringify(payload)}`;
                     *     const signature = crypto.createHmac("sha256", secret)
                     *       .update(stringToSign)
                     *       .digest("hex");
                     *     ``` */
                    "X-Twenty-Webhook-Signature"?: string;
                    /** @description Unix timestamp of when the webhook was sent. This timestamp is included in the HMAC signature generation to prevent replay attacks. */
                    "X-Twenty-Webhook-Timestamp"?: string;
                    /** @description Unique identifier for this webhook request to prevent replay attacks. Consumers should ensure this nonce is not reused. */
                    "X-Twenty-Webhook-Nonce"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @example https://example.com/incomingWebhook */
                        targetUrl?: string;
                        /** @example viewSort.created */
                        eventName?: string;
                        objectMetadata?: {
                            /** @example 370985db-22d8-4463-8e5f-2271d30913bd */
                            id?: string;
                            /** @enum {string} */
                            nameSingular?: "viewSort";
                        };
                        /** @example 872cfcf1-c79f-42bc-877d-5829f06eb3f9 */
                        workspaceId?: string;
                        /** @example 90056586-1228-4e03-a507-70140aa85c05 */
                        webhookId?: string;
                        /** @example 2024-02-14T11:27:01.779Z */
                        eventDate?: string;
                        record?: components["schemas"]["ViewSortForResponse"];
                    };
                };
            };
            responses: {
                /** @description Return a 200 status to indicate that the data was received successfully */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "ViewSort Updated": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description HMAC SHA256 signature of the request payload using the webhook secret. To compute the signature:
                     *     1. Concatenate `X-Twenty-Webhook-Timestamp`, a colon (:), and the JSON string of the request payload.
                     *     2. Compute the HMAC SHA256 hash using the shared secret as the key.
                     *     3. Send the resulting hex digest as this header value.
                     *     Example (Node.js):
                     *     ```javascript
                     *     const crypto = require("crypto");
                     *     const timestamp = "1735066639761";
                     *     const payload = JSON.stringify({...});
                     *     const secret = "your-secret";
                     *     const stringToSign = `${timestamp}:${JSON.stringify(payload)}`;
                     *     const signature = crypto.createHmac("sha256", secret)
                     *       .update(stringToSign)
                     *       .digest("hex");
                     *     ``` */
                    "X-Twenty-Webhook-Signature"?: string;
                    /** @description Unix timestamp of when the webhook was sent. This timestamp is included in the HMAC signature generation to prevent replay attacks. */
                    "X-Twenty-Webhook-Timestamp"?: string;
                    /** @description Unique identifier for this webhook request to prevent replay attacks. Consumers should ensure this nonce is not reused. */
                    "X-Twenty-Webhook-Nonce"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @example https://example.com/incomingWebhook */
                        targetUrl?: string;
                        /** @example viewSort.updated */
                        eventName?: string;
                        objectMetadata?: {
                            /** @example 370985db-22d8-4463-8e5f-2271d30913bd */
                            id?: string;
                            /** @enum {string} */
                            nameSingular?: "viewSort";
                        };
                        /** @example 872cfcf1-c79f-42bc-877d-5829f06eb3f9 */
                        workspaceId?: string;
                        /** @example 90056586-1228-4e03-a507-70140aa85c05 */
                        webhookId?: string;
                        /** @example 2024-02-14T11:27:01.779Z */
                        eventDate?: string;
                        record?: components["schemas"]["ViewSortForResponse"];
                        updatedFields?: string[];
                    };
                };
            };
            responses: {
                /** @description Return a 200 status to indicate that the data was received successfully */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "ViewSort Deleted": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description HMAC SHA256 signature of the request payload using the webhook secret. To compute the signature:
                     *     1. Concatenate `X-Twenty-Webhook-Timestamp`, a colon (:), and the JSON string of the request payload.
                     *     2. Compute the HMAC SHA256 hash using the shared secret as the key.
                     *     3. Send the resulting hex digest as this header value.
                     *     Example (Node.js):
                     *     ```javascript
                     *     const crypto = require("crypto");
                     *     const timestamp = "1735066639761";
                     *     const payload = JSON.stringify({...});
                     *     const secret = "your-secret";
                     *     const stringToSign = `${timestamp}:${JSON.stringify(payload)}`;
                     *     const signature = crypto.createHmac("sha256", secret)
                     *       .update(stringToSign)
                     *       .digest("hex");
                     *     ``` */
                    "X-Twenty-Webhook-Signature"?: string;
                    /** @description Unix timestamp of when the webhook was sent. This timestamp is included in the HMAC signature generation to prevent replay attacks. */
                    "X-Twenty-Webhook-Timestamp"?: string;
                    /** @description Unique identifier for this webhook request to prevent replay attacks. Consumers should ensure this nonce is not reused. */
                    "X-Twenty-Webhook-Nonce"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @example https://example.com/incomingWebhook */
                        targetUrl?: string;
                        /** @example viewSort.deleted */
                        eventName?: string;
                        objectMetadata?: {
                            /** @example 370985db-22d8-4463-8e5f-2271d30913bd */
                            id?: string;
                            /** @enum {string} */
                            nameSingular?: "viewSort";
                        };
                        /** @example 872cfcf1-c79f-42bc-877d-5829f06eb3f9 */
                        workspaceId?: string;
                        /** @example 90056586-1228-4e03-a507-70140aa85c05 */
                        webhookId?: string;
                        /** @example 2024-02-14T11:27:01.779Z */
                        eventDate?: string;
                        record?: components["schemas"]["ViewSortForResponse"];
                    };
                };
            };
            responses: {
                /** @description Return a 200 status to indicate that the data was received successfully */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "WorkflowAutomatedTrigger Created": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description HMAC SHA256 signature of the request payload using the webhook secret. To compute the signature:
                     *     1. Concatenate `X-Twenty-Webhook-Timestamp`, a colon (:), and the JSON string of the request payload.
                     *     2. Compute the HMAC SHA256 hash using the shared secret as the key.
                     *     3. Send the resulting hex digest as this header value.
                     *     Example (Node.js):
                     *     ```javascript
                     *     const crypto = require("crypto");
                     *     const timestamp = "1735066639761";
                     *     const payload = JSON.stringify({...});
                     *     const secret = "your-secret";
                     *     const stringToSign = `${timestamp}:${JSON.stringify(payload)}`;
                     *     const signature = crypto.createHmac("sha256", secret)
                     *       .update(stringToSign)
                     *       .digest("hex");
                     *     ``` */
                    "X-Twenty-Webhook-Signature"?: string;
                    /** @description Unix timestamp of when the webhook was sent. This timestamp is included in the HMAC signature generation to prevent replay attacks. */
                    "X-Twenty-Webhook-Timestamp"?: string;
                    /** @description Unique identifier for this webhook request to prevent replay attacks. Consumers should ensure this nonce is not reused. */
                    "X-Twenty-Webhook-Nonce"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @example https://example.com/incomingWebhook */
                        targetUrl?: string;
                        /** @example workflowAutomatedTrigger.created */
                        eventName?: string;
                        objectMetadata?: {
                            /** @example 370985db-22d8-4463-8e5f-2271d30913bd */
                            id?: string;
                            /** @enum {string} */
                            nameSingular?: "workflowAutomatedTrigger";
                        };
                        /** @example 872cfcf1-c79f-42bc-877d-5829f06eb3f9 */
                        workspaceId?: string;
                        /** @example 90056586-1228-4e03-a507-70140aa85c05 */
                        webhookId?: string;
                        /** @example 2024-02-14T11:27:01.779Z */
                        eventDate?: string;
                        record?: components["schemas"]["WorkflowAutomatedTriggerForResponse"];
                    };
                };
            };
            responses: {
                /** @description Return a 200 status to indicate that the data was received successfully */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "WorkflowAutomatedTrigger Updated": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description HMAC SHA256 signature of the request payload using the webhook secret. To compute the signature:
                     *     1. Concatenate `X-Twenty-Webhook-Timestamp`, a colon (:), and the JSON string of the request payload.
                     *     2. Compute the HMAC SHA256 hash using the shared secret as the key.
                     *     3. Send the resulting hex digest as this header value.
                     *     Example (Node.js):
                     *     ```javascript
                     *     const crypto = require("crypto");
                     *     const timestamp = "1735066639761";
                     *     const payload = JSON.stringify({...});
                     *     const secret = "your-secret";
                     *     const stringToSign = `${timestamp}:${JSON.stringify(payload)}`;
                     *     const signature = crypto.createHmac("sha256", secret)
                     *       .update(stringToSign)
                     *       .digest("hex");
                     *     ``` */
                    "X-Twenty-Webhook-Signature"?: string;
                    /** @description Unix timestamp of when the webhook was sent. This timestamp is included in the HMAC signature generation to prevent replay attacks. */
                    "X-Twenty-Webhook-Timestamp"?: string;
                    /** @description Unique identifier for this webhook request to prevent replay attacks. Consumers should ensure this nonce is not reused. */
                    "X-Twenty-Webhook-Nonce"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @example https://example.com/incomingWebhook */
                        targetUrl?: string;
                        /** @example workflowAutomatedTrigger.updated */
                        eventName?: string;
                        objectMetadata?: {
                            /** @example 370985db-22d8-4463-8e5f-2271d30913bd */
                            id?: string;
                            /** @enum {string} */
                            nameSingular?: "workflowAutomatedTrigger";
                        };
                        /** @example 872cfcf1-c79f-42bc-877d-5829f06eb3f9 */
                        workspaceId?: string;
                        /** @example 90056586-1228-4e03-a507-70140aa85c05 */
                        webhookId?: string;
                        /** @example 2024-02-14T11:27:01.779Z */
                        eventDate?: string;
                        record?: components["schemas"]["WorkflowAutomatedTriggerForResponse"];
                        updatedFields?: string[];
                    };
                };
            };
            responses: {
                /** @description Return a 200 status to indicate that the data was received successfully */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "WorkflowAutomatedTrigger Deleted": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description HMAC SHA256 signature of the request payload using the webhook secret. To compute the signature:
                     *     1. Concatenate `X-Twenty-Webhook-Timestamp`, a colon (:), and the JSON string of the request payload.
                     *     2. Compute the HMAC SHA256 hash using the shared secret as the key.
                     *     3. Send the resulting hex digest as this header value.
                     *     Example (Node.js):
                     *     ```javascript
                     *     const crypto = require("crypto");
                     *     const timestamp = "1735066639761";
                     *     const payload = JSON.stringify({...});
                     *     const secret = "your-secret";
                     *     const stringToSign = `${timestamp}:${JSON.stringify(payload)}`;
                     *     const signature = crypto.createHmac("sha256", secret)
                     *       .update(stringToSign)
                     *       .digest("hex");
                     *     ``` */
                    "X-Twenty-Webhook-Signature"?: string;
                    /** @description Unix timestamp of when the webhook was sent. This timestamp is included in the HMAC signature generation to prevent replay attacks. */
                    "X-Twenty-Webhook-Timestamp"?: string;
                    /** @description Unique identifier for this webhook request to prevent replay attacks. Consumers should ensure this nonce is not reused. */
                    "X-Twenty-Webhook-Nonce"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @example https://example.com/incomingWebhook */
                        targetUrl?: string;
                        /** @example workflowAutomatedTrigger.deleted */
                        eventName?: string;
                        objectMetadata?: {
                            /** @example 370985db-22d8-4463-8e5f-2271d30913bd */
                            id?: string;
                            /** @enum {string} */
                            nameSingular?: "workflowAutomatedTrigger";
                        };
                        /** @example 872cfcf1-c79f-42bc-877d-5829f06eb3f9 */
                        workspaceId?: string;
                        /** @example 90056586-1228-4e03-a507-70140aa85c05 */
                        webhookId?: string;
                        /** @example 2024-02-14T11:27:01.779Z */
                        eventDate?: string;
                        record?: components["schemas"]["WorkflowAutomatedTriggerForResponse"];
                    };
                };
            };
            responses: {
                /** @description Return a 200 status to indicate that the data was received successfully */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "WorkflowRun Created": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description HMAC SHA256 signature of the request payload using the webhook secret. To compute the signature:
                     *     1. Concatenate `X-Twenty-Webhook-Timestamp`, a colon (:), and the JSON string of the request payload.
                     *     2. Compute the HMAC SHA256 hash using the shared secret as the key.
                     *     3. Send the resulting hex digest as this header value.
                     *     Example (Node.js):
                     *     ```javascript
                     *     const crypto = require("crypto");
                     *     const timestamp = "1735066639761";
                     *     const payload = JSON.stringify({...});
                     *     const secret = "your-secret";
                     *     const stringToSign = `${timestamp}:${JSON.stringify(payload)}`;
                     *     const signature = crypto.createHmac("sha256", secret)
                     *       .update(stringToSign)
                     *       .digest("hex");
                     *     ``` */
                    "X-Twenty-Webhook-Signature"?: string;
                    /** @description Unix timestamp of when the webhook was sent. This timestamp is included in the HMAC signature generation to prevent replay attacks. */
                    "X-Twenty-Webhook-Timestamp"?: string;
                    /** @description Unique identifier for this webhook request to prevent replay attacks. Consumers should ensure this nonce is not reused. */
                    "X-Twenty-Webhook-Nonce"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @example https://example.com/incomingWebhook */
                        targetUrl?: string;
                        /** @example workflowRun.created */
                        eventName?: string;
                        objectMetadata?: {
                            /** @example 370985db-22d8-4463-8e5f-2271d30913bd */
                            id?: string;
                            /** @enum {string} */
                            nameSingular?: "workflowRun";
                        };
                        /** @example 872cfcf1-c79f-42bc-877d-5829f06eb3f9 */
                        workspaceId?: string;
                        /** @example 90056586-1228-4e03-a507-70140aa85c05 */
                        webhookId?: string;
                        /** @example 2024-02-14T11:27:01.779Z */
                        eventDate?: string;
                        record?: components["schemas"]["WorkflowRunForResponse"];
                    };
                };
            };
            responses: {
                /** @description Return a 200 status to indicate that the data was received successfully */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "WorkflowRun Updated": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description HMAC SHA256 signature of the request payload using the webhook secret. To compute the signature:
                     *     1. Concatenate `X-Twenty-Webhook-Timestamp`, a colon (:), and the JSON string of the request payload.
                     *     2. Compute the HMAC SHA256 hash using the shared secret as the key.
                     *     3. Send the resulting hex digest as this header value.
                     *     Example (Node.js):
                     *     ```javascript
                     *     const crypto = require("crypto");
                     *     const timestamp = "1735066639761";
                     *     const payload = JSON.stringify({...});
                     *     const secret = "your-secret";
                     *     const stringToSign = `${timestamp}:${JSON.stringify(payload)}`;
                     *     const signature = crypto.createHmac("sha256", secret)
                     *       .update(stringToSign)
                     *       .digest("hex");
                     *     ``` */
                    "X-Twenty-Webhook-Signature"?: string;
                    /** @description Unix timestamp of when the webhook was sent. This timestamp is included in the HMAC signature generation to prevent replay attacks. */
                    "X-Twenty-Webhook-Timestamp"?: string;
                    /** @description Unique identifier for this webhook request to prevent replay attacks. Consumers should ensure this nonce is not reused. */
                    "X-Twenty-Webhook-Nonce"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @example https://example.com/incomingWebhook */
                        targetUrl?: string;
                        /** @example workflowRun.updated */
                        eventName?: string;
                        objectMetadata?: {
                            /** @example 370985db-22d8-4463-8e5f-2271d30913bd */
                            id?: string;
                            /** @enum {string} */
                            nameSingular?: "workflowRun";
                        };
                        /** @example 872cfcf1-c79f-42bc-877d-5829f06eb3f9 */
                        workspaceId?: string;
                        /** @example 90056586-1228-4e03-a507-70140aa85c05 */
                        webhookId?: string;
                        /** @example 2024-02-14T11:27:01.779Z */
                        eventDate?: string;
                        record?: components["schemas"]["WorkflowRunForResponse"];
                        updatedFields?: string[];
                    };
                };
            };
            responses: {
                /** @description Return a 200 status to indicate that the data was received successfully */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "WorkflowRun Deleted": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description HMAC SHA256 signature of the request payload using the webhook secret. To compute the signature:
                     *     1. Concatenate `X-Twenty-Webhook-Timestamp`, a colon (:), and the JSON string of the request payload.
                     *     2. Compute the HMAC SHA256 hash using the shared secret as the key.
                     *     3. Send the resulting hex digest as this header value.
                     *     Example (Node.js):
                     *     ```javascript
                     *     const crypto = require("crypto");
                     *     const timestamp = "1735066639761";
                     *     const payload = JSON.stringify({...});
                     *     const secret = "your-secret";
                     *     const stringToSign = `${timestamp}:${JSON.stringify(payload)}`;
                     *     const signature = crypto.createHmac("sha256", secret)
                     *       .update(stringToSign)
                     *       .digest("hex");
                     *     ``` */
                    "X-Twenty-Webhook-Signature"?: string;
                    /** @description Unix timestamp of when the webhook was sent. This timestamp is included in the HMAC signature generation to prevent replay attacks. */
                    "X-Twenty-Webhook-Timestamp"?: string;
                    /** @description Unique identifier for this webhook request to prevent replay attacks. Consumers should ensure this nonce is not reused. */
                    "X-Twenty-Webhook-Nonce"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @example https://example.com/incomingWebhook */
                        targetUrl?: string;
                        /** @example workflowRun.deleted */
                        eventName?: string;
                        objectMetadata?: {
                            /** @example 370985db-22d8-4463-8e5f-2271d30913bd */
                            id?: string;
                            /** @enum {string} */
                            nameSingular?: "workflowRun";
                        };
                        /** @example 872cfcf1-c79f-42bc-877d-5829f06eb3f9 */
                        workspaceId?: string;
                        /** @example 90056586-1228-4e03-a507-70140aa85c05 */
                        webhookId?: string;
                        /** @example 2024-02-14T11:27:01.779Z */
                        eventDate?: string;
                        record?: components["schemas"]["WorkflowRunForResponse"];
                    };
                };
            };
            responses: {
                /** @description Return a 200 status to indicate that the data was received successfully */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "Workflow Created": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description HMAC SHA256 signature of the request payload using the webhook secret. To compute the signature:
                     *     1. Concatenate `X-Twenty-Webhook-Timestamp`, a colon (:), and the JSON string of the request payload.
                     *     2. Compute the HMAC SHA256 hash using the shared secret as the key.
                     *     3. Send the resulting hex digest as this header value.
                     *     Example (Node.js):
                     *     ```javascript
                     *     const crypto = require("crypto");
                     *     const timestamp = "1735066639761";
                     *     const payload = JSON.stringify({...});
                     *     const secret = "your-secret";
                     *     const stringToSign = `${timestamp}:${JSON.stringify(payload)}`;
                     *     const signature = crypto.createHmac("sha256", secret)
                     *       .update(stringToSign)
                     *       .digest("hex");
                     *     ``` */
                    "X-Twenty-Webhook-Signature"?: string;
                    /** @description Unix timestamp of when the webhook was sent. This timestamp is included in the HMAC signature generation to prevent replay attacks. */
                    "X-Twenty-Webhook-Timestamp"?: string;
                    /** @description Unique identifier for this webhook request to prevent replay attacks. Consumers should ensure this nonce is not reused. */
                    "X-Twenty-Webhook-Nonce"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @example https://example.com/incomingWebhook */
                        targetUrl?: string;
                        /** @example workflow.created */
                        eventName?: string;
                        objectMetadata?: {
                            /** @example 370985db-22d8-4463-8e5f-2271d30913bd */
                            id?: string;
                            /** @enum {string} */
                            nameSingular?: "workflow";
                        };
                        /** @example 872cfcf1-c79f-42bc-877d-5829f06eb3f9 */
                        workspaceId?: string;
                        /** @example 90056586-1228-4e03-a507-70140aa85c05 */
                        webhookId?: string;
                        /** @example 2024-02-14T11:27:01.779Z */
                        eventDate?: string;
                        record?: components["schemas"]["WorkflowForResponse"];
                    };
                };
            };
            responses: {
                /** @description Return a 200 status to indicate that the data was received successfully */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "Workflow Updated": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description HMAC SHA256 signature of the request payload using the webhook secret. To compute the signature:
                     *     1. Concatenate `X-Twenty-Webhook-Timestamp`, a colon (:), and the JSON string of the request payload.
                     *     2. Compute the HMAC SHA256 hash using the shared secret as the key.
                     *     3. Send the resulting hex digest as this header value.
                     *     Example (Node.js):
                     *     ```javascript
                     *     const crypto = require("crypto");
                     *     const timestamp = "1735066639761";
                     *     const payload = JSON.stringify({...});
                     *     const secret = "your-secret";
                     *     const stringToSign = `${timestamp}:${JSON.stringify(payload)}`;
                     *     const signature = crypto.createHmac("sha256", secret)
                     *       .update(stringToSign)
                     *       .digest("hex");
                     *     ``` */
                    "X-Twenty-Webhook-Signature"?: string;
                    /** @description Unix timestamp of when the webhook was sent. This timestamp is included in the HMAC signature generation to prevent replay attacks. */
                    "X-Twenty-Webhook-Timestamp"?: string;
                    /** @description Unique identifier for this webhook request to prevent replay attacks. Consumers should ensure this nonce is not reused. */
                    "X-Twenty-Webhook-Nonce"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @example https://example.com/incomingWebhook */
                        targetUrl?: string;
                        /** @example workflow.updated */
                        eventName?: string;
                        objectMetadata?: {
                            /** @example 370985db-22d8-4463-8e5f-2271d30913bd */
                            id?: string;
                            /** @enum {string} */
                            nameSingular?: "workflow";
                        };
                        /** @example 872cfcf1-c79f-42bc-877d-5829f06eb3f9 */
                        workspaceId?: string;
                        /** @example 90056586-1228-4e03-a507-70140aa85c05 */
                        webhookId?: string;
                        /** @example 2024-02-14T11:27:01.779Z */
                        eventDate?: string;
                        record?: components["schemas"]["WorkflowForResponse"];
                        updatedFields?: string[];
                    };
                };
            };
            responses: {
                /** @description Return a 200 status to indicate that the data was received successfully */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "Workflow Deleted": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description HMAC SHA256 signature of the request payload using the webhook secret. To compute the signature:
                     *     1. Concatenate `X-Twenty-Webhook-Timestamp`, a colon (:), and the JSON string of the request payload.
                     *     2. Compute the HMAC SHA256 hash using the shared secret as the key.
                     *     3. Send the resulting hex digest as this header value.
                     *     Example (Node.js):
                     *     ```javascript
                     *     const crypto = require("crypto");
                     *     const timestamp = "1735066639761";
                     *     const payload = JSON.stringify({...});
                     *     const secret = "your-secret";
                     *     const stringToSign = `${timestamp}:${JSON.stringify(payload)}`;
                     *     const signature = crypto.createHmac("sha256", secret)
                     *       .update(stringToSign)
                     *       .digest("hex");
                     *     ``` */
                    "X-Twenty-Webhook-Signature"?: string;
                    /** @description Unix timestamp of when the webhook was sent. This timestamp is included in the HMAC signature generation to prevent replay attacks. */
                    "X-Twenty-Webhook-Timestamp"?: string;
                    /** @description Unique identifier for this webhook request to prevent replay attacks. Consumers should ensure this nonce is not reused. */
                    "X-Twenty-Webhook-Nonce"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @example https://example.com/incomingWebhook */
                        targetUrl?: string;
                        /** @example workflow.deleted */
                        eventName?: string;
                        objectMetadata?: {
                            /** @example 370985db-22d8-4463-8e5f-2271d30913bd */
                            id?: string;
                            /** @enum {string} */
                            nameSingular?: "workflow";
                        };
                        /** @example 872cfcf1-c79f-42bc-877d-5829f06eb3f9 */
                        workspaceId?: string;
                        /** @example 90056586-1228-4e03-a507-70140aa85c05 */
                        webhookId?: string;
                        /** @example 2024-02-14T11:27:01.779Z */
                        eventDate?: string;
                        record?: components["schemas"]["WorkflowForResponse"];
                    };
                };
            };
            responses: {
                /** @description Return a 200 status to indicate that the data was received successfully */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "WorkflowVersion Created": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description HMAC SHA256 signature of the request payload using the webhook secret. To compute the signature:
                     *     1. Concatenate `X-Twenty-Webhook-Timestamp`, a colon (:), and the JSON string of the request payload.
                     *     2. Compute the HMAC SHA256 hash using the shared secret as the key.
                     *     3. Send the resulting hex digest as this header value.
                     *     Example (Node.js):
                     *     ```javascript
                     *     const crypto = require("crypto");
                     *     const timestamp = "1735066639761";
                     *     const payload = JSON.stringify({...});
                     *     const secret = "your-secret";
                     *     const stringToSign = `${timestamp}:${JSON.stringify(payload)}`;
                     *     const signature = crypto.createHmac("sha256", secret)
                     *       .update(stringToSign)
                     *       .digest("hex");
                     *     ``` */
                    "X-Twenty-Webhook-Signature"?: string;
                    /** @description Unix timestamp of when the webhook was sent. This timestamp is included in the HMAC signature generation to prevent replay attacks. */
                    "X-Twenty-Webhook-Timestamp"?: string;
                    /** @description Unique identifier for this webhook request to prevent replay attacks. Consumers should ensure this nonce is not reused. */
                    "X-Twenty-Webhook-Nonce"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @example https://example.com/incomingWebhook */
                        targetUrl?: string;
                        /** @example workflowVersion.created */
                        eventName?: string;
                        objectMetadata?: {
                            /** @example 370985db-22d8-4463-8e5f-2271d30913bd */
                            id?: string;
                            /** @enum {string} */
                            nameSingular?: "workflowVersion";
                        };
                        /** @example 872cfcf1-c79f-42bc-877d-5829f06eb3f9 */
                        workspaceId?: string;
                        /** @example 90056586-1228-4e03-a507-70140aa85c05 */
                        webhookId?: string;
                        /** @example 2024-02-14T11:27:01.779Z */
                        eventDate?: string;
                        record?: components["schemas"]["WorkflowVersionForResponse"];
                    };
                };
            };
            responses: {
                /** @description Return a 200 status to indicate that the data was received successfully */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "WorkflowVersion Updated": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description HMAC SHA256 signature of the request payload using the webhook secret. To compute the signature:
                     *     1. Concatenate `X-Twenty-Webhook-Timestamp`, a colon (:), and the JSON string of the request payload.
                     *     2. Compute the HMAC SHA256 hash using the shared secret as the key.
                     *     3. Send the resulting hex digest as this header value.
                     *     Example (Node.js):
                     *     ```javascript
                     *     const crypto = require("crypto");
                     *     const timestamp = "1735066639761";
                     *     const payload = JSON.stringify({...});
                     *     const secret = "your-secret";
                     *     const stringToSign = `${timestamp}:${JSON.stringify(payload)}`;
                     *     const signature = crypto.createHmac("sha256", secret)
                     *       .update(stringToSign)
                     *       .digest("hex");
                     *     ``` */
                    "X-Twenty-Webhook-Signature"?: string;
                    /** @description Unix timestamp of when the webhook was sent. This timestamp is included in the HMAC signature generation to prevent replay attacks. */
                    "X-Twenty-Webhook-Timestamp"?: string;
                    /** @description Unique identifier for this webhook request to prevent replay attacks. Consumers should ensure this nonce is not reused. */
                    "X-Twenty-Webhook-Nonce"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @example https://example.com/incomingWebhook */
                        targetUrl?: string;
                        /** @example workflowVersion.updated */
                        eventName?: string;
                        objectMetadata?: {
                            /** @example 370985db-22d8-4463-8e5f-2271d30913bd */
                            id?: string;
                            /** @enum {string} */
                            nameSingular?: "workflowVersion";
                        };
                        /** @example 872cfcf1-c79f-42bc-877d-5829f06eb3f9 */
                        workspaceId?: string;
                        /** @example 90056586-1228-4e03-a507-70140aa85c05 */
                        webhookId?: string;
                        /** @example 2024-02-14T11:27:01.779Z */
                        eventDate?: string;
                        record?: components["schemas"]["WorkflowVersionForResponse"];
                        updatedFields?: string[];
                    };
                };
            };
            responses: {
                /** @description Return a 200 status to indicate that the data was received successfully */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "WorkflowVersion Deleted": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description HMAC SHA256 signature of the request payload using the webhook secret. To compute the signature:
                     *     1. Concatenate `X-Twenty-Webhook-Timestamp`, a colon (:), and the JSON string of the request payload.
                     *     2. Compute the HMAC SHA256 hash using the shared secret as the key.
                     *     3. Send the resulting hex digest as this header value.
                     *     Example (Node.js):
                     *     ```javascript
                     *     const crypto = require("crypto");
                     *     const timestamp = "1735066639761";
                     *     const payload = JSON.stringify({...});
                     *     const secret = "your-secret";
                     *     const stringToSign = `${timestamp}:${JSON.stringify(payload)}`;
                     *     const signature = crypto.createHmac("sha256", secret)
                     *       .update(stringToSign)
                     *       .digest("hex");
                     *     ``` */
                    "X-Twenty-Webhook-Signature"?: string;
                    /** @description Unix timestamp of when the webhook was sent. This timestamp is included in the HMAC signature generation to prevent replay attacks. */
                    "X-Twenty-Webhook-Timestamp"?: string;
                    /** @description Unique identifier for this webhook request to prevent replay attacks. Consumers should ensure this nonce is not reused. */
                    "X-Twenty-Webhook-Nonce"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @example https://example.com/incomingWebhook */
                        targetUrl?: string;
                        /** @example workflowVersion.deleted */
                        eventName?: string;
                        objectMetadata?: {
                            /** @example 370985db-22d8-4463-8e5f-2271d30913bd */
                            id?: string;
                            /** @enum {string} */
                            nameSingular?: "workflowVersion";
                        };
                        /** @example 872cfcf1-c79f-42bc-877d-5829f06eb3f9 */
                        workspaceId?: string;
                        /** @example 90056586-1228-4e03-a507-70140aa85c05 */
                        webhookId?: string;
                        /** @example 2024-02-14T11:27:01.779Z */
                        eventDate?: string;
                        record?: components["schemas"]["WorkflowVersionForResponse"];
                    };
                };
            };
            responses: {
                /** @description Return a 200 status to indicate that the data was received successfully */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "WorkspaceMember Created": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description HMAC SHA256 signature of the request payload using the webhook secret. To compute the signature:
                     *     1. Concatenate `X-Twenty-Webhook-Timestamp`, a colon (:), and the JSON string of the request payload.
                     *     2. Compute the HMAC SHA256 hash using the shared secret as the key.
                     *     3. Send the resulting hex digest as this header value.
                     *     Example (Node.js):
                     *     ```javascript
                     *     const crypto = require("crypto");
                     *     const timestamp = "1735066639761";
                     *     const payload = JSON.stringify({...});
                     *     const secret = "your-secret";
                     *     const stringToSign = `${timestamp}:${JSON.stringify(payload)}`;
                     *     const signature = crypto.createHmac("sha256", secret)
                     *       .update(stringToSign)
                     *       .digest("hex");
                     *     ``` */
                    "X-Twenty-Webhook-Signature"?: string;
                    /** @description Unix timestamp of when the webhook was sent. This timestamp is included in the HMAC signature generation to prevent replay attacks. */
                    "X-Twenty-Webhook-Timestamp"?: string;
                    /** @description Unique identifier for this webhook request to prevent replay attacks. Consumers should ensure this nonce is not reused. */
                    "X-Twenty-Webhook-Nonce"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @example https://example.com/incomingWebhook */
                        targetUrl?: string;
                        /** @example workspaceMember.created */
                        eventName?: string;
                        objectMetadata?: {
                            /** @example 370985db-22d8-4463-8e5f-2271d30913bd */
                            id?: string;
                            /** @enum {string} */
                            nameSingular?: "workspaceMember";
                        };
                        /** @example 872cfcf1-c79f-42bc-877d-5829f06eb3f9 */
                        workspaceId?: string;
                        /** @example 90056586-1228-4e03-a507-70140aa85c05 */
                        webhookId?: string;
                        /** @example 2024-02-14T11:27:01.779Z */
                        eventDate?: string;
                        record?: components["schemas"]["WorkspaceMemberForResponse"];
                    };
                };
            };
            responses: {
                /** @description Return a 200 status to indicate that the data was received successfully */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "WorkspaceMember Updated": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description HMAC SHA256 signature of the request payload using the webhook secret. To compute the signature:
                     *     1. Concatenate `X-Twenty-Webhook-Timestamp`, a colon (:), and the JSON string of the request payload.
                     *     2. Compute the HMAC SHA256 hash using the shared secret as the key.
                     *     3. Send the resulting hex digest as this header value.
                     *     Example (Node.js):
                     *     ```javascript
                     *     const crypto = require("crypto");
                     *     const timestamp = "1735066639761";
                     *     const payload = JSON.stringify({...});
                     *     const secret = "your-secret";
                     *     const stringToSign = `${timestamp}:${JSON.stringify(payload)}`;
                     *     const signature = crypto.createHmac("sha256", secret)
                     *       .update(stringToSign)
                     *       .digest("hex");
                     *     ``` */
                    "X-Twenty-Webhook-Signature"?: string;
                    /** @description Unix timestamp of when the webhook was sent. This timestamp is included in the HMAC signature generation to prevent replay attacks. */
                    "X-Twenty-Webhook-Timestamp"?: string;
                    /** @description Unique identifier for this webhook request to prevent replay attacks. Consumers should ensure this nonce is not reused. */
                    "X-Twenty-Webhook-Nonce"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @example https://example.com/incomingWebhook */
                        targetUrl?: string;
                        /** @example workspaceMember.updated */
                        eventName?: string;
                        objectMetadata?: {
                            /** @example 370985db-22d8-4463-8e5f-2271d30913bd */
                            id?: string;
                            /** @enum {string} */
                            nameSingular?: "workspaceMember";
                        };
                        /** @example 872cfcf1-c79f-42bc-877d-5829f06eb3f9 */
                        workspaceId?: string;
                        /** @example 90056586-1228-4e03-a507-70140aa85c05 */
                        webhookId?: string;
                        /** @example 2024-02-14T11:27:01.779Z */
                        eventDate?: string;
                        record?: components["schemas"]["WorkspaceMemberForResponse"];
                        updatedFields?: string[];
                    };
                };
            };
            responses: {
                /** @description Return a 200 status to indicate that the data was received successfully */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "WorkspaceMember Deleted": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description HMAC SHA256 signature of the request payload using the webhook secret. To compute the signature:
                     *     1. Concatenate `X-Twenty-Webhook-Timestamp`, a colon (:), and the JSON string of the request payload.
                     *     2. Compute the HMAC SHA256 hash using the shared secret as the key.
                     *     3. Send the resulting hex digest as this header value.
                     *     Example (Node.js):
                     *     ```javascript
                     *     const crypto = require("crypto");
                     *     const timestamp = "1735066639761";
                     *     const payload = JSON.stringify({...});
                     *     const secret = "your-secret";
                     *     const stringToSign = `${timestamp}:${JSON.stringify(payload)}`;
                     *     const signature = crypto.createHmac("sha256", secret)
                     *       .update(stringToSign)
                     *       .digest("hex");
                     *     ``` */
                    "X-Twenty-Webhook-Signature"?: string;
                    /** @description Unix timestamp of when the webhook was sent. This timestamp is included in the HMAC signature generation to prevent replay attacks. */
                    "X-Twenty-Webhook-Timestamp"?: string;
                    /** @description Unique identifier for this webhook request to prevent replay attacks. Consumers should ensure this nonce is not reused. */
                    "X-Twenty-Webhook-Nonce"?: string;
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @example https://example.com/incomingWebhook */
                        targetUrl?: string;
                        /** @example workspaceMember.deleted */
                        eventName?: string;
                        objectMetadata?: {
                            /** @example 370985db-22d8-4463-8e5f-2271d30913bd */
                            id?: string;
                            /** @enum {string} */
                            nameSingular?: "workspaceMember";
                        };
                        /** @example 872cfcf1-c79f-42bc-877d-5829f06eb3f9 */
                        workspaceId?: string;
                        /** @example 90056586-1228-4e03-a507-70140aa85c05 */
                        webhookId?: string;
                        /** @example 2024-02-14T11:27:01.779Z */
                        eventDate?: string;
                        record?: components["schemas"]["WorkspaceMemberForResponse"];
                    };
                };
            };
            responses: {
                /** @description Return a 200 status to indicate that the data was received successfully */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export interface components {
    schemas: {
        /**
         * @description An attachment
         * @example {
         *       "name": "Attachment name"
         *     }
         */
        Attachment: {
            /** @description Attachment full path */
            fullPath?: string;
            /** @description Attachment name */
            name?: string;
            /** Format: uuid */
            authorId?: string;
            /** Format: uuid */
            taskId?: string;
            /** Format: uuid */
            noteId?: string;
            /** Format: uuid */
            personId?: string;
            /** Format: uuid */
            companyId?: string;
            /** Format: uuid */
            opportunityId?: string;
            /** @description Attachment type */
            type?: string;
        };
        /**
         * @description An attachment
         * @example {
         *       "name": "Attachment name"
         *     }
         */
        AttachmentForUpdate: {
            /** @description Attachment full path */
            fullPath?: string;
            /** @description Attachment name */
            name?: string;
            /** Format: uuid */
            authorId?: string;
            /** Format: uuid */
            taskId?: string;
            /** Format: uuid */
            noteId?: string;
            /** Format: uuid */
            personId?: string;
            /** Format: uuid */
            companyId?: string;
            /** Format: uuid */
            opportunityId?: string;
            /** @description Attachment type */
            type?: string;
        };
        /** @description An attachment */
        AttachmentForResponse: {
            /** @description Attachment full path */
            fullPath?: string;
            /**
             * Format: uuid
             * @description Id
             */
            id?: string;
            /** @description Attachment name */
            name?: string;
            /**
             * Format: date-time
             * @description Creation date
             */
            createdAt?: string;
            /**
             * Format: date-time
             * @description Last time the record was changed
             */
            updatedAt?: string;
            /**
             * Format: date-time
             * @description Date when the record was deleted
             */
            deletedAt?: string;
            /** Format: uuid */
            authorId?: string;
            /** Format: uuid */
            taskId?: string;
            /** Format: uuid */
            noteId?: string;
            /** Format: uuid */
            personId?: string;
            /** Format: uuid */
            companyId?: string;
            /** Format: uuid */
            opportunityId?: string;
            /** @description Attachment type */
            type?: string;
            /** @description Attachment author */
            author?: components["schemas"]["WorkspaceMemberForResponse"];
            /** @description Attachment task */
            task?: components["schemas"]["TaskForResponse"];
            /** @description Attachment note */
            note?: components["schemas"]["NoteForResponse"];
            /** @description Attachment person */
            person?: components["schemas"]["PersonForResponse"];
            /** @description Attachment company */
            company?: components["schemas"]["CompanyForResponse"];
            /** @description Attachment opportunity */
            opportunity?: components["schemas"]["OpportunityForResponse"];
        };
        /**
         * @description Blocklist
         * @example {}
         */
        Blocklist: {
            /** @description Handle */
            handle?: string;
            /** Format: uuid */
            workspaceMemberId?: string;
        };
        /**
         * @description Blocklist
         * @example {}
         */
        BlocklistForUpdate: {
            /** @description Handle */
            handle?: string;
            /** Format: uuid */
            workspaceMemberId?: string;
        };
        /** @description Blocklist */
        BlocklistForResponse: {
            /**
             * Format: uuid
             * @description Id
             */
            id?: string;
            /** @description Handle */
            handle?: string;
            /**
             * Format: date-time
             * @description Creation date
             */
            createdAt?: string;
            /**
             * Format: date-time
             * @description Last time the record was changed
             */
            updatedAt?: string;
            /**
             * Format: date-time
             * @description Date when the record was deleted
             */
            deletedAt?: string;
            /** Format: uuid */
            workspaceMemberId?: string;
            /** @description WorkspaceMember */
            workspaceMember?: components["schemas"]["WorkspaceMemberForResponse"];
        };
        /**
         * @description Calendar Channel Event Associations
         * @example {}
         */
        CalendarChannelEventAssociation: {
            /** Format: uuid */
            calendarEventId?: string;
            /** Format: uuid */
            calendarChannelId?: string;
            /** @description Recurring Event ID */
            recurringEventExternalId?: string;
            /** @description Event external ID */
            eventExternalId?: string;
        };
        /**
         * @description Calendar Channel Event Associations
         * @example {}
         */
        CalendarChannelEventAssociationForUpdate: {
            /** Format: uuid */
            calendarEventId?: string;
            /** Format: uuid */
            calendarChannelId?: string;
            /** @description Recurring Event ID */
            recurringEventExternalId?: string;
            /** @description Event external ID */
            eventExternalId?: string;
        };
        /** @description Calendar Channel Event Associations */
        CalendarChannelEventAssociationForResponse: {
            /** Format: uuid */
            calendarEventId?: string;
            /** Format: uuid */
            calendarChannelId?: string;
            /**
             * Format: date-time
             * @description Date when the record was deleted
             */
            deletedAt?: string;
            /**
             * Format: date-time
             * @description Last time the record was changed
             */
            updatedAt?: string;
            /**
             * Format: date-time
             * @description Creation date
             */
            createdAt?: string;
            /**
             * Format: uuid
             * @description Id
             */
            id?: string;
            /** @description Recurring Event ID */
            recurringEventExternalId?: string;
            /** @description Event external ID */
            eventExternalId?: string;
            /** @description Event ID */
            calendarEvent?: components["schemas"]["CalendarEventForResponse"];
            /** @description Channel ID */
            calendarChannel?: components["schemas"]["CalendarChannelForResponse"];
        };
        /**
         * @description Calendar Channels
         * @example {
         *       "syncStatus": [
         *         "ONGOING"
         *       ],
         *       "syncStage": [
         *         "CALENDAR_EVENT_LIST_FETCH_PENDING"
         *       ],
         *       "visibility": [
         *         "METADATA"
         *       ],
         *       "contactAutoCreationPolicy": [
         *         "AS_PARTICIPANT_AND_ORGANIZER"
         *       ]
         *     }
         */
        CalendarChannel: {
            /** @description Handle */
            handle?: string;
            /**
             * @description Sync status
             * @enum {string}
             */
            syncStatus?: "ONGOING" | "NOT_SYNCED" | "ACTIVE" | "FAILED_INSUFFICIENT_PERMISSIONS" | "FAILED_UNKNOWN";
            /**
             * @description Sync stage
             * @enum {string}
             */
            syncStage?: "CALENDAR_EVENT_LIST_FETCH_PENDING" | "CALENDAR_EVENT_LIST_FETCH_SCHEDULED" | "CALENDAR_EVENT_LIST_FETCH_ONGOING" | "CALENDAR_EVENTS_IMPORT_PENDING" | "CALENDAR_EVENTS_IMPORT_SCHEDULED" | "CALENDAR_EVENTS_IMPORT_ONGOING" | "FAILED" | "FULL_CALENDAR_EVENT_LIST_FETCH_PENDING" | "PARTIAL_CALENDAR_EVENT_LIST_FETCH_PENDING";
            /**
             * @description Visibility
             * @enum {string}
             */
            visibility?: "METADATA" | "SHARE_EVERYTHING";
            /** @description Is Contact Auto Creation Enabled */
            isContactAutoCreationEnabled?: boolean;
            /**
             * @description Automatically create records for people you participated with in an event.
             * @enum {string}
             */
            contactAutoCreationPolicy?: "AS_PARTICIPANT_AND_ORGANIZER" | "AS_PARTICIPANT" | "AS_ORGANIZER" | "NONE";
            /** @description Is Sync Enabled */
            isSyncEnabled?: boolean;
            /** @description Sync Cursor. Used for syncing events from the calendar provider */
            syncCursor?: string;
            /**
             * Format: date-time
             * @description Last sync date
             */
            syncedAt?: string;
            /**
             * Format: date-time
             * @description Sync stage started at
             */
            syncStageStartedAt?: string;
            /** @description Throttle Failure Count */
            throttleFailureCount?: number;
            /** Format: uuid */
            connectedAccountId?: string;
        };
        /**
         * @description Calendar Channels
         * @example {
         *       "syncStatus": [
         *         "ONGOING"
         *       ],
         *       "syncStage": [
         *         "CALENDAR_EVENT_LIST_FETCH_PENDING"
         *       ],
         *       "visibility": [
         *         "METADATA"
         *       ],
         *       "contactAutoCreationPolicy": [
         *         "AS_PARTICIPANT_AND_ORGANIZER"
         *       ]
         *     }
         */
        CalendarChannelForUpdate: {
            /** @description Handle */
            handle?: string;
            /**
             * @description Sync status
             * @enum {string}
             */
            syncStatus?: "ONGOING" | "NOT_SYNCED" | "ACTIVE" | "FAILED_INSUFFICIENT_PERMISSIONS" | "FAILED_UNKNOWN";
            /**
             * @description Sync stage
             * @enum {string}
             */
            syncStage?: "CALENDAR_EVENT_LIST_FETCH_PENDING" | "CALENDAR_EVENT_LIST_FETCH_SCHEDULED" | "CALENDAR_EVENT_LIST_FETCH_ONGOING" | "CALENDAR_EVENTS_IMPORT_PENDING" | "CALENDAR_EVENTS_IMPORT_SCHEDULED" | "CALENDAR_EVENTS_IMPORT_ONGOING" | "FAILED" | "FULL_CALENDAR_EVENT_LIST_FETCH_PENDING" | "PARTIAL_CALENDAR_EVENT_LIST_FETCH_PENDING";
            /**
             * @description Visibility
             * @enum {string}
             */
            visibility?: "METADATA" | "SHARE_EVERYTHING";
            /** @description Is Contact Auto Creation Enabled */
            isContactAutoCreationEnabled?: boolean;
            /**
             * @description Automatically create records for people you participated with in an event.
             * @enum {string}
             */
            contactAutoCreationPolicy?: "AS_PARTICIPANT_AND_ORGANIZER" | "AS_PARTICIPANT" | "AS_ORGANIZER" | "NONE";
            /** @description Is Sync Enabled */
            isSyncEnabled?: boolean;
            /** @description Sync Cursor. Used for syncing events from the calendar provider */
            syncCursor?: string;
            /**
             * Format: date-time
             * @description Last sync date
             */
            syncedAt?: string;
            /**
             * Format: date-time
             * @description Sync stage started at
             */
            syncStageStartedAt?: string;
            /** @description Throttle Failure Count */
            throttleFailureCount?: number;
            /** Format: uuid */
            connectedAccountId?: string;
        };
        /** @description Calendar Channels */
        CalendarChannelForResponse: {
            /**
             * Format: uuid
             * @description Id
             */
            id?: string;
            /** @description Handle */
            handle?: string;
            /**
             * @description Sync status
             * @enum {string}
             */
            syncStatus?: "ONGOING" | "NOT_SYNCED" | "ACTIVE" | "FAILED_INSUFFICIENT_PERMISSIONS" | "FAILED_UNKNOWN";
            /**
             * @description Sync stage
             * @enum {string}
             */
            syncStage?: "CALENDAR_EVENT_LIST_FETCH_PENDING" | "CALENDAR_EVENT_LIST_FETCH_SCHEDULED" | "CALENDAR_EVENT_LIST_FETCH_ONGOING" | "CALENDAR_EVENTS_IMPORT_PENDING" | "CALENDAR_EVENTS_IMPORT_SCHEDULED" | "CALENDAR_EVENTS_IMPORT_ONGOING" | "FAILED" | "FULL_CALENDAR_EVENT_LIST_FETCH_PENDING" | "PARTIAL_CALENDAR_EVENT_LIST_FETCH_PENDING";
            /**
             * @description Visibility
             * @enum {string}
             */
            visibility?: "METADATA" | "SHARE_EVERYTHING";
            /** @description Is Contact Auto Creation Enabled */
            isContactAutoCreationEnabled?: boolean;
            /**
             * @description Automatically create records for people you participated with in an event.
             * @enum {string}
             */
            contactAutoCreationPolicy?: "AS_PARTICIPANT_AND_ORGANIZER" | "AS_PARTICIPANT" | "AS_ORGANIZER" | "NONE";
            /** @description Is Sync Enabled */
            isSyncEnabled?: boolean;
            /** @description Sync Cursor. Used for syncing events from the calendar provider */
            syncCursor?: string;
            /**
             * Format: date-time
             * @description Last sync date
             */
            syncedAt?: string;
            /**
             * Format: date-time
             * @description Sync stage started at
             */
            syncStageStartedAt?: string;
            /** @description Throttle Failure Count */
            throttleFailureCount?: number;
            /**
             * Format: date-time
             * @description Creation date
             */
            createdAt?: string;
            /**
             * Format: date-time
             * @description Last time the record was changed
             */
            updatedAt?: string;
            /**
             * Format: date-time
             * @description Date when the record was deleted
             */
            deletedAt?: string;
            /** Format: uuid */
            connectedAccountId?: string;
            /** @description Connected Account */
            connectedAccount?: components["schemas"]["ConnectedAccountForResponse"];
            /** @description Calendar Channel Event Associations */
            calendarChannelEventAssociations?: components["schemas"]["CalendarChannelEventAssociationForResponse"][];
        };
        /**
         * @description Calendar event participants
         * @example {
         *       "responseStatus": [
         *         "NEEDS_ACTION"
         *       ]
         *     }
         */
        CalendarEventParticipant: {
            /** @description Handle */
            handle?: string;
            /** @description Display Name */
            displayName?: string;
            /** @description Is Organizer */
            isOrganizer?: boolean;
            /**
             * @description Response Status
             * @enum {string}
             */
            responseStatus?: "NEEDS_ACTION" | "DECLINED" | "TENTATIVE" | "ACCEPTED";
            /** Format: uuid */
            calendarEventId?: string;
            /** Format: uuid */
            personId?: string;
            /** Format: uuid */
            workspaceMemberId?: string;
        };
        /**
         * @description Calendar event participants
         * @example {
         *       "responseStatus": [
         *         "NEEDS_ACTION"
         *       ]
         *     }
         */
        CalendarEventParticipantForUpdate: {
            /** @description Handle */
            handle?: string;
            /** @description Display Name */
            displayName?: string;
            /** @description Is Organizer */
            isOrganizer?: boolean;
            /**
             * @description Response Status
             * @enum {string}
             */
            responseStatus?: "NEEDS_ACTION" | "DECLINED" | "TENTATIVE" | "ACCEPTED";
            /** Format: uuid */
            calendarEventId?: string;
            /** Format: uuid */
            personId?: string;
            /** Format: uuid */
            workspaceMemberId?: string;
        };
        /** @description Calendar event participants */
        CalendarEventParticipantForResponse: {
            /** @description Handle */
            handle?: string;
            /** @description Display Name */
            displayName?: string;
            /** @description Is Organizer */
            isOrganizer?: boolean;
            /**
             * @description Response Status
             * @enum {string}
             */
            responseStatus?: "NEEDS_ACTION" | "DECLINED" | "TENTATIVE" | "ACCEPTED";
            /**
             * Format: uuid
             * @description Id
             */
            id?: string;
            /**
             * Format: date-time
             * @description Creation date
             */
            createdAt?: string;
            /**
             * Format: date-time
             * @description Last time the record was changed
             */
            updatedAt?: string;
            /**
             * Format: date-time
             * @description Date when the record was deleted
             */
            deletedAt?: string;
            /** Format: uuid */
            calendarEventId?: string;
            /** Format: uuid */
            personId?: string;
            /** Format: uuid */
            workspaceMemberId?: string;
            /** @description Event ID */
            calendarEvent?: components["schemas"]["CalendarEventForResponse"];
            /** @description Person */
            person?: components["schemas"]["PersonForResponse"];
            /** @description Workspace Member */
            workspaceMember?: components["schemas"]["WorkspaceMemberForResponse"];
        };
        /**
         * @description Calendar events
         * @example {
         *       "conferenceLink": {
         *         "primaryLinkLabel": "",
         *         "primaryLinkUrl": "https://meaty-assist.net/",
         *         "additionalLinks": []
         *       }
         *     }
         */
        CalendarEvent: {
            /** @description Location */
            location?: string;
            /** @description Is canceled */
            isCanceled?: boolean;
            /** @description Title */
            title?: string;
            /** @description Description */
            description?: string;
            /**
             * Format: date-time
             * @description Update DateTime
             */
            externalUpdatedAt?: string;
            /**
             * Format: date-time
             * @description Creation DateTime
             */
            externalCreatedAt?: string;
            /**
             * Format: date-time
             * @description End Date
             */
            endsAt?: string;
            /**
             * Format: date-time
             * @description Start Date
             */
            startsAt?: string;
            /** @description Is Full Day */
            isFullDay?: boolean;
            /** @description iCal UID */
            iCalUID?: string;
            /** @description Conference Solution */
            conferenceSolution?: string;
            /** @description Meet Link */
            conferenceLink?: {
                primaryLinkLabel?: string;
                primaryLinkUrl?: string;
                secondaryLinks?: {
                    /** Format: uri */
                    url?: string;
                    label?: string;
                }[];
            };
        };
        /**
         * @description Calendar events
         * @example {
         *       "conferenceLink": {
         *         "primaryLinkLabel": "",
         *         "primaryLinkUrl": "https://cruel-cop-out.info",
         *         "additionalLinks": []
         *       }
         *     }
         */
        CalendarEventForUpdate: {
            /** @description Location */
            location?: string;
            /** @description Is canceled */
            isCanceled?: boolean;
            /** @description Title */
            title?: string;
            /** @description Description */
            description?: string;
            /**
             * Format: date-time
             * @description Update DateTime
             */
            externalUpdatedAt?: string;
            /**
             * Format: date-time
             * @description Creation DateTime
             */
            externalCreatedAt?: string;
            /**
             * Format: date-time
             * @description End Date
             */
            endsAt?: string;
            /**
             * Format: date-time
             * @description Start Date
             */
            startsAt?: string;
            /** @description Is Full Day */
            isFullDay?: boolean;
            /** @description iCal UID */
            iCalUID?: string;
            /** @description Conference Solution */
            conferenceSolution?: string;
            /** @description Meet Link */
            conferenceLink?: {
                primaryLinkLabel?: string;
                primaryLinkUrl?: string;
                secondaryLinks?: {
                    /** Format: uri */
                    url?: string;
                    label?: string;
                }[];
            };
        };
        /** @description Calendar events */
        CalendarEventForResponse: {
            /**
             * Format: date-time
             * @description Creation date
             */
            createdAt?: string;
            /**
             * Format: date-time
             * @description Last time the record was changed
             */
            updatedAt?: string;
            /**
             * Format: date-time
             * @description Date when the record was deleted
             */
            deletedAt?: string;
            /** @description Location */
            location?: string;
            /** @description Is canceled */
            isCanceled?: boolean;
            /** @description Title */
            title?: string;
            /** @description Description */
            description?: string;
            /**
             * Format: date-time
             * @description Update DateTime
             */
            externalUpdatedAt?: string;
            /**
             * Format: date-time
             * @description Creation DateTime
             */
            externalCreatedAt?: string;
            /**
             * Format: date-time
             * @description End Date
             */
            endsAt?: string;
            /**
             * Format: date-time
             * @description Start Date
             */
            startsAt?: string;
            /** @description Is Full Day */
            isFullDay?: boolean;
            /** @description iCal UID */
            iCalUID?: string;
            /** @description Conference Solution */
            conferenceSolution?: string;
            /** @description Meet Link */
            conferenceLink?: {
                primaryLinkLabel?: string;
                primaryLinkUrl?: string;
                secondaryLinks?: {
                    /** Format: uri */
                    url?: string;
                    label?: string;
                }[];
            };
            /**
             * Format: uuid
             * @description Id
             */
            id?: string;
            /** @description Event Participants */
            calendarEventParticipants?: components["schemas"]["CalendarEventParticipantForResponse"][];
            /** @description Calendar Channel Event Associations */
            calendarChannelEventAssociations?: components["schemas"]["CalendarChannelEventAssociationForResponse"][];
        };
        /**
         * @description A company
         * @example {
         *       "name": "Company name",
         *       "domainName": {
         *         "primaryLinkLabel": "",
         *         "primaryLinkUrl": "https://favorite-clamp.net",
         *         "additionalLinks": []
         *       },
         *       "linkedinLink": {
         *         "primaryLinkLabel": "",
         *         "primaryLinkUrl": "https://thorough-lace.com",
         *         "additionalLinks": []
         *       },
         *       "xLink": {
         *         "primaryLinkLabel": "",
         *         "primaryLinkUrl": "https://rowdy-tribe.info/",
         *         "additionalLinks": []
         *       },
         *       "annualRecurringRevenue": {
         *         "amountMicros": 695000000,
         *         "currencyCode": "EUR"
         *       }
         *     }
         */
        Company: {
            /** Format: uuid */
            accountOwnerId?: string;
            /** @description The company name */
            name?: string;
            /** @description The company website URL. We use this url to fetch the company icon */
            domainName?: {
                primaryLinkLabel?: string;
                primaryLinkUrl?: string;
                secondaryLinks?: {
                    /** Format: uri */
                    url?: string;
                    label?: string;
                }[];
            };
            /** @description Number of employees in the company */
            employees?: number;
            /** @description The company Linkedin account */
            linkedinLink?: {
                primaryLinkLabel?: string;
                primaryLinkUrl?: string;
                secondaryLinks?: {
                    /** Format: uri */
                    url?: string;
                    label?: string;
                }[];
            };
            /** @description The company Twitter/X account */
            xLink?: {
                primaryLinkLabel?: string;
                primaryLinkUrl?: string;
                secondaryLinks?: {
                    /** Format: uri */
                    url?: string;
                    label?: string;
                }[];
            };
            /** @description Annual Recurring Revenue: The actual or estimated annual revenue of the company */
            annualRecurringRevenue?: {
                amountMicros?: number;
                currencyCode?: string;
            };
            /** @description Address of the company */
            address?: {
                addressStreet1?: string;
                addressStreet2?: string;
                addressCity?: string;
                addressPostcode?: string;
                addressState?: string;
                addressCountry?: string;
                addressLat?: number;
                addressLng?: number;
            };
            /** @description Ideal Customer Profile:  Indicates whether the company is the most suitable and valuable customer for you */
            idealCustomerProfile?: boolean;
            /** @description Company record position */
            position?: number;
            /** @description The creator of the record */
            createdBy?: {
                /** @enum {string} */
                source?: "EMAIL" | "CALENDAR" | "WORKFLOW" | "API" | "IMPORT" | "MANUAL" | "SYSTEM" | "WEBHOOK";
            };
        };
        /**
         * @description A company
         * @example {
         *       "name": "Company name",
         *       "domainName": {
         *         "primaryLinkLabel": "",
         *         "primaryLinkUrl": "https://outstanding-adult.name/",
         *         "additionalLinks": []
         *       },
         *       "linkedinLink": {
         *         "primaryLinkLabel": "",
         *         "primaryLinkUrl": "https://flickering-redesign.name",
         *         "additionalLinks": []
         *       },
         *       "xLink": {
         *         "primaryLinkLabel": "",
         *         "primaryLinkUrl": "https://sticky-order.biz/",
         *         "additionalLinks": []
         *       },
         *       "annualRecurringRevenue": {
         *         "amountMicros": 831000000,
         *         "currencyCode": "EUR"
         *       }
         *     }
         */
        CompanyForUpdate: {
            /** Format: uuid */
            accountOwnerId?: string;
            /** @description The company name */
            name?: string;
            /** @description The company website URL. We use this url to fetch the company icon */
            domainName?: {
                primaryLinkLabel?: string;
                primaryLinkUrl?: string;
                secondaryLinks?: {
                    /** Format: uri */
                    url?: string;
                    label?: string;
                }[];
            };
            /** @description Number of employees in the company */
            employees?: number;
            /** @description The company Linkedin account */
            linkedinLink?: {
                primaryLinkLabel?: string;
                primaryLinkUrl?: string;
                secondaryLinks?: {
                    /** Format: uri */
                    url?: string;
                    label?: string;
                }[];
            };
            /** @description The company Twitter/X account */
            xLink?: {
                primaryLinkLabel?: string;
                primaryLinkUrl?: string;
                secondaryLinks?: {
                    /** Format: uri */
                    url?: string;
                    label?: string;
                }[];
            };
            /** @description Annual Recurring Revenue: The actual or estimated annual revenue of the company */
            annualRecurringRevenue?: {
                amountMicros?: number;
                currencyCode?: string;
            };
            /** @description Address of the company */
            address?: {
                addressStreet1?: string;
                addressStreet2?: string;
                addressCity?: string;
                addressPostcode?: string;
                addressState?: string;
                addressCountry?: string;
                addressLat?: number;
                addressLng?: number;
            };
            /** @description Ideal Customer Profile:  Indicates whether the company is the most suitable and valuable customer for you */
            idealCustomerProfile?: boolean;
            /** @description Company record position */
            position?: number;
            /** @description The creator of the record */
            createdBy?: {
                /** @enum {string} */
                source?: "EMAIL" | "CALENDAR" | "WORKFLOW" | "API" | "IMPORT" | "MANUAL" | "SYSTEM" | "WEBHOOK";
            };
        };
        /** @description A company */
        CompanyForResponse: {
            /**
             * Format: date-time
             * @description Last time the record was changed
             */
            updatedAt?: string;
            /** Format: uuid */
            accountOwnerId?: string;
            /** @description The company name */
            name?: string;
            /** @description The company website URL. We use this url to fetch the company icon */
            domainName?: {
                primaryLinkLabel?: string;
                primaryLinkUrl?: string;
                secondaryLinks?: {
                    /** Format: uri */
                    url?: string;
                    label?: string;
                }[];
            };
            /** @description Number of employees in the company */
            employees?: number;
            /** @description The company Linkedin account */
            linkedinLink?: {
                primaryLinkLabel?: string;
                primaryLinkUrl?: string;
                secondaryLinks?: {
                    /** Format: uri */
                    url?: string;
                    label?: string;
                }[];
            };
            /** @description The company Twitter/X account */
            xLink?: {
                primaryLinkLabel?: string;
                primaryLinkUrl?: string;
                secondaryLinks?: {
                    /** Format: uri */
                    url?: string;
                    label?: string;
                }[];
            };
            /** @description Annual Recurring Revenue: The actual or estimated annual revenue of the company */
            annualRecurringRevenue?: {
                amountMicros?: number;
                currencyCode?: string;
            };
            /** @description Address of the company */
            address?: {
                addressStreet1?: string;
                addressStreet2?: string;
                addressCity?: string;
                addressPostcode?: string;
                addressState?: string;
                addressCountry?: string;
                addressLat?: number;
                addressLng?: number;
            };
            /** @description Ideal Customer Profile:  Indicates whether the company is the most suitable and valuable customer for you */
            idealCustomerProfile?: boolean;
            /** @description Company record position */
            position?: number;
            /** @description The creator of the record */
            createdBy?: {
                /** @enum {string} */
                source?: "EMAIL" | "CALENDAR" | "WORKFLOW" | "API" | "IMPORT" | "MANUAL" | "SYSTEM" | "WEBHOOK";
                /** Format: uuid */
                workspaceMemberId?: string;
                name?: string;
            };
            /**
             * Format: uuid
             * @description Id
             */
            id?: string;
            /**
             * Format: date-time
             * @description Creation date
             */
            createdAt?: string;
            /**
             * Format: date-time
             * @description Date when the record was deleted
             */
            deletedAt?: string;
            /** @description People linked to the company. */
            people?: components["schemas"]["PersonForResponse"][];
            /** @description Your team member responsible for managing the company account */
            accountOwner?: components["schemas"]["WorkspaceMemberForResponse"];
            /** @description Tasks tied to the company */
            taskTargets?: components["schemas"]["TaskTargetForResponse"][];
            /** @description Notes tied to the company */
            noteTargets?: components["schemas"]["NoteTargetForResponse"][];
            /** @description Opportunities linked to the company. */
            opportunities?: components["schemas"]["OpportunityForResponse"][];
            /** @description Favorites linked to the company */
            favorites?: components["schemas"]["FavoriteForResponse"][];
            /** @description Attachments linked to the company */
            attachments?: components["schemas"]["AttachmentForResponse"][];
            /** @description Timeline Activities linked to the company */
            timelineActivities?: components["schemas"]["TimelineActivityForResponse"][];
        };
        /**
         * @description A connected account
         * @example {}
         */
        ConnectedAccount: {
            /** @description The account handle (email, username, phone number, etc.) */
            handle?: string;
            /** @description The account provider */
            provider?: string;
            /** @description Messaging provider access token */
            accessToken?: string;
            /** @description Messaging provider refresh token */
            refreshToken?: string;
            /** @description Last sync history ID */
            lastSyncHistoryId?: string;
            /**
             * Format: date-time
             * @description Auth failed at
             */
            authFailedAt?: string;
            /** @description Handle Aliases */
            handleAliases?: string;
            /** @description Scopes */
            scopes?: string[];
            /** @description JSON object containing custom connection parameters */
            connectionParameters?: Record<string, never>;
            /** Format: uuid */
            accountOwnerId?: string;
        };
        /**
         * @description A connected account
         * @example {}
         */
        ConnectedAccountForUpdate: {
            /** @description The account handle (email, username, phone number, etc.) */
            handle?: string;
            /** @description The account provider */
            provider?: string;
            /** @description Messaging provider access token */
            accessToken?: string;
            /** @description Messaging provider refresh token */
            refreshToken?: string;
            /** @description Last sync history ID */
            lastSyncHistoryId?: string;
            /**
             * Format: date-time
             * @description Auth failed at
             */
            authFailedAt?: string;
            /** @description Handle Aliases */
            handleAliases?: string;
            /** @description Scopes */
            scopes?: string[];
            /** @description JSON object containing custom connection parameters */
            connectionParameters?: Record<string, never>;
            /** Format: uuid */
            accountOwnerId?: string;
        };
        /** @description A connected account */
        ConnectedAccountForResponse: {
            /** @description The account handle (email, username, phone number, etc.) */
            handle?: string;
            /** @description The account provider */
            provider?: string;
            /** @description Messaging provider access token */
            accessToken?: string;
            /** @description Messaging provider refresh token */
            refreshToken?: string;
            /** @description Last sync history ID */
            lastSyncHistoryId?: string;
            /**
             * Format: date-time
             * @description Auth failed at
             */
            authFailedAt?: string;
            /** @description Handle Aliases */
            handleAliases?: string;
            /** @description Scopes */
            scopes?: string[];
            /** @description JSON object containing custom connection parameters */
            connectionParameters?: Record<string, never>;
            /**
             * Format: uuid
             * @description Id
             */
            id?: string;
            /**
             * Format: date-time
             * @description Creation date
             */
            createdAt?: string;
            /**
             * Format: date-time
             * @description Last time the record was changed
             */
            updatedAt?: string;
            /**
             * Format: date-time
             * @description Date when the record was deleted
             */
            deletedAt?: string;
            /** Format: uuid */
            accountOwnerId?: string;
            /** @description Calendar Channels */
            calendarChannels?: components["schemas"]["CalendarChannelForResponse"][];
            /** @description Account Owner */
            accountOwner?: components["schemas"]["WorkspaceMemberForResponse"];
            /** @description Message Channels */
            messageChannels?: components["schemas"]["MessageChannelForResponse"][];
        };
        /**
         * @description A Folder of favorites
         * @example {
         *       "name": "Favorite Folder name"
         *     }
         */
        FavoriteFolder: {
            /** @description Favorite folder position */
            position?: number;
            /** @description Name of the favorite folder */
            name?: string;
        };
        /**
         * @description A Folder of favorites
         * @example {
         *       "name": "Favorite Folder name"
         *     }
         */
        FavoriteFolderForUpdate: {
            /** @description Favorite folder position */
            position?: number;
            /** @description Name of the favorite folder */
            name?: string;
        };
        /** @description A Folder of favorites */
        FavoriteFolderForResponse: {
            /** @description Favorite folder position */
            position?: number;
            /** @description Name of the favorite folder */
            name?: string;
            /**
             * Format: uuid
             * @description Id
             */
            id?: string;
            /**
             * Format: date-time
             * @description Creation date
             */
            createdAt?: string;
            /**
             * Format: date-time
             * @description Last time the record was changed
             */
            updatedAt?: string;
            /**
             * Format: date-time
             * @description Date when the record was deleted
             */
            deletedAt?: string;
            /** @description Favorites in this folder */
            favorites?: components["schemas"]["FavoriteForResponse"][];
        };
        /**
         * @description A favorite that can be accessed from the left menu
         * @example {}
         */
        Favorite: {
            /** Format: uuid */
            opportunityId?: string;
            /** Format: uuid */
            workflowId?: string;
            /** Format: uuid */
            workflowVersionId?: string;
            /** Format: uuid */
            workflowRunId?: string;
            /** Format: uuid */
            taskId?: string;
            /** Format: uuid */
            noteId?: string;
            /** @description Favorite position */
            position?: number;
            /**
             * Format: uuid
             * @description ViewId
             */
            viewId?: string;
            /** Format: uuid */
            forWorkspaceMemberId?: string;
            /** Format: uuid */
            personId?: string;
            /** Format: uuid */
            companyId?: string;
            /** Format: uuid */
            favoriteFolderId?: string;
        };
        /**
         * @description A favorite that can be accessed from the left menu
         * @example {}
         */
        FavoriteForUpdate: {
            /** Format: uuid */
            opportunityId?: string;
            /** Format: uuid */
            workflowId?: string;
            /** Format: uuid */
            workflowVersionId?: string;
            /** Format: uuid */
            workflowRunId?: string;
            /** Format: uuid */
            taskId?: string;
            /** Format: uuid */
            noteId?: string;
            /** @description Favorite position */
            position?: number;
            /**
             * Format: uuid
             * @description ViewId
             */
            viewId?: string;
            /** Format: uuid */
            forWorkspaceMemberId?: string;
            /** Format: uuid */
            personId?: string;
            /** Format: uuid */
            companyId?: string;
            /** Format: uuid */
            favoriteFolderId?: string;
        };
        /** @description A favorite that can be accessed from the left menu */
        FavoriteForResponse: {
            /** Format: uuid */
            opportunityId?: string;
            /** Format: uuid */
            workflowId?: string;
            /** Format: uuid */
            workflowVersionId?: string;
            /** Format: uuid */
            workflowRunId?: string;
            /** Format: uuid */
            taskId?: string;
            /** Format: uuid */
            noteId?: string;
            /** @description Favorite position */
            position?: number;
            /**
             * Format: uuid
             * @description ViewId
             */
            viewId?: string;
            /**
             * Format: uuid
             * @description Id
             */
            id?: string;
            /**
             * Format: date-time
             * @description Creation date
             */
            createdAt?: string;
            /**
             * Format: date-time
             * @description Last time the record was changed
             */
            updatedAt?: string;
            /**
             * Format: date-time
             * @description Date when the record was deleted
             */
            deletedAt?: string;
            /** Format: uuid */
            forWorkspaceMemberId?: string;
            /** Format: uuid */
            personId?: string;
            /** Format: uuid */
            companyId?: string;
            /** Format: uuid */
            favoriteFolderId?: string;
            /** @description Favorite opportunity */
            opportunity?: components["schemas"]["OpportunityForResponse"];
            /** @description Favorite workflow */
            workflow?: components["schemas"]["WorkflowForResponse"];
            /** @description Favorite workflow version */
            workflowVersion?: components["schemas"]["WorkflowVersionForResponse"];
            /** @description Favorite workflow run */
            workflowRun?: components["schemas"]["WorkflowRunForResponse"];
            /** @description Favorite task */
            task?: components["schemas"]["TaskForResponse"];
            /** @description Favorite note */
            note?: components["schemas"]["NoteForResponse"];
            /** @description Favorite workspace member */
            forWorkspaceMember?: components["schemas"]["WorkspaceMemberForResponse"];
            /** @description Favorite person */
            person?: components["schemas"]["PersonForResponse"];
            /** @description Favorite company */
            company?: components["schemas"]["CompanyForResponse"];
            /** @description The folder this favorite belongs to */
            favoriteFolder?: components["schemas"]["FavoriteFolderForResponse"];
        };
        /**
         * @description Message Synced with a Message Channel
         * @example {
         *       "direction": [
         *         "INCOMING"
         *       ]
         *     }
         */
        MessageChannelMessageAssociation: {
            /** Format: uuid */
            messageChannelId?: string;
            /**
             * @description Message Direction
             * @enum {string}
             */
            direction?: "INCOMING" | "OUTGOING";
            /** @description Thread id from the messaging provider */
            messageThreadExternalId?: string;
            /** Format: uuid */
            messageId?: string;
            /** @description Message id from the messaging provider */
            messageExternalId?: string;
        };
        /**
         * @description Message Synced with a Message Channel
         * @example {
         *       "direction": [
         *         "INCOMING"
         *       ]
         *     }
         */
        MessageChannelMessageAssociationForUpdate: {
            /** Format: uuid */
            messageChannelId?: string;
            /**
             * @description Message Direction
             * @enum {string}
             */
            direction?: "INCOMING" | "OUTGOING";
            /** @description Thread id from the messaging provider */
            messageThreadExternalId?: string;
            /** Format: uuid */
            messageId?: string;
            /** @description Message id from the messaging provider */
            messageExternalId?: string;
        };
        /** @description Message Synced with a Message Channel */
        MessageChannelMessageAssociationForResponse: {
            /** Format: uuid */
            messageChannelId?: string;
            /**
             * Format: date-time
             * @description Date when the record was deleted
             */
            deletedAt?: string;
            /**
             * Format: date-time
             * @description Last time the record was changed
             */
            updatedAt?: string;
            /**
             * Format: date-time
             * @description Creation date
             */
            createdAt?: string;
            /**
             * Format: uuid
             * @description Id
             */
            id?: string;
            /**
             * @description Message Direction
             * @enum {string}
             */
            direction?: "INCOMING" | "OUTGOING";
            /** @description Thread id from the messaging provider */
            messageThreadExternalId?: string;
            /** Format: uuid */
            messageId?: string;
            /** @description Message id from the messaging provider */
            messageExternalId?: string;
            /** @description Message Channel Id */
            messageChannel?: components["schemas"]["MessageChannelForResponse"];
            /** @description Message Id */
            message?: components["schemas"]["MessageForResponse"];
        };
        /**
         * @description Message Channels
         * @example {
         *       "visibility": [
         *         "METADATA"
         *       ],
         *       "type": [
         *         "email"
         *       ],
         *       "contactAutoCreationPolicy": [
         *         "SENT_AND_RECEIVED"
         *       ],
         *       "syncStatus": [
         *         "ONGOING"
         *       ],
         *       "syncStage": [
         *         "MESSAGE_LIST_FETCH_PENDING"
         *       ]
         *     }
         */
        MessageChannel: {
            /**
             * @description Visibility
             * @enum {string}
             */
            visibility?: "METADATA" | "SUBJECT" | "SHARE_EVERYTHING";
            /** @description Handle */
            handle?: string;
            /**
             * @description Channel Type
             * @enum {string}
             */
            type?: "email" | "sms";
            /** @description Is Contact Auto Creation Enabled */
            isContactAutoCreationEnabled?: boolean;
            /**
             * @description Automatically create People records when receiving or sending emails
             * @enum {string}
             */
            contactAutoCreationPolicy?: "SENT_AND_RECEIVED" | "SENT" | "NONE";
            /** @description Exclude non professional emails */
            excludeNonProfessionalEmails?: boolean;
            /** @description Exclude group emails */
            excludeGroupEmails?: boolean;
            /** @description Is Sync Enabled */
            isSyncEnabled?: boolean;
            /** @description Last sync cursor */
            syncCursor?: string;
            /**
             * Format: date-time
             * @description Last sync date
             */
            syncedAt?: string;
            /**
             * @description Sync status
             * @enum {string}
             */
            syncStatus?: "ONGOING" | "NOT_SYNCED" | "ACTIVE" | "FAILED_INSUFFICIENT_PERMISSIONS" | "FAILED_UNKNOWN";
            /**
             * @description Sync stage
             * @enum {string}
             */
            syncStage?: "MESSAGE_LIST_FETCH_PENDING" | "MESSAGE_LIST_FETCH_SCHEDULED" | "MESSAGE_LIST_FETCH_ONGOING" | "MESSAGES_IMPORT_PENDING" | "MESSAGES_IMPORT_SCHEDULED" | "MESSAGES_IMPORT_ONGOING" | "FAILED" | "FULL_MESSAGE_LIST_FETCH_PENDING" | "PARTIAL_MESSAGE_LIST_FETCH_PENDING";
            /**
             * Format: date-time
             * @description Sync stage started at
             */
            syncStageStartedAt?: string;
            /** @description Throttle Failure Count */
            throttleFailureCount?: number;
            /** Format: uuid */
            connectedAccountId?: string;
        };
        /**
         * @description Message Channels
         * @example {
         *       "visibility": [
         *         "METADATA"
         *       ],
         *       "type": [
         *         "email"
         *       ],
         *       "contactAutoCreationPolicy": [
         *         "SENT_AND_RECEIVED"
         *       ],
         *       "syncStatus": [
         *         "ONGOING"
         *       ],
         *       "syncStage": [
         *         "MESSAGE_LIST_FETCH_PENDING"
         *       ]
         *     }
         */
        MessageChannelForUpdate: {
            /**
             * @description Visibility
             * @enum {string}
             */
            visibility?: "METADATA" | "SUBJECT" | "SHARE_EVERYTHING";
            /** @description Handle */
            handle?: string;
            /**
             * @description Channel Type
             * @enum {string}
             */
            type?: "email" | "sms";
            /** @description Is Contact Auto Creation Enabled */
            isContactAutoCreationEnabled?: boolean;
            /**
             * @description Automatically create People records when receiving or sending emails
             * @enum {string}
             */
            contactAutoCreationPolicy?: "SENT_AND_RECEIVED" | "SENT" | "NONE";
            /** @description Exclude non professional emails */
            excludeNonProfessionalEmails?: boolean;
            /** @description Exclude group emails */
            excludeGroupEmails?: boolean;
            /** @description Is Sync Enabled */
            isSyncEnabled?: boolean;
            /** @description Last sync cursor */
            syncCursor?: string;
            /**
             * Format: date-time
             * @description Last sync date
             */
            syncedAt?: string;
            /**
             * @description Sync status
             * @enum {string}
             */
            syncStatus?: "ONGOING" | "NOT_SYNCED" | "ACTIVE" | "FAILED_INSUFFICIENT_PERMISSIONS" | "FAILED_UNKNOWN";
            /**
             * @description Sync stage
             * @enum {string}
             */
            syncStage?: "MESSAGE_LIST_FETCH_PENDING" | "MESSAGE_LIST_FETCH_SCHEDULED" | "MESSAGE_LIST_FETCH_ONGOING" | "MESSAGES_IMPORT_PENDING" | "MESSAGES_IMPORT_SCHEDULED" | "MESSAGES_IMPORT_ONGOING" | "FAILED" | "FULL_MESSAGE_LIST_FETCH_PENDING" | "PARTIAL_MESSAGE_LIST_FETCH_PENDING";
            /**
             * Format: date-time
             * @description Sync stage started at
             */
            syncStageStartedAt?: string;
            /** @description Throttle Failure Count */
            throttleFailureCount?: number;
            /** Format: uuid */
            connectedAccountId?: string;
        };
        /** @description Message Channels */
        MessageChannelForResponse: {
            /**
             * Format: date-time
             * @description Creation date
             */
            createdAt?: string;
            /**
             * @description Visibility
             * @enum {string}
             */
            visibility?: "METADATA" | "SUBJECT" | "SHARE_EVERYTHING";
            /** @description Handle */
            handle?: string;
            /**
             * @description Channel Type
             * @enum {string}
             */
            type?: "email" | "sms";
            /** @description Is Contact Auto Creation Enabled */
            isContactAutoCreationEnabled?: boolean;
            /**
             * @description Automatically create People records when receiving or sending emails
             * @enum {string}
             */
            contactAutoCreationPolicy?: "SENT_AND_RECEIVED" | "SENT" | "NONE";
            /** @description Exclude non professional emails */
            excludeNonProfessionalEmails?: boolean;
            /** @description Exclude group emails */
            excludeGroupEmails?: boolean;
            /** @description Is Sync Enabled */
            isSyncEnabled?: boolean;
            /** @description Last sync cursor */
            syncCursor?: string;
            /**
             * Format: date-time
             * @description Last sync date
             */
            syncedAt?: string;
            /**
             * @description Sync status
             * @enum {string}
             */
            syncStatus?: "ONGOING" | "NOT_SYNCED" | "ACTIVE" | "FAILED_INSUFFICIENT_PERMISSIONS" | "FAILED_UNKNOWN";
            /**
             * @description Sync stage
             * @enum {string}
             */
            syncStage?: "MESSAGE_LIST_FETCH_PENDING" | "MESSAGE_LIST_FETCH_SCHEDULED" | "MESSAGE_LIST_FETCH_ONGOING" | "MESSAGES_IMPORT_PENDING" | "MESSAGES_IMPORT_SCHEDULED" | "MESSAGES_IMPORT_ONGOING" | "FAILED" | "FULL_MESSAGE_LIST_FETCH_PENDING" | "PARTIAL_MESSAGE_LIST_FETCH_PENDING";
            /**
             * Format: date-time
             * @description Sync stage started at
             */
            syncStageStartedAt?: string;
            /** @description Throttle Failure Count */
            throttleFailureCount?: number;
            /**
             * Format: uuid
             * @description Id
             */
            id?: string;
            /**
             * Format: date-time
             * @description Last time the record was changed
             */
            updatedAt?: string;
            /**
             * Format: date-time
             * @description Date when the record was deleted
             */
            deletedAt?: string;
            /** Format: uuid */
            connectedAccountId?: string;
            /** @description Connected Account */
            connectedAccount?: components["schemas"]["ConnectedAccountForResponse"];
            /** @description Messages from the channel. */
            messageChannelMessageAssociations?: components["schemas"]["MessageChannelMessageAssociationForResponse"][];
            /** @description Message Folders */
            messageFolders?: components["schemas"]["MessageFolderForResponse"][];
        };
        /**
         * @description Folder for Message Channel
         * @example {
         *       "name": "Message Folder name"
         *     }
         */
        MessageFolder: {
            /** @description Folder name */
            name?: string;
            /** Format: uuid */
            messageChannelId?: string;
            /** @description External ID */
            externalId?: string;
            /** @description Is Synced */
            isSynced?: boolean;
            /** @description Is Sent Folder */
            isSentFolder?: boolean;
            /** @description Sync Cursor */
            syncCursor?: string;
        };
        /**
         * @description Folder for Message Channel
         * @example {
         *       "name": "Message Folder name"
         *     }
         */
        MessageFolderForUpdate: {
            /** @description Folder name */
            name?: string;
            /** Format: uuid */
            messageChannelId?: string;
            /** @description External ID */
            externalId?: string;
            /** @description Is Synced */
            isSynced?: boolean;
            /** @description Is Sent Folder */
            isSentFolder?: boolean;
            /** @description Sync Cursor */
            syncCursor?: string;
        };
        /** @description Folder for Message Channel */
        MessageFolderForResponse: {
            /** @description Folder name */
            name?: string;
            /** Format: uuid */
            messageChannelId?: string;
            /**
             * Format: date-time
             * @description Date when the record was deleted
             */
            deletedAt?: string;
            /**
             * Format: date-time
             * @description Last time the record was changed
             */
            updatedAt?: string;
            /**
             * Format: date-time
             * @description Creation date
             */
            createdAt?: string;
            /**
             * Format: uuid
             * @description Id
             */
            id?: string;
            /** @description External ID */
            externalId?: string;
            /** @description Is Synced */
            isSynced?: boolean;
            /** @description Is Sent Folder */
            isSentFolder?: boolean;
            /** @description Sync Cursor */
            syncCursor?: string;
            /** @description Message Channel */
            messageChannel?: components["schemas"]["MessageChannelForResponse"];
        };
        /**
         * @description Message Participants
         * @example {
         *       "role": [
         *         "from"
         *       ]
         *     }
         */
        MessageParticipant: {
            /** Format: uuid */
            workspaceMemberId?: string;
            /** Format: uuid */
            personId?: string;
            /** Format: uuid */
            messageId?: string;
            /** @description Display Name */
            displayName?: string;
            /** @description Handle */
            handle?: string;
            /**
             * @description Role
             * @enum {string}
             */
            role?: "from" | "to" | "cc" | "bcc";
        };
        /**
         * @description Message Participants
         * @example {
         *       "role": [
         *         "from"
         *       ]
         *     }
         */
        MessageParticipantForUpdate: {
            /** Format: uuid */
            workspaceMemberId?: string;
            /** Format: uuid */
            personId?: string;
            /** Format: uuid */
            messageId?: string;
            /** @description Display Name */
            displayName?: string;
            /** @description Handle */
            handle?: string;
            /**
             * @description Role
             * @enum {string}
             */
            role?: "from" | "to" | "cc" | "bcc";
        };
        /** @description Message Participants */
        MessageParticipantForResponse: {
            /**
             * Format: date-time
             * @description Last time the record was changed
             */
            updatedAt?: string;
            /** Format: uuid */
            workspaceMemberId?: string;
            /** Format: uuid */
            personId?: string;
            /** Format: uuid */
            messageId?: string;
            /**
             * Format: date-time
             * @description Date when the record was deleted
             */
            deletedAt?: string;
            /**
             * Format: date-time
             * @description Creation date
             */
            createdAt?: string;
            /**
             * Format: uuid
             * @description Id
             */
            id?: string;
            /** @description Display Name */
            displayName?: string;
            /** @description Handle */
            handle?: string;
            /**
             * @description Role
             * @enum {string}
             */
            role?: "from" | "to" | "cc" | "bcc";
            /** @description Workspace member */
            workspaceMember?: components["schemas"]["WorkspaceMemberForResponse"];
            /** @description Person */
            person?: components["schemas"]["PersonForResponse"];
            /** @description Message */
            message?: components["schemas"]["MessageForResponse"];
        };
        /**
         * @description A message sent or received through a messaging channel (email, chat, etc.)
         * @example {}
         */
        Message: {
            /** @description Message id from the message header */
            headerMessageId?: string;
            /** @description Subject */
            subject?: string;
            /** @description Text */
            text?: string;
            /**
             * Format: date-time
             * @description The date the message was received
             */
            receivedAt?: string;
            /** Format: uuid */
            messageThreadId?: string;
        };
        /**
         * @description A message sent or received through a messaging channel (email, chat, etc.)
         * @example {}
         */
        MessageForUpdate: {
            /** @description Message id from the message header */
            headerMessageId?: string;
            /** @description Subject */
            subject?: string;
            /** @description Text */
            text?: string;
            /**
             * Format: date-time
             * @description The date the message was received
             */
            receivedAt?: string;
            /** Format: uuid */
            messageThreadId?: string;
        };
        /** @description A message sent or received through a messaging channel (email, chat, etc.) */
        MessageForResponse: {
            /** @description Message id from the message header */
            headerMessageId?: string;
            /** @description Subject */
            subject?: string;
            /** @description Text */
            text?: string;
            /**
             * Format: date-time
             * @description The date the message was received
             */
            receivedAt?: string;
            /**
             * Format: uuid
             * @description Id
             */
            id?: string;
            /**
             * Format: date-time
             * @description Creation date
             */
            createdAt?: string;
            /**
             * Format: date-time
             * @description Last time the record was changed
             */
            updatedAt?: string;
            /**
             * Format: date-time
             * @description Date when the record was deleted
             */
            deletedAt?: string;
            /** Format: uuid */
            messageThreadId?: string;
            /** @description Messages from the channel. */
            messageChannelMessageAssociations?: components["schemas"]["MessageChannelMessageAssociationForResponse"][];
            /** @description Message Thread Id */
            messageThread?: components["schemas"]["MessageThreadForResponse"];
            /** @description Message Participants */
            messageParticipants?: components["schemas"]["MessageParticipantForResponse"][];
        };
        /**
         * @description A group of related messages (e.g. email thread, chat thread)
         * @example {}
         */
        MessageThread: Record<string, never>;
        /**
         * @description A group of related messages (e.g. email thread, chat thread)
         * @example {}
         */
        MessageThreadForUpdate: Record<string, never>;
        /** @description A group of related messages (e.g. email thread, chat thread) */
        MessageThreadForResponse: {
            /**
             * Format: date-time
             * @description Creation date
             */
            createdAt?: string;
            /**
             * Format: uuid
             * @description Id
             */
            id?: string;
            /**
             * Format: date-time
             * @description Date when the record was deleted
             */
            deletedAt?: string;
            /**
             * Format: date-time
             * @description Last time the record was changed
             */
            updatedAt?: string;
            /** @description Messages from the thread. */
            messages?: components["schemas"]["MessageForResponse"][];
        };
        /**
         * @description A note
         * @example {}
         */
        Note: {
            /** @description The creator of the record */
            createdBy?: {
                /** @enum {string} */
                source?: "EMAIL" | "CALENDAR" | "WORKFLOW" | "API" | "IMPORT" | "MANUAL" | "SYSTEM" | "WEBHOOK";
            };
            /** @description Note body */
            bodyV2?: {
                blocknote?: string;
                markdown?: string;
            };
            /** @description Note record position */
            position?: number;
            /** @description Note title */
            title?: string;
        };
        /**
         * @description A note
         * @example {}
         */
        NoteForUpdate: {
            /** @description The creator of the record */
            createdBy?: {
                /** @enum {string} */
                source?: "EMAIL" | "CALENDAR" | "WORKFLOW" | "API" | "IMPORT" | "MANUAL" | "SYSTEM" | "WEBHOOK";
            };
            /** @description Note body */
            bodyV2?: {
                blocknote?: string;
                markdown?: string;
            };
            /** @description Note record position */
            position?: number;
            /** @description Note title */
            title?: string;
        };
        /** @description A note */
        NoteForResponse: {
            /** @description The creator of the record */
            createdBy?: {
                /** @enum {string} */
                source?: "EMAIL" | "CALENDAR" | "WORKFLOW" | "API" | "IMPORT" | "MANUAL" | "SYSTEM" | "WEBHOOK";
                /** Format: uuid */
                workspaceMemberId?: string;
                name?: string;
            };
            /** @description Note body */
            bodyV2?: {
                blocknote?: string;
                markdown?: string;
            };
            /** @description Note record position */
            position?: number;
            /** @description Note title */
            title?: string;
            /**
             * Format: date-time
             * @description Date when the record was deleted
             */
            deletedAt?: string;
            /**
             * Format: date-time
             * @description Last time the record was changed
             */
            updatedAt?: string;
            /**
             * Format: date-time
             * @description Creation date
             */
            createdAt?: string;
            /**
             * Format: uuid
             * @description Id
             */
            id?: string;
            /** @description Favorites linked to the note */
            favorites?: components["schemas"]["FavoriteForResponse"][];
            /** @description Timeline Activities linked to the note. */
            timelineActivities?: components["schemas"]["TimelineActivityForResponse"][];
            /** @description Note attachments */
            attachments?: components["schemas"]["AttachmentForResponse"][];
            /** @description Note targets */
            noteTargets?: components["schemas"]["NoteTargetForResponse"][];
        };
        /**
         * @description A note target
         * @example {}
         */
        NoteTarget: {
            /** Format: uuid */
            noteId?: string;
            /** Format: uuid */
            personId?: string;
            /** Format: uuid */
            companyId?: string;
            /** Format: uuid */
            opportunityId?: string;
        };
        /**
         * @description A note target
         * @example {}
         */
        NoteTargetForUpdate: {
            /** Format: uuid */
            noteId?: string;
            /** Format: uuid */
            personId?: string;
            /** Format: uuid */
            companyId?: string;
            /** Format: uuid */
            opportunityId?: string;
        };
        /** @description A note target */
        NoteTargetForResponse: {
            /**
             * Format: date-time
             * @description Last time the record was changed
             */
            updatedAt?: string;
            /** Format: uuid */
            noteId?: string;
            /** Format: uuid */
            personId?: string;
            /** Format: uuid */
            companyId?: string;
            /** Format: uuid */
            opportunityId?: string;
            /**
             * Format: uuid
             * @description Id
             */
            id?: string;
            /**
             * Format: date-time
             * @description Creation date
             */
            createdAt?: string;
            /**
             * Format: date-time
             * @description Date when the record was deleted
             */
            deletedAt?: string;
            /** @description NoteTarget note */
            note?: components["schemas"]["NoteForResponse"];
            /** @description NoteTarget person */
            person?: components["schemas"]["PersonForResponse"];
            /** @description NoteTarget company */
            company?: components["schemas"]["CompanyForResponse"];
            /** @description NoteTarget opportunity */
            opportunity?: components["schemas"]["OpportunityForResponse"];
        };
        /**
         * @description An opportunity
         * @example {
         *       "name": "Opportunity name",
         *       "amount": {
         *         "amountMicros": 893000000,
         *         "currencyCode": "EUR"
         *       },
         *       "stage": [
         *         "NEW"
         *       ]
         *     }
         */
        Opportunity: {
            /** @description The opportunity name */
            name?: string;
            /** @description Opportunity amount */
            amount?: {
                amountMicros?: number;
                currencyCode?: string;
            };
            /**
             * Format: date-time
             * @description Opportunity close date
             */
            closeDate?: string;
            /**
             * @description Opportunity stage
             * @enum {string}
             */
            stage?: "NEW" | "SCREENING" | "MEETING" | "PROPOSAL" | "CUSTOMER";
            /** @description Opportunity record position */
            position?: number;
            /** @description The creator of the record */
            createdBy?: {
                /** @enum {string} */
                source?: "EMAIL" | "CALENDAR" | "WORKFLOW" | "API" | "IMPORT" | "MANUAL" | "SYSTEM" | "WEBHOOK";
            };
            /** Format: uuid */
            pointOfContactId?: string;
            /** Format: uuid */
            companyId?: string;
        };
        /**
         * @description An opportunity
         * @example {
         *       "name": "Opportunity name",
         *       "amount": {
         *         "amountMicros": 249000000,
         *         "currencyCode": "EUR"
         *       },
         *       "stage": [
         *         "NEW"
         *       ]
         *     }
         */
        OpportunityForUpdate: {
            /** @description The opportunity name */
            name?: string;
            /** @description Opportunity amount */
            amount?: {
                amountMicros?: number;
                currencyCode?: string;
            };
            /**
             * Format: date-time
             * @description Opportunity close date
             */
            closeDate?: string;
            /**
             * @description Opportunity stage
             * @enum {string}
             */
            stage?: "NEW" | "SCREENING" | "MEETING" | "PROPOSAL" | "CUSTOMER";
            /** @description Opportunity record position */
            position?: number;
            /** @description The creator of the record */
            createdBy?: {
                /** @enum {string} */
                source?: "EMAIL" | "CALENDAR" | "WORKFLOW" | "API" | "IMPORT" | "MANUAL" | "SYSTEM" | "WEBHOOK";
            };
            /** Format: uuid */
            pointOfContactId?: string;
            /** Format: uuid */
            companyId?: string;
        };
        /** @description An opportunity */
        OpportunityForResponse: {
            /**
             * Format: date-time
             * @description Last time the record was changed
             */
            updatedAt?: string;
            /** @description The opportunity name */
            name?: string;
            /** @description Opportunity amount */
            amount?: {
                amountMicros?: number;
                currencyCode?: string;
            };
            /**
             * Format: date-time
             * @description Opportunity close date
             */
            closeDate?: string;
            /**
             * @description Opportunity stage
             * @enum {string}
             */
            stage?: "NEW" | "SCREENING" | "MEETING" | "PROPOSAL" | "CUSTOMER";
            /** @description Opportunity record position */
            position?: number;
            /** @description The creator of the record */
            createdBy?: {
                /** @enum {string} */
                source?: "EMAIL" | "CALENDAR" | "WORKFLOW" | "API" | "IMPORT" | "MANUAL" | "SYSTEM" | "WEBHOOK";
                /** Format: uuid */
                workspaceMemberId?: string;
                name?: string;
            };
            /**
             * Format: uuid
             * @description Id
             */
            id?: string;
            /**
             * Format: date-time
             * @description Creation date
             */
            createdAt?: string;
            /**
             * Format: date-time
             * @description Date when the record was deleted
             */
            deletedAt?: string;
            /** Format: uuid */
            pointOfContactId?: string;
            /** Format: uuid */
            companyId?: string;
            /** @description Opportunity point of contact */
            pointOfContact?: components["schemas"]["PersonForResponse"];
            /** @description Opportunity company */
            company?: components["schemas"]["CompanyForResponse"];
            /** @description Favorites linked to the opportunity */
            favorites?: components["schemas"]["FavoriteForResponse"][];
            /** @description Tasks tied to the opportunity */
            taskTargets?: components["schemas"]["TaskTargetForResponse"][];
            /** @description Notes tied to the opportunity */
            noteTargets?: components["schemas"]["NoteTargetForResponse"][];
            /** @description Attachments linked to the opportunity */
            attachments?: components["schemas"]["AttachmentForResponse"][];
            /** @description Timeline Activities linked to the opportunity. */
            timelineActivities?: components["schemas"]["TimelineActivityForResponse"][];
        };
        /**
         * @description A person
         * @example {
         *       "phones": {
         *         "primaryPhoneNumber": "06 10 20 30 40",
         *         "primaryPhoneCallingCode": "+33",
         *         "primaryPhoneCountryCode": "FR",
         *         "additionalPhones": []
         *       },
         *       "xLink": {
         *         "primaryLinkLabel": "",
         *         "primaryLinkUrl": "https://sure-footed-brochure.com",
         *         "additionalLinks": []
         *       },
         *       "linkedinLink": {
         *         "primaryLinkLabel": "",
         *         "primaryLinkUrl": "https://harmful-junior.biz/",
         *         "additionalLinks": []
         *       },
         *       "emails": {
         *         "primaryEmail": "tyler_dicki@hotmail.com",
         *         "additionalEmails": null
         *       },
         *       "name": {
         *         "firstName": "Sister",
         *         "lastName": "Langworth"
         *       }
         *     }
         */
        Person: {
            /** @description Contact’s avatar */
            avatarUrl?: string;
            /** @description Contact’s city */
            city?: string;
            /** @description Contact’s phone numbers */
            phones?: {
                additionalPhones?: string[];
                primaryPhoneCountryCode?: string;
                primaryPhoneCallingCode?: string;
                primaryPhoneNumber?: string;
            };
            /** @description Contact’s job title */
            jobTitle?: string;
            /** @description Contact’s X/Twitter account */
            xLink?: {
                primaryLinkLabel?: string;
                primaryLinkUrl?: string;
                secondaryLinks?: {
                    /** Format: uri */
                    url?: string;
                    label?: string;
                }[];
            };
            /** @description Contact’s Linkedin account */
            linkedinLink?: {
                primaryLinkLabel?: string;
                primaryLinkUrl?: string;
                secondaryLinks?: {
                    /** Format: uri */
                    url?: string;
                    label?: string;
                }[];
            };
            /** @description Contact’s Emails */
            emails?: {
                primaryEmail?: string;
                additionalEmails?: string[];
            };
            /** @description Contact’s name */
            name?: {
                firstName?: string;
                lastName?: string;
            };
            /** Format: uuid */
            companyId?: string;
            /** @description The creator of the record */
            createdBy?: {
                /** @enum {string} */
                source?: "EMAIL" | "CALENDAR" | "WORKFLOW" | "API" | "IMPORT" | "MANUAL" | "SYSTEM" | "WEBHOOK";
            };
            /** @description Person record Position */
            position?: number;
        };
        /**
         * @description A person
         * @example {
         *       "phones": {
         *         "primaryPhoneNumber": "06 10 20 30 40",
         *         "primaryPhoneCallingCode": "+33",
         *         "primaryPhoneCountryCode": "FR",
         *         "additionalPhones": []
         *       },
         *       "xLink": {
         *         "primaryLinkLabel": "",
         *         "primaryLinkUrl": "https://profuse-angle.name/",
         *         "additionalLinks": []
         *       },
         *       "linkedinLink": {
         *         "primaryLinkLabel": "",
         *         "primaryLinkUrl": "https://meaty-shore.com/",
         *         "additionalLinks": []
         *       },
         *       "emails": {
         *         "primaryEmail": "lexus.herzog@yahoo.com",
         *         "additionalEmails": null
         *       },
         *       "name": {
         *         "firstName": "Branson",
         *         "lastName": "Harvey"
         *       }
         *     }
         */
        PersonForUpdate: {
            /** @description Contact’s avatar */
            avatarUrl?: string;
            /** @description Contact’s city */
            city?: string;
            /** @description Contact’s phone numbers */
            phones?: {
                additionalPhones?: string[];
                primaryPhoneCountryCode?: string;
                primaryPhoneCallingCode?: string;
                primaryPhoneNumber?: string;
            };
            /** @description Contact’s job title */
            jobTitle?: string;
            /** @description Contact’s X/Twitter account */
            xLink?: {
                primaryLinkLabel?: string;
                primaryLinkUrl?: string;
                secondaryLinks?: {
                    /** Format: uri */
                    url?: string;
                    label?: string;
                }[];
            };
            /** @description Contact’s Linkedin account */
            linkedinLink?: {
                primaryLinkLabel?: string;
                primaryLinkUrl?: string;
                secondaryLinks?: {
                    /** Format: uri */
                    url?: string;
                    label?: string;
                }[];
            };
            /** @description Contact’s Emails */
            emails?: {
                primaryEmail?: string;
                additionalEmails?: string[];
            };
            /** @description Contact’s name */
            name?: {
                firstName?: string;
                lastName?: string;
            };
            /** Format: uuid */
            companyId?: string;
            /** @description The creator of the record */
            createdBy?: {
                /** @enum {string} */
                source?: "EMAIL" | "CALENDAR" | "WORKFLOW" | "API" | "IMPORT" | "MANUAL" | "SYSTEM" | "WEBHOOK";
            };
            /** @description Person record Position */
            position?: number;
        };
        /** @description A person */
        PersonForResponse: {
            /** @description Contact’s avatar */
            avatarUrl?: string;
            /** @description Contact’s city */
            city?: string;
            /** @description Contact’s phone numbers */
            phones?: {
                additionalPhones?: string[];
                primaryPhoneCountryCode?: string;
                primaryPhoneCallingCode?: string;
                primaryPhoneNumber?: string;
            };
            /** @description Contact’s job title */
            jobTitle?: string;
            /** @description Contact’s X/Twitter account */
            xLink?: {
                primaryLinkLabel?: string;
                primaryLinkUrl?: string;
                secondaryLinks?: {
                    /** Format: uri */
                    url?: string;
                    label?: string;
                }[];
            };
            /** @description Contact’s Linkedin account */
            linkedinLink?: {
                primaryLinkLabel?: string;
                primaryLinkUrl?: string;
                secondaryLinks?: {
                    /** Format: uri */
                    url?: string;
                    label?: string;
                }[];
            };
            /** @description Contact’s Emails */
            emails?: {
                primaryEmail?: string;
                additionalEmails?: string[];
            };
            /** @description Contact’s name */
            name?: {
                firstName?: string;
                lastName?: string;
            };
            /** Format: uuid */
            companyId?: string;
            /**
             * Format: date-time
             * @description Date when the record was deleted
             */
            deletedAt?: string;
            /**
             * Format: date-time
             * @description Last time the record was changed
             */
            updatedAt?: string;
            /**
             * Format: date-time
             * @description Creation date
             */
            createdAt?: string;
            /**
             * Format: uuid
             * @description Id
             */
            id?: string;
            /** @description The creator of the record */
            createdBy?: {
                /** @enum {string} */
                source?: "EMAIL" | "CALENDAR" | "WORKFLOW" | "API" | "IMPORT" | "MANUAL" | "SYSTEM" | "WEBHOOK";
                /** Format: uuid */
                workspaceMemberId?: string;
                name?: string;
            };
            /** @description Person record Position */
            position?: number;
            /** @description Events linked to the person */
            timelineActivities?: components["schemas"]["TimelineActivityForResponse"][];
            /** @description Calendar Event Participants */
            calendarEventParticipants?: components["schemas"]["CalendarEventParticipantForResponse"][];
            /** @description Message Participants */
            messageParticipants?: components["schemas"]["MessageParticipantForResponse"][];
            /** @description Attachments linked to the contact. */
            attachments?: components["schemas"]["AttachmentForResponse"][];
            /** @description Favorites linked to the contact */
            favorites?: components["schemas"]["FavoriteForResponse"][];
            /** @description Notes tied to the contact */
            noteTargets?: components["schemas"]["NoteTargetForResponse"][];
            /** @description Tasks tied to the contact */
            taskTargets?: components["schemas"]["TaskTargetForResponse"][];
            /** @description List of opportunities for which that person is the point of contact */
            pointOfContactForOpportunities?: components["schemas"]["OpportunityForResponse"][];
            /** @description Contact’s company */
            company?: components["schemas"]["CompanyForResponse"];
        };
        /**
         * @description A task
         * @example {
         *       "status": [
         *         "TODO"
         *       ]
         *     }
         */
        Task: {
            /** @description Task record position */
            position?: number;
            /** Format: uuid */
            assigneeId?: string;
            /** @description The creator of the record */
            createdBy?: {
                /** @enum {string} */
                source?: "EMAIL" | "CALENDAR" | "WORKFLOW" | "API" | "IMPORT" | "MANUAL" | "SYSTEM" | "WEBHOOK";
            };
            /**
             * @description Task status
             * @enum {string}
             */
            status?: "TODO" | "IN_PROGRESS" | "DONE";
            /**
             * Format: date-time
             * @description Task due date
             */
            dueAt?: string;
            /** @description Task body */
            bodyV2?: {
                blocknote?: string;
                markdown?: string;
            };
            /** @description Task title */
            title?: string;
        };
        /**
         * @description A task
         * @example {
         *       "status": [
         *         "TODO"
         *       ]
         *     }
         */
        TaskForUpdate: {
            /** @description Task record position */
            position?: number;
            /** Format: uuid */
            assigneeId?: string;
            /** @description The creator of the record */
            createdBy?: {
                /** @enum {string} */
                source?: "EMAIL" | "CALENDAR" | "WORKFLOW" | "API" | "IMPORT" | "MANUAL" | "SYSTEM" | "WEBHOOK";
            };
            /**
             * @description Task status
             * @enum {string}
             */
            status?: "TODO" | "IN_PROGRESS" | "DONE";
            /**
             * Format: date-time
             * @description Task due date
             */
            dueAt?: string;
            /** @description Task body */
            bodyV2?: {
                blocknote?: string;
                markdown?: string;
            };
            /** @description Task title */
            title?: string;
        };
        /** @description A task */
        TaskForResponse: {
            /** @description Task record position */
            position?: number;
            /** Format: uuid */
            assigneeId?: string;
            /**
             * Format: date-time
             * @description Date when the record was deleted
             */
            deletedAt?: string;
            /**
             * Format: date-time
             * @description Last time the record was changed
             */
            updatedAt?: string;
            /**
             * Format: uuid
             * @description Id
             */
            id?: string;
            /** @description The creator of the record */
            createdBy?: {
                /** @enum {string} */
                source?: "EMAIL" | "CALENDAR" | "WORKFLOW" | "API" | "IMPORT" | "MANUAL" | "SYSTEM" | "WEBHOOK";
                /** Format: uuid */
                workspaceMemberId?: string;
                name?: string;
            };
            /**
             * @description Task status
             * @enum {string}
             */
            status?: "TODO" | "IN_PROGRESS" | "DONE";
            /**
             * Format: date-time
             * @description Task due date
             */
            dueAt?: string;
            /** @description Task body */
            bodyV2?: {
                blocknote?: string;
                markdown?: string;
            };
            /** @description Task title */
            title?: string;
            /**
             * Format: date-time
             * @description Creation date
             */
            createdAt?: string;
            /** @description Favorites linked to the task */
            favorites?: components["schemas"]["FavoriteForResponse"][];
            /** @description Timeline Activities linked to the task. */
            timelineActivities?: components["schemas"]["TimelineActivityForResponse"][];
            /** @description Task assignee */
            assignee?: components["schemas"]["WorkspaceMemberForResponse"];
            /** @description Task attachments */
            attachments?: components["schemas"]["AttachmentForResponse"][];
            /** @description Task targets */
            taskTargets?: components["schemas"]["TaskTargetForResponse"][];
        };
        /**
         * @description A task target
         * @example {}
         */
        TaskTarget: {
            /** Format: uuid */
            opportunityId?: string;
            /** Format: uuid */
            companyId?: string;
            /** Format: uuid */
            personId?: string;
            /** Format: uuid */
            taskId?: string;
        };
        /**
         * @description A task target
         * @example {}
         */
        TaskTargetForUpdate: {
            /** Format: uuid */
            opportunityId?: string;
            /** Format: uuid */
            companyId?: string;
            /** Format: uuid */
            personId?: string;
            /** Format: uuid */
            taskId?: string;
        };
        /** @description A task target */
        TaskTargetForResponse: {
            /** Format: uuid */
            opportunityId?: string;
            /** Format: uuid */
            companyId?: string;
            /** Format: uuid */
            personId?: string;
            /** Format: uuid */
            taskId?: string;
            /**
             * Format: date-time
             * @description Date when the record was deleted
             */
            deletedAt?: string;
            /**
             * Format: date-time
             * @description Last time the record was changed
             */
            updatedAt?: string;
            /**
             * Format: date-time
             * @description Creation date
             */
            createdAt?: string;
            /**
             * Format: uuid
             * @description Id
             */
            id?: string;
            /** @description TaskTarget opportunity */
            opportunity?: components["schemas"]["OpportunityForResponse"];
            /** @description TaskTarget company */
            company?: components["schemas"]["CompanyForResponse"];
            /** @description TaskTarget person */
            person?: components["schemas"]["PersonForResponse"];
            /** @description TaskTarget task */
            task?: components["schemas"]["TaskForResponse"];
        };
        /**
         * @description Aggregated / filtered event to be displayed on the timeline
         * @example {
         *       "name": "Timeline Activity name"
         *     }
         */
        TimelineActivity: {
            /**
             * Format: date-time
             * @description Creation date
             */
            happensAt?: string;
            /** @description Event name */
            name?: string;
            /** @description Json value for event details */
            properties?: Record<string, never>;
            /** @description Cached record name */
            linkedRecordCachedName?: string;
            /**
             * Format: uuid
             * @description Linked Record id
             */
            linkedRecordId?: string;
            /**
             * Format: uuid
             * @description Linked Object Metadata Id
             */
            linkedObjectMetadataId?: string;
            /** Format: uuid */
            workspaceMemberId?: string;
            /** Format: uuid */
            personId?: string;
            /** Format: uuid */
            companyId?: string;
            /** Format: uuid */
            opportunityId?: string;
            /** Format: uuid */
            noteId?: string;
            /** Format: uuid */
            taskId?: string;
            /** Format: uuid */
            workflowId?: string;
            /** Format: uuid */
            workflowVersionId?: string;
            /** Format: uuid */
            workflowRunId?: string;
        };
        /**
         * @description Aggregated / filtered event to be displayed on the timeline
         * @example {
         *       "name": "Timeline Activity name"
         *     }
         */
        TimelineActivityForUpdate: {
            /**
             * Format: date-time
             * @description Creation date
             */
            happensAt?: string;
            /** @description Event name */
            name?: string;
            /** @description Json value for event details */
            properties?: Record<string, never>;
            /** @description Cached record name */
            linkedRecordCachedName?: string;
            /**
             * Format: uuid
             * @description Linked Record id
             */
            linkedRecordId?: string;
            /**
             * Format: uuid
             * @description Linked Object Metadata Id
             */
            linkedObjectMetadataId?: string;
            /** Format: uuid */
            workspaceMemberId?: string;
            /** Format: uuid */
            personId?: string;
            /** Format: uuid */
            companyId?: string;
            /** Format: uuid */
            opportunityId?: string;
            /** Format: uuid */
            noteId?: string;
            /** Format: uuid */
            taskId?: string;
            /** Format: uuid */
            workflowId?: string;
            /** Format: uuid */
            workflowVersionId?: string;
            /** Format: uuid */
            workflowRunId?: string;
        };
        /** @description Aggregated / filtered event to be displayed on the timeline */
        TimelineActivityForResponse: {
            /**
             * Format: date-time
             * @description Creation date
             */
            happensAt?: string;
            /** @description Event name */
            name?: string;
            /** @description Json value for event details */
            properties?: Record<string, never>;
            /** @description Cached record name */
            linkedRecordCachedName?: string;
            /**
             * Format: uuid
             * @description Linked Record id
             */
            linkedRecordId?: string;
            /**
             * Format: uuid
             * @description Linked Object Metadata Id
             */
            linkedObjectMetadataId?: string;
            /**
             * Format: uuid
             * @description Id
             */
            id?: string;
            /**
             * Format: date-time
             * @description Creation date
             */
            createdAt?: string;
            /**
             * Format: date-time
             * @description Last time the record was changed
             */
            updatedAt?: string;
            /**
             * Format: date-time
             * @description Date when the record was deleted
             */
            deletedAt?: string;
            /** Format: uuid */
            workspaceMemberId?: string;
            /** Format: uuid */
            personId?: string;
            /** Format: uuid */
            companyId?: string;
            /** Format: uuid */
            opportunityId?: string;
            /** Format: uuid */
            noteId?: string;
            /** Format: uuid */
            taskId?: string;
            /** Format: uuid */
            workflowId?: string;
            /** Format: uuid */
            workflowVersionId?: string;
            /** Format: uuid */
            workflowRunId?: string;
            /** @description Event workspace member */
            workspaceMember?: components["schemas"]["WorkspaceMemberForResponse"];
            /** @description Event person */
            person?: components["schemas"]["PersonForResponse"];
            /** @description Event company */
            company?: components["schemas"]["CompanyForResponse"];
            /** @description Event opportunity */
            opportunity?: components["schemas"]["OpportunityForResponse"];
            /** @description Event note */
            note?: components["schemas"]["NoteForResponse"];
            /** @description Event task */
            task?: components["schemas"]["TaskForResponse"];
            /** @description Event workflow */
            workflow?: components["schemas"]["WorkflowForResponse"];
            /** @description Event workflow version */
            workflowVersion?: components["schemas"]["WorkflowVersionForResponse"];
            /** @description Event workflow run */
            workflowRun?: components["schemas"]["WorkflowRunForResponse"];
        };
        /**
         * @description (System) View Fields
         * @example {
         *       "fieldMetadataId": "ce04671f-cd61-4596-903e-1919a22a2c8b",
         *       "aggregateOperation": [
         *         "AVG"
         *       ]
         *     }
         */
        ViewField: {
            /** Format: uuid */
            viewId?: string;
            /**
             * Format: uuid
             * @description View Field target field
             */
            fieldMetadataId: string;
            /** @description View Field visibility */
            isVisible?: boolean;
            /** @description View Field size */
            size?: number;
            /** @description View Field position */
            position?: number;
            /**
             * @description Optional aggregate operation
             * @enum {string}
             */
            aggregateOperation?: "AVG" | "COUNT" | "MAX" | "MIN" | "SUM" | "COUNT_EMPTY" | "COUNT_NOT_EMPTY" | "COUNT_UNIQUE_VALUES" | "PERCENTAGE_EMPTY" | "PERCENTAGE_NOT_EMPTY" | "COUNT_TRUE" | "COUNT_FALSE";
        };
        /**
         * @description (System) View Fields
         * @example {
         *       "fieldMetadataId": "ffd9ea45-a848-4593-89c0-a90f234e5e05",
         *       "aggregateOperation": [
         *         "AVG"
         *       ]
         *     }
         */
        ViewFieldForUpdate: {
            /** Format: uuid */
            viewId?: string;
            /**
             * Format: uuid
             * @description View Field target field
             */
            fieldMetadataId?: string;
            /** @description View Field visibility */
            isVisible?: boolean;
            /** @description View Field size */
            size?: number;
            /** @description View Field position */
            position?: number;
            /**
             * @description Optional aggregate operation
             * @enum {string}
             */
            aggregateOperation?: "AVG" | "COUNT" | "MAX" | "MIN" | "SUM" | "COUNT_EMPTY" | "COUNT_NOT_EMPTY" | "COUNT_UNIQUE_VALUES" | "PERCENTAGE_EMPTY" | "PERCENTAGE_NOT_EMPTY" | "COUNT_TRUE" | "COUNT_FALSE";
        };
        /** @description (System) View Fields */
        ViewFieldForResponse: {
            /**
             * Format: date-time
             * @description Date when the record was deleted
             */
            deletedAt?: string;
            /** Format: uuid */
            viewId?: string;
            /**
             * Format: uuid
             * @description View Field target field
             */
            fieldMetadataId?: string;
            /** @description View Field visibility */
            isVisible?: boolean;
            /** @description View Field size */
            size?: number;
            /** @description View Field position */
            position?: number;
            /**
             * @description Optional aggregate operation
             * @enum {string}
             */
            aggregateOperation?: "AVG" | "COUNT" | "MAX" | "MIN" | "SUM" | "COUNT_EMPTY" | "COUNT_NOT_EMPTY" | "COUNT_UNIQUE_VALUES" | "PERCENTAGE_EMPTY" | "PERCENTAGE_NOT_EMPTY" | "COUNT_TRUE" | "COUNT_FALSE";
            /**
             * Format: uuid
             * @description Id
             */
            id?: string;
            /**
             * Format: date-time
             * @description Creation date
             */
            createdAt?: string;
            /**
             * Format: date-time
             * @description Last time the record was changed
             */
            updatedAt?: string;
            /** @description View Field related view */
            view?: components["schemas"]["ViewForResponse"];
        };
        /**
         * @description (System) View Filter Groups
         * @example {
         *       "logicalOperator": [
         *         "AND"
         *       ]
         *     }
         */
        ViewFilterGroup: {
            /**
             * Format: uuid
             * @description Parent View Filter Group
             */
            parentViewFilterGroupId?: string;
            /**
             * @description Logical operator for the filter group
             * @enum {string}
             */
            logicalOperator?: "AND" | "OR" | "NOT";
            /** @description Position in the parent view filter group */
            positionInViewFilterGroup?: number;
            /** Format: uuid */
            viewId?: string;
        };
        /**
         * @description (System) View Filter Groups
         * @example {
         *       "logicalOperator": [
         *         "AND"
         *       ]
         *     }
         */
        ViewFilterGroupForUpdate: {
            /**
             * Format: uuid
             * @description Parent View Filter Group
             */
            parentViewFilterGroupId?: string;
            /**
             * @description Logical operator for the filter group
             * @enum {string}
             */
            logicalOperator?: "AND" | "OR" | "NOT";
            /** @description Position in the parent view filter group */
            positionInViewFilterGroup?: number;
            /** Format: uuid */
            viewId?: string;
        };
        /** @description (System) View Filter Groups */
        ViewFilterGroupForResponse: {
            /**
             * Format: date-time
             * @description Last time the record was changed
             */
            updatedAt?: string;
            /**
             * Format: date-time
             * @description Date when the record was deleted
             */
            deletedAt?: string;
            /**
             * Format: uuid
             * @description Parent View Filter Group
             */
            parentViewFilterGroupId?: string;
            /**
             * @description Logical operator for the filter group
             * @enum {string}
             */
            logicalOperator?: "AND" | "OR" | "NOT";
            /** @description Position in the parent view filter group */
            positionInViewFilterGroup?: number;
            /**
             * Format: uuid
             * @description Id
             */
            id?: string;
            /**
             * Format: date-time
             * @description Creation date
             */
            createdAt?: string;
            /** Format: uuid */
            viewId?: string;
            /** @description View */
            view?: components["schemas"]["ViewForResponse"];
        };
        /**
         * @description (System) View Filters
         * @example {
         *       "fieldMetadataId": "0ff9ea5a-928e-44a5-aabb-e118d02a67f0"
         *     }
         */
        ViewFilter: {
            /** @description View Filter Display Value */
            displayValue?: string;
            /** Format: uuid */
            viewId?: string;
            /** @description Sub field name */
            subFieldName?: string;
            /** @description Position in the view filter group */
            positionInViewFilterGroup?: number;
            /**
             * Format: uuid
             * @description View Filter Group
             */
            viewFilterGroupId?: string;
            /** @description View Filter value */
            value?: string;
            /** @description View Filter operand */
            operand?: string;
            /**
             * Format: uuid
             * @description View Filter target field
             */
            fieldMetadataId: string;
        };
        /**
         * @description (System) View Filters
         * @example {
         *       "fieldMetadataId": "78a0fdc7-0849-43fc-b957-67f57de2a3dd"
         *     }
         */
        ViewFilterForUpdate: {
            /** @description View Filter Display Value */
            displayValue?: string;
            /** Format: uuid */
            viewId?: string;
            /** @description Sub field name */
            subFieldName?: string;
            /** @description Position in the view filter group */
            positionInViewFilterGroup?: number;
            /**
             * Format: uuid
             * @description View Filter Group
             */
            viewFilterGroupId?: string;
            /** @description View Filter value */
            value?: string;
            /** @description View Filter operand */
            operand?: string;
            /**
             * Format: uuid
             * @description View Filter target field
             */
            fieldMetadataId?: string;
        };
        /** @description (System) View Filters */
        ViewFilterForResponse: {
            /** @description View Filter Display Value */
            displayValue?: string;
            /** Format: uuid */
            viewId?: string;
            /**
             * Format: date-time
             * @description Date when the record was deleted
             */
            deletedAt?: string;
            /**
             * Format: date-time
             * @description Last time the record was changed
             */
            updatedAt?: string;
            /**
             * Format: date-time
             * @description Creation date
             */
            createdAt?: string;
            /**
             * Format: uuid
             * @description Id
             */
            id?: string;
            /** @description Sub field name */
            subFieldName?: string;
            /** @description Position in the view filter group */
            positionInViewFilterGroup?: number;
            /**
             * Format: uuid
             * @description View Filter Group
             */
            viewFilterGroupId?: string;
            /** @description View Filter value */
            value?: string;
            /** @description View Filter operand */
            operand?: string;
            /**
             * Format: uuid
             * @description View Filter target field
             */
            fieldMetadataId?: string;
            /** @description View Filter related view */
            view?: components["schemas"]["ViewForResponse"];
        };
        /**
         * @description (System) View Groups
         * @example {
         *       "fieldMetadataId": "4f07bb23-8e6e-4b6f-a10b-a06a7a2e1e15"
         *     }
         */
        ViewGroup: {
            /**
             * Format: uuid
             * @description View Group target field
             */
            fieldMetadataId: string;
            /** Format: uuid */
            viewId?: string;
            /** @description View Field position */
            position?: number;
            /** @description Group by this field value */
            fieldValue?: string;
            /** @description View Group visibility */
            isVisible?: boolean;
        };
        /**
         * @description (System) View Groups
         * @example {
         *       "fieldMetadataId": "6ab8bdd5-9691-497f-a6ad-50fc0b019ea1"
         *     }
         */
        ViewGroupForUpdate: {
            /**
             * Format: uuid
             * @description View Group target field
             */
            fieldMetadataId?: string;
            /** Format: uuid */
            viewId?: string;
            /** @description View Field position */
            position?: number;
            /** @description Group by this field value */
            fieldValue?: string;
            /** @description View Group visibility */
            isVisible?: boolean;
        };
        /** @description (System) View Groups */
        ViewGroupForResponse: {
            /**
             * Format: uuid
             * @description View Group target field
             */
            fieldMetadataId?: string;
            /** Format: uuid */
            viewId?: string;
            /**
             * Format: date-time
             * @description Date when the record was deleted
             */
            deletedAt?: string;
            /**
             * Format: date-time
             * @description Last time the record was changed
             */
            updatedAt?: string;
            /**
             * Format: date-time
             * @description Creation date
             */
            createdAt?: string;
            /**
             * Format: uuid
             * @description Id
             */
            id?: string;
            /** @description View Field position */
            position?: number;
            /** @description Group by this field value */
            fieldValue?: string;
            /** @description View Group visibility */
            isVisible?: boolean;
            /** @description View Group related view */
            view?: components["schemas"]["ViewForResponse"];
        };
        /**
         * @description (System) Views
         * @example {
         *       "key": [
         *         "INDEX"
         *       ],
         *       "openRecordIn": [
         *         "SIDE_PANEL"
         *       ],
         *       "kanbanAggregateOperation": [
         *         "AVG"
         *       ],
         *       "objectMetadataId": "6d9bee96-3e4a-4d0c-bbcf-7d768bc76bfd",
         *       "name": "View name"
         *     }
         */
        View: {
            /**
             * @description View key
             * @enum {string}
             */
            key?: "INDEX";
            /** @description View type */
            type?: string;
            /** @description View icon */
            icon?: string;
            /** @description View Kanban column field */
            kanbanFieldMetadataId?: string;
            /** @description View position */
            position?: number;
            /** @description Describes if the view is in compact mode */
            isCompact?: boolean;
            /**
             * @description Display the records in a side panel or in a record page
             * @enum {string}
             */
            openRecordIn?: "SIDE_PANEL" | "RECORD_PAGE";
            /**
             * @description Optional aggregate operation
             * @enum {string}
             */
            kanbanAggregateOperation?: "AVG" | "COUNT" | "MAX" | "MIN" | "SUM" | "COUNT_EMPTY" | "COUNT_NOT_EMPTY" | "COUNT_UNIQUE_VALUES" | "PERCENTAGE_EMPTY" | "PERCENTAGE_NOT_EMPTY" | "COUNT_TRUE" | "COUNT_FALSE";
            /**
             * Format: uuid
             * @description Field metadata used for aggregate operation
             */
            kanbanAggregateOperationFieldMetadataId?: string;
            /** @description Any field filter value */
            anyFieldFilterValue?: string;
            /**
             * Format: uuid
             * @description View target object
             */
            objectMetadataId: string;
            /** @description View name */
            name?: string;
        };
        /**
         * @description (System) Views
         * @example {
         *       "key": [
         *         "INDEX"
         *       ],
         *       "openRecordIn": [
         *         "SIDE_PANEL"
         *       ],
         *       "kanbanAggregateOperation": [
         *         "AVG"
         *       ],
         *       "objectMetadataId": "42888ed7-9f14-4a49-afa2-9563ce52ec0c",
         *       "name": "View name"
         *     }
         */
        ViewForUpdate: {
            /**
             * @description View key
             * @enum {string}
             */
            key?: "INDEX";
            /** @description View type */
            type?: string;
            /** @description View icon */
            icon?: string;
            /** @description View Kanban column field */
            kanbanFieldMetadataId?: string;
            /** @description View position */
            position?: number;
            /** @description Describes if the view is in compact mode */
            isCompact?: boolean;
            /**
             * @description Display the records in a side panel or in a record page
             * @enum {string}
             */
            openRecordIn?: "SIDE_PANEL" | "RECORD_PAGE";
            /**
             * @description Optional aggregate operation
             * @enum {string}
             */
            kanbanAggregateOperation?: "AVG" | "COUNT" | "MAX" | "MIN" | "SUM" | "COUNT_EMPTY" | "COUNT_NOT_EMPTY" | "COUNT_UNIQUE_VALUES" | "PERCENTAGE_EMPTY" | "PERCENTAGE_NOT_EMPTY" | "COUNT_TRUE" | "COUNT_FALSE";
            /**
             * Format: uuid
             * @description Field metadata used for aggregate operation
             */
            kanbanAggregateOperationFieldMetadataId?: string;
            /** @description Any field filter value */
            anyFieldFilterValue?: string;
            /**
             * Format: uuid
             * @description View target object
             */
            objectMetadataId?: string;
            /** @description View name */
            name?: string;
        };
        /** @description (System) Views */
        ViewForResponse: {
            /**
             * @description View key
             * @enum {string}
             */
            key?: "INDEX";
            /** @description View type */
            type?: string;
            /** @description View icon */
            icon?: string;
            /** @description View Kanban column field */
            kanbanFieldMetadataId?: string;
            /** @description View position */
            position?: number;
            /** @description Describes if the view is in compact mode */
            isCompact?: boolean;
            /**
             * @description Display the records in a side panel or in a record page
             * @enum {string}
             */
            openRecordIn?: "SIDE_PANEL" | "RECORD_PAGE";
            /**
             * @description Optional aggregate operation
             * @enum {string}
             */
            kanbanAggregateOperation?: "AVG" | "COUNT" | "MAX" | "MIN" | "SUM" | "COUNT_EMPTY" | "COUNT_NOT_EMPTY" | "COUNT_UNIQUE_VALUES" | "PERCENTAGE_EMPTY" | "PERCENTAGE_NOT_EMPTY" | "COUNT_TRUE" | "COUNT_FALSE";
            /**
             * Format: uuid
             * @description Field metadata used for aggregate operation
             */
            kanbanAggregateOperationFieldMetadataId?: string;
            /** @description Any field filter value */
            anyFieldFilterValue?: string;
            /**
             * Format: date-time
             * @description Creation date
             */
            createdAt?: string;
            /**
             * Format: uuid
             * @description Id
             */
            id?: string;
            /**
             * Format: date-time
             * @description Last time the record was changed
             */
            updatedAt?: string;
            /**
             * Format: date-time
             * @description Date when the record was deleted
             */
            deletedAt?: string;
            /**
             * Format: uuid
             * @description View target object
             */
            objectMetadataId?: string;
            /** @description View name */
            name?: string;
            /** @description View Sorts */
            viewSorts?: components["schemas"]["ViewSortForResponse"][];
            /** @description View Fields */
            viewFields?: components["schemas"]["ViewFieldForResponse"][];
            /** @description View Groups */
            viewGroups?: components["schemas"]["ViewGroupForResponse"][];
            /** @description View Filters */
            viewFilters?: components["schemas"]["ViewFilterForResponse"][];
            /** @description View Filter Groups */
            viewFilterGroups?: components["schemas"]["ViewFilterGroupForResponse"][];
        };
        /**
         * @description (System) View Sorts
         * @example {
         *       "fieldMetadataId": "3e01c4c5-55fa-456b-aa1d-89bd7275c8e7"
         *     }
         */
        ViewSort: {
            /** Format: uuid */
            viewId?: string;
            /**
             * Format: uuid
             * @description View Sort target field
             */
            fieldMetadataId: string;
            /** @description View Sort direction */
            direction?: string;
        };
        /**
         * @description (System) View Sorts
         * @example {
         *       "fieldMetadataId": "9bead423-5dcf-426c-9bcd-c05428fc11ff"
         *     }
         */
        ViewSortForUpdate: {
            /** Format: uuid */
            viewId?: string;
            /**
             * Format: uuid
             * @description View Sort target field
             */
            fieldMetadataId?: string;
            /** @description View Sort direction */
            direction?: string;
        };
        /** @description (System) View Sorts */
        ViewSortForResponse: {
            /**
             * Format: uuid
             * @description Id
             */
            id?: string;
            /** Format: uuid */
            viewId?: string;
            /**
             * Format: date-time
             * @description Date when the record was deleted
             */
            deletedAt?: string;
            /**
             * Format: date-time
             * @description Last time the record was changed
             */
            updatedAt?: string;
            /**
             * Format: uuid
             * @description View Sort target field
             */
            fieldMetadataId?: string;
            /** @description View Sort direction */
            direction?: string;
            /**
             * Format: date-time
             * @description Creation date
             */
            createdAt?: string;
            /** @description View Sort related view */
            view?: components["schemas"]["ViewForResponse"];
        };
        /**
         * @description A workflow automated trigger
         * @example {
         *       "type": [
         *         "DATABASE_EVENT"
         *       ],
         *       "settings": {}
         *     }
         */
        WorkflowAutomatedTrigger: {
            /** Format: uuid */
            workflowId?: string;
            /**
             * @description The workflow automated trigger type
             * @enum {string}
             */
            type: "DATABASE_EVENT" | "CRON";
            /** @description The workflow automated trigger settings */
            settings: Record<string, never>;
        };
        /**
         * @description A workflow automated trigger
         * @example {
         *       "type": [
         *         "DATABASE_EVENT"
         *       ],
         *       "settings": {}
         *     }
         */
        WorkflowAutomatedTriggerForUpdate: {
            /** Format: uuid */
            workflowId?: string;
            /**
             * @description The workflow automated trigger type
             * @enum {string}
             */
            type?: "DATABASE_EVENT" | "CRON";
            /** @description The workflow automated trigger settings */
            settings?: Record<string, never>;
        };
        /** @description A workflow automated trigger */
        WorkflowAutomatedTriggerForResponse: {
            /** Format: uuid */
            workflowId?: string;
            /**
             * @description The workflow automated trigger type
             * @enum {string}
             */
            type?: "DATABASE_EVENT" | "CRON";
            /** @description The workflow automated trigger settings */
            settings?: Record<string, never>;
            /**
             * Format: uuid
             * @description Id
             */
            id?: string;
            /**
             * Format: date-time
             * @description Creation date
             */
            createdAt?: string;
            /**
             * Format: date-time
             * @description Last time the record was changed
             */
            updatedAt?: string;
            /**
             * Format: date-time
             * @description Date when the record was deleted
             */
            deletedAt?: string;
            /** @description WorkflowAutomatedTrigger workflow */
            workflow?: components["schemas"]["WorkflowForResponse"];
        };
        /**
         * @description A workflow run
         * @example {
         *       "state": {},
         *       "status": [
         *         "NOT_STARTED"
         *       ],
         *       "name": "Workflow Run name"
         *     }
         */
        WorkflowRun: {
            /**
             * Format: date-time
             * @description Workflow run started at
             */
            startedAt?: string;
            /** Format: uuid */
            workflowId?: string;
            /** Format: uuid */
            workflowVersionId?: string;
            /** @description Workflow run position */
            position?: number;
            /** @description State of the workflow run */
            state: Record<string, never>;
            /** @description The executor of the workflow */
            createdBy?: {
                /** @enum {string} */
                source?: "EMAIL" | "CALENDAR" | "WORKFLOW" | "API" | "IMPORT" | "MANUAL" | "SYSTEM" | "WEBHOOK";
            };
            /**
             * @description Workflow run status
             * @enum {string}
             */
            status?: "NOT_STARTED" | "RUNNING" | "COMPLETED" | "FAILED" | "ENQUEUED";
            /**
             * Format: date-time
             * @description Workflow run ended at
             */
            endedAt?: string;
            /**
             * Format: date-time
             * @description Workflow run enqueued at
             */
            enqueuedAt?: string;
            /** @description Name of the workflow run */
            name?: string;
        };
        /**
         * @description A workflow run
         * @example {
         *       "state": {},
         *       "status": [
         *         "NOT_STARTED"
         *       ],
         *       "name": "Workflow Run name"
         *     }
         */
        WorkflowRunForUpdate: {
            /**
             * Format: date-time
             * @description Workflow run started at
             */
            startedAt?: string;
            /** Format: uuid */
            workflowId?: string;
            /** Format: uuid */
            workflowVersionId?: string;
            /** @description Workflow run position */
            position?: number;
            /** @description State of the workflow run */
            state?: Record<string, never>;
            /** @description The executor of the workflow */
            createdBy?: {
                /** @enum {string} */
                source?: "EMAIL" | "CALENDAR" | "WORKFLOW" | "API" | "IMPORT" | "MANUAL" | "SYSTEM" | "WEBHOOK";
            };
            /**
             * @description Workflow run status
             * @enum {string}
             */
            status?: "NOT_STARTED" | "RUNNING" | "COMPLETED" | "FAILED" | "ENQUEUED";
            /**
             * Format: date-time
             * @description Workflow run ended at
             */
            endedAt?: string;
            /**
             * Format: date-time
             * @description Workflow run enqueued at
             */
            enqueuedAt?: string;
            /** @description Name of the workflow run */
            name?: string;
        };
        /** @description A workflow run */
        WorkflowRunForResponse: {
            /**
             * Format: date-time
             * @description Workflow run started at
             */
            startedAt?: string;
            /** Format: uuid */
            workflowId?: string;
            /** Format: uuid */
            workflowVersionId?: string;
            /**
             * Format: date-time
             * @description Date when the record was deleted
             */
            deletedAt?: string;
            /**
             * Format: date-time
             * @description Last time the record was changed
             */
            updatedAt?: string;
            /**
             * Format: date-time
             * @description Creation date
             */
            createdAt?: string;
            /**
             * Format: uuid
             * @description Id
             */
            id?: string;
            /** @description Workflow run position */
            position?: number;
            /** @description State of the workflow run */
            state?: Record<string, never>;
            /** @description The executor of the workflow */
            createdBy?: {
                /** @enum {string} */
                source?: "EMAIL" | "CALENDAR" | "WORKFLOW" | "API" | "IMPORT" | "MANUAL" | "SYSTEM" | "WEBHOOK";
                /** Format: uuid */
                workspaceMemberId?: string;
                name?: string;
            };
            /**
             * @description Workflow run status
             * @enum {string}
             */
            status?: "NOT_STARTED" | "RUNNING" | "COMPLETED" | "FAILED" | "ENQUEUED";
            /**
             * Format: date-time
             * @description Workflow run ended at
             */
            endedAt?: string;
            /**
             * Format: date-time
             * @description Workflow run enqueued at
             */
            enqueuedAt?: string;
            /** @description Name of the workflow run */
            name?: string;
            /** @description Timeline activities linked to the run */
            timelineActivities?: components["schemas"]["TimelineActivityForResponse"][];
            /** @description Workflow linked to the run. */
            workflow?: components["schemas"]["WorkflowForResponse"];
            /** @description Workflow version linked to the run. */
            workflowVersion?: components["schemas"]["WorkflowVersionForResponse"];
            /** @description Favorites linked to the workflow run */
            favorites?: components["schemas"]["FavoriteForResponse"][];
        };
        /**
         * @description A workflow
         * @example {
         *       "statuses": [
         *         "DRAFT"
         *       ],
         *       "name": "Workflow name"
         *     }
         */
        Workflow: {
            /** @description The current statuses of the workflow versions */
            statuses?: ("DRAFT" | "ACTIVE" | "DEACTIVATED")[];
            /** @description The workflow last published version id */
            lastPublishedVersionId?: string;
            /** @description The workflow name */
            name?: string;
            /** @description Workflow record position */
            position?: number;
            /** @description The creator of the record */
            createdBy?: {
                /** @enum {string} */
                source?: "EMAIL" | "CALENDAR" | "WORKFLOW" | "API" | "IMPORT" | "MANUAL" | "SYSTEM" | "WEBHOOK";
            };
        };
        /**
         * @description A workflow
         * @example {
         *       "statuses": [
         *         "DRAFT"
         *       ],
         *       "name": "Workflow name"
         *     }
         */
        WorkflowForUpdate: {
            /** @description The current statuses of the workflow versions */
            statuses?: ("DRAFT" | "ACTIVE" | "DEACTIVATED")[];
            /** @description The workflow last published version id */
            lastPublishedVersionId?: string;
            /** @description The workflow name */
            name?: string;
            /** @description Workflow record position */
            position?: number;
            /** @description The creator of the record */
            createdBy?: {
                /** @enum {string} */
                source?: "EMAIL" | "CALENDAR" | "WORKFLOW" | "API" | "IMPORT" | "MANUAL" | "SYSTEM" | "WEBHOOK";
            };
        };
        /** @description A workflow */
        WorkflowForResponse: {
            /**
             * Format: date-time
             * @description Last time the record was changed
             */
            updatedAt?: string;
            /** @description The current statuses of the workflow versions */
            statuses?: ("DRAFT" | "ACTIVE" | "DEACTIVATED")[];
            /** @description The workflow last published version id */
            lastPublishedVersionId?: string;
            /** @description The workflow name */
            name?: string;
            /** @description Workflow record position */
            position?: number;
            /** @description The creator of the record */
            createdBy?: {
                /** @enum {string} */
                source?: "EMAIL" | "CALENDAR" | "WORKFLOW" | "API" | "IMPORT" | "MANUAL" | "SYSTEM" | "WEBHOOK";
                /** Format: uuid */
                workspaceMemberId?: string;
                name?: string;
            };
            /**
             * Format: uuid
             * @description Id
             */
            id?: string;
            /**
             * Format: date-time
             * @description Creation date
             */
            createdAt?: string;
            /**
             * Format: date-time
             * @description Date when the record was deleted
             */
            deletedAt?: string;
            /** @description Timeline activities linked to the workflow */
            timelineActivities?: components["schemas"]["TimelineActivityForResponse"][];
            /** @description Favorites linked to the workflow */
            favorites?: components["schemas"]["FavoriteForResponse"][];
            /** @description Workflow automated triggers linked to the workflow. */
            automatedTriggers?: components["schemas"]["WorkflowAutomatedTriggerForResponse"][];
            /** @description Workflow runs linked to the workflow. */
            runs?: components["schemas"]["WorkflowRunForResponse"][];
            /** @description Workflow versions linked to the workflow. */
            versions?: components["schemas"]["WorkflowVersionForResponse"][];
        };
        /**
         * @description A workflow version
         * @example {
         *       "status": [
         *         "DRAFT"
         *       ],
         *       "name": "Workflow Version name"
         *     }
         */
        WorkflowVersion: {
            /** Format: uuid */
            workflowId?: string;
            /**
             * @description The workflow version status
             * @enum {string}
             */
            status?: "DRAFT" | "ACTIVE" | "DEACTIVATED" | "ARCHIVED";
            /** @description Json object to provide steps */
            steps?: Record<string, never>;
            /** @description Json object to provide trigger */
            trigger?: Record<string, never>;
            /** @description Workflow version position */
            position?: number;
            /** @description The workflow version name */
            name?: string;
        };
        /**
         * @description A workflow version
         * @example {
         *       "status": [
         *         "DRAFT"
         *       ],
         *       "name": "Workflow Version name"
         *     }
         */
        WorkflowVersionForUpdate: {
            /** Format: uuid */
            workflowId?: string;
            /**
             * @description The workflow version status
             * @enum {string}
             */
            status?: "DRAFT" | "ACTIVE" | "DEACTIVATED" | "ARCHIVED";
            /** @description Json object to provide steps */
            steps?: Record<string, never>;
            /** @description Json object to provide trigger */
            trigger?: Record<string, never>;
            /** @description Workflow version position */
            position?: number;
            /** @description The workflow version name */
            name?: string;
        };
        /** @description A workflow version */
        WorkflowVersionForResponse: {
            /** Format: uuid */
            workflowId?: string;
            /**
             * Format: date-time
             * @description Date when the record was deleted
             */
            deletedAt?: string;
            /**
             * Format: date-time
             * @description Last time the record was changed
             */
            updatedAt?: string;
            /**
             * Format: date-time
             * @description Creation date
             */
            createdAt?: string;
            /**
             * Format: uuid
             * @description Id
             */
            id?: string;
            /**
             * @description The workflow version status
             * @enum {string}
             */
            status?: "DRAFT" | "ACTIVE" | "DEACTIVATED" | "ARCHIVED";
            /** @description Json object to provide steps */
            steps?: Record<string, never>;
            /** @description Json object to provide trigger */
            trigger?: Record<string, never>;
            /** @description Workflow version position */
            position?: number;
            /** @description The workflow version name */
            name?: string;
            /** @description Favorites linked to the workflow version */
            favorites?: components["schemas"]["FavoriteForResponse"][];
            /** @description Workflow runs linked to the version. */
            runs?: components["schemas"]["WorkflowRunForResponse"][];
            /** @description WorkflowVersion workflow */
            workflow?: components["schemas"]["WorkflowForResponse"];
            /** @description Timeline activities linked to the version */
            timelineActivities?: components["schemas"]["TimelineActivityForResponse"][];
        };
        /**
         * @description A workspace member
         * @example {
         *       "name": {
         *         "firstName": "Alfreda",
         *         "lastName": "Bosco"
         *       },
         *       "numberFormat": [
         *         "SYSTEM"
         *       ],
         *       "timeFormat": [
         *         "SYSTEM"
         *       ],
         *       "dateFormat": [
         *         "SYSTEM"
         *       ],
         *       "userId": "da646138-839f-4ae7-ae70-92611b21210a"
         *     }
         */
        WorkspaceMember: {
            /** @description Related user email address */
            userEmail?: string;
            /** @description Preferred language */
            locale?: string;
            /** @description Preferred color scheme */
            colorScheme?: string;
            /** @description Workspace member name */
            name?: {
                firstName?: string;
                lastName?: string;
            };
            /** @description Workspace member position */
            position?: number;
            /**
             * @description User's preferred number format
             * @enum {string}
             */
            numberFormat?: "SYSTEM" | "COMMAS_AND_DOT" | "SPACES_AND_COMMA" | "DOTS_AND_COMMA" | "APOSTROPHE_AND_DOT";
            /**
             * @description User's preferred time format
             * @enum {string}
             */
            timeFormat?: "SYSTEM" | "HOUR_24" | "HOUR_12";
            /**
             * @description User's preferred date format
             * @enum {string}
             */
            dateFormat?: "SYSTEM" | "MONTH_FIRST" | "DAY_FIRST" | "YEAR_FIRST";
            /** @description User time zone */
            timeZone?: string;
            /**
             * Format: uuid
             * @description Associated User Id
             */
            userId: string;
            /** @description User's preferred start day of the week */
            calendarStartDay?: number;
            /** @description Workspace member avatar */
            avatarUrl?: string;
        };
        /**
         * @description A workspace member
         * @example {
         *       "name": {
         *         "firstName": "Burley",
         *         "lastName": "Grimes"
         *       },
         *       "numberFormat": [
         *         "SYSTEM"
         *       ],
         *       "timeFormat": [
         *         "SYSTEM"
         *       ],
         *       "dateFormat": [
         *         "SYSTEM"
         *       ],
         *       "userId": "60d548aa-f554-4f77-a58e-b62f4680eee6"
         *     }
         */
        WorkspaceMemberForUpdate: {
            /** @description Related user email address */
            userEmail?: string;
            /** @description Preferred language */
            locale?: string;
            /** @description Preferred color scheme */
            colorScheme?: string;
            /** @description Workspace member name */
            name?: {
                firstName?: string;
                lastName?: string;
            };
            /** @description Workspace member position */
            position?: number;
            /**
             * @description User's preferred number format
             * @enum {string}
             */
            numberFormat?: "SYSTEM" | "COMMAS_AND_DOT" | "SPACES_AND_COMMA" | "DOTS_AND_COMMA" | "APOSTROPHE_AND_DOT";
            /**
             * @description User's preferred time format
             * @enum {string}
             */
            timeFormat?: "SYSTEM" | "HOUR_24" | "HOUR_12";
            /**
             * @description User's preferred date format
             * @enum {string}
             */
            dateFormat?: "SYSTEM" | "MONTH_FIRST" | "DAY_FIRST" | "YEAR_FIRST";
            /** @description User time zone */
            timeZone?: string;
            /**
             * Format: uuid
             * @description Associated User Id
             */
            userId?: string;
            /** @description User's preferred start day of the week */
            calendarStartDay?: number;
            /** @description Workspace member avatar */
            avatarUrl?: string;
        };
        /** @description A workspace member */
        WorkspaceMemberForResponse: {
            /** @description Related user email address */
            userEmail?: string;
            /** @description Preferred language */
            locale?: string;
            /** @description Preferred color scheme */
            colorScheme?: string;
            /** @description Workspace member name */
            name?: {
                firstName?: string;
                lastName?: string;
            };
            /** @description Workspace member position */
            position?: number;
            /**
             * Format: date-time
             * @description Date when the record was deleted
             */
            deletedAt?: string;
            /**
             * Format: date-time
             * @description Last time the record was changed
             */
            updatedAt?: string;
            /**
             * Format: date-time
             * @description Creation date
             */
            createdAt?: string;
            /**
             * Format: uuid
             * @description Id
             */
            id?: string;
            /**
             * @description User's preferred number format
             * @enum {string}
             */
            numberFormat?: "SYSTEM" | "COMMAS_AND_DOT" | "SPACES_AND_COMMA" | "DOTS_AND_COMMA" | "APOSTROPHE_AND_DOT";
            /**
             * @description User's preferred time format
             * @enum {string}
             */
            timeFormat?: "SYSTEM" | "HOUR_24" | "HOUR_12";
            /**
             * @description User's preferred date format
             * @enum {string}
             */
            dateFormat?: "SYSTEM" | "MONTH_FIRST" | "DAY_FIRST" | "YEAR_FIRST";
            /** @description User time zone */
            timeZone?: string;
            /**
             * Format: uuid
             * @description Associated User Id
             */
            userId?: string;
            /** @description User's preferred start day of the week */
            calendarStartDay?: number;
            /** @description Workspace member avatar */
            avatarUrl?: string;
            /** @description Connected accounts */
            connectedAccounts?: components["schemas"]["ConnectedAccountForResponse"][];
            /** @description Message Participants */
            messageParticipants?: components["schemas"]["MessageParticipantForResponse"][];
            /** @description Blocklisted handles */
            blocklist?: components["schemas"]["BlocklistForResponse"][];
            /** @description Calendar Event Participants */
            calendarEventParticipants?: components["schemas"]["CalendarEventParticipantForResponse"][];
            /** @description Events linked to the workspace member */
            timelineActivities?: components["schemas"]["TimelineActivityForResponse"][];
            /** @description Attachments created by the workspace member */
            authoredAttachments?: components["schemas"]["AttachmentForResponse"][];
            /** @description Account owner for companies */
            accountOwnerForCompanies?: components["schemas"]["CompanyForResponse"][];
            /** @description Favorites linked to the workspace member */
            favorites?: components["schemas"]["FavoriteForResponse"][];
            /** @description Tasks assigned to the workspace member */
            assignedTasks?: components["schemas"]["TaskForResponse"][];
        };
    };
    responses: {
        /** @description Bad Request */
        400: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": {
                    statusCode?: number;
                    messages?: string[];
                    error?: string;
                };
            };
        };
        /** @description Unauthorized */
        401: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": {
                    statusCode?: number;
                    message?: string;
                    error?: string;
                };
            };
        };
    };
    parameters: {
        /** @description Object id. */
        idPath: string;
        /** @description Returns objects starting after a specific cursor. You can find cursors in **startCursor** and **endCursor** in **pageInfo** in response data */
        startingAfter: string;
        /** @description Returns objects ending before a specific cursor. You can find cursors in **startCursor** and **endCursor** in **pageInfo** in response data */
        endingBefore: string;
        /** @description Format: field[COMPARATOR]:value,field2[COMPARATOR]:value2
         *         Refer to the filter section at the top of the page for more details. */
        filter: string;
        /** @description Determines the level of nested related objects to include in the response.
         *         - 0: Primary object only
         *         - 1: Primary object + direct relations
         *         - 2: Primary object + direct relations + nested relations */
        depth: 0 | 1;
        /** @description Format: **field_name_1,field_name_2[DIRECTION_2]
         *         Refer to the filter section at the top of the page for more details. */
        orderBy: string;
        /** @description Limits the number of objects returned. */
        limit: number;
    };
    requestBodies: never;
    headers: never;
    pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
    GetOpenApiSchema: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        openapi?: string;
                        info?: {
                            title?: string;
                            description?: string;
                            termsOfService?: string;
                            contact?: {
                                email?: string;
                            };
                            license?: {
                                name?: string;
                                url?: string;
                            };
                        };
                        servers?: {
                            url?: string;
                            description?: string;
                        }[];
                        components?: {
                            schemas?: Record<string, never>;
                            parameters?: Record<string, never>;
                            responses?: Record<string, never>;
                        };
                        paths?: Record<string, never>;
                        tags?: Record<string, never>;
                    };
                };
            };
        };
    };
    findManyAttachments: {
        parameters: {
            query?: {
                /** @description Format: **field_name_1,field_name_2[DIRECTION_2]
                 *         Refer to the filter section at the top of the page for more details. */
                order_by?: components["parameters"]["orderBy"];
                /** @description Format: field[COMPARATOR]:value,field2[COMPARATOR]:value2
                 *         Refer to the filter section at the top of the page for more details. */
                filter?: components["parameters"]["filter"];
                /** @description Limits the number of objects returned. */
                limit?: components["parameters"]["limit"];
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
                /** @description Returns objects starting after a specific cursor. You can find cursors in **startCursor** and **endCursor** in **pageInfo** in response data */
                starting_after?: components["parameters"]["startingAfter"];
                /** @description Returns objects ending before a specific cursor. You can find cursors in **startCursor** and **endCursor** in **pageInfo** in response data */
                ending_before?: components["parameters"]["endingBefore"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            attachments?: components["schemas"]["AttachmentForResponse"][];
                        };
                        pageInfo?: {
                            hasNextPage?: boolean;
                            /** Format: uuid */
                            startCursor?: string;
                            /** Format: uuid */
                            endCursor?: string;
                        };
                        totalCount?: number;
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    createOneAttachment: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description body */
        requestBody: {
            content: {
                "application/json": components["schemas"]["Attachment"];
            };
        };
        responses: {
            /** @description Successful operation */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            createAttachment?: components["schemas"]["AttachmentForResponse"];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    createManyAttachments: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["Attachment"][];
            };
        };
        responses: {
            /** @description Successful operation */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            createAttachments?: components["schemas"]["AttachmentForResponse"][];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    findOneAttachment: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path: {
                /** @description Object id. */
                id: components["parameters"]["idPath"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            attachment?: components["schemas"]["AttachmentForResponse"];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    deleteOneAttachment: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Object id. */
                id: components["parameters"]["idPath"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            deleteAttachment?: {
                                /** Format: uuid */
                                id?: string;
                            };
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    UpdateOneAttachment: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path: {
                /** @description Object id. */
                id: components["parameters"]["idPath"];
            };
            cookie?: never;
        };
        /** @description body */
        requestBody: {
            content: {
                "application/json": components["schemas"]["AttachmentForUpdate"];
            };
        };
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            updateAttachment?: components["schemas"]["AttachmentForResponse"];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    findAttachmentDuplicates: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description body */
        requestBody: {
            content: {
                "application/json": {
                    data?: components["schemas"]["Attachment"][];
                    ids?: string[];
                };
            };
        };
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            totalCount?: number;
                            pageInfo?: {
                                hasNextPage?: boolean;
                                /** Format: uuid */
                                startCursor?: string;
                                /** Format: uuid */
                                endCursor?: string;
                            };
                            attachmentDuplicates?: components["schemas"]["AttachmentForResponse"][];
                        }[];
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    findManyBlocklists: {
        parameters: {
            query?: {
                /** @description Format: **field_name_1,field_name_2[DIRECTION_2]
                 *         Refer to the filter section at the top of the page for more details. */
                order_by?: components["parameters"]["orderBy"];
                /** @description Format: field[COMPARATOR]:value,field2[COMPARATOR]:value2
                 *         Refer to the filter section at the top of the page for more details. */
                filter?: components["parameters"]["filter"];
                /** @description Limits the number of objects returned. */
                limit?: components["parameters"]["limit"];
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
                /** @description Returns objects starting after a specific cursor. You can find cursors in **startCursor** and **endCursor** in **pageInfo** in response data */
                starting_after?: components["parameters"]["startingAfter"];
                /** @description Returns objects ending before a specific cursor. You can find cursors in **startCursor** and **endCursor** in **pageInfo** in response data */
                ending_before?: components["parameters"]["endingBefore"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            blocklists?: components["schemas"]["BlocklistForResponse"][];
                        };
                        pageInfo?: {
                            hasNextPage?: boolean;
                            /** Format: uuid */
                            startCursor?: string;
                            /** Format: uuid */
                            endCursor?: string;
                        };
                        totalCount?: number;
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    createOneBlocklist: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description body */
        requestBody: {
            content: {
                "application/json": components["schemas"]["Blocklist"];
            };
        };
        responses: {
            /** @description Successful operation */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            createBlocklist?: components["schemas"]["BlocklistForResponse"];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    createManyBlocklists: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["Blocklist"][];
            };
        };
        responses: {
            /** @description Successful operation */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            createBlocklists?: components["schemas"]["BlocklistForResponse"][];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    findOneBlocklist: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path: {
                /** @description Object id. */
                id: components["parameters"]["idPath"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            blocklist?: components["schemas"]["BlocklistForResponse"];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    deleteOneBlocklist: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Object id. */
                id: components["parameters"]["idPath"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            deleteBlocklist?: {
                                /** Format: uuid */
                                id?: string;
                            };
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    UpdateOneBlocklist: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path: {
                /** @description Object id. */
                id: components["parameters"]["idPath"];
            };
            cookie?: never;
        };
        /** @description body */
        requestBody: {
            content: {
                "application/json": components["schemas"]["BlocklistForUpdate"];
            };
        };
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            updateBlocklist?: components["schemas"]["BlocklistForResponse"];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    findBlocklistDuplicates: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description body */
        requestBody: {
            content: {
                "application/json": {
                    data?: components["schemas"]["Blocklist"][];
                    ids?: string[];
                };
            };
        };
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            totalCount?: number;
                            pageInfo?: {
                                hasNextPage?: boolean;
                                /** Format: uuid */
                                startCursor?: string;
                                /** Format: uuid */
                                endCursor?: string;
                            };
                            blocklistDuplicates?: components["schemas"]["BlocklistForResponse"][];
                        }[];
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    findManyCalendarChannelEventAssociations: {
        parameters: {
            query?: {
                /** @description Format: **field_name_1,field_name_2[DIRECTION_2]
                 *         Refer to the filter section at the top of the page for more details. */
                order_by?: components["parameters"]["orderBy"];
                /** @description Format: field[COMPARATOR]:value,field2[COMPARATOR]:value2
                 *         Refer to the filter section at the top of the page for more details. */
                filter?: components["parameters"]["filter"];
                /** @description Limits the number of objects returned. */
                limit?: components["parameters"]["limit"];
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
                /** @description Returns objects starting after a specific cursor. You can find cursors in **startCursor** and **endCursor** in **pageInfo** in response data */
                starting_after?: components["parameters"]["startingAfter"];
                /** @description Returns objects ending before a specific cursor. You can find cursors in **startCursor** and **endCursor** in **pageInfo** in response data */
                ending_before?: components["parameters"]["endingBefore"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            calendarChannelEventAssociations?: components["schemas"]["CalendarChannelEventAssociationForResponse"][];
                        };
                        pageInfo?: {
                            hasNextPage?: boolean;
                            /** Format: uuid */
                            startCursor?: string;
                            /** Format: uuid */
                            endCursor?: string;
                        };
                        totalCount?: number;
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    createOneCalendarChannelEventAssociation: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description body */
        requestBody: {
            content: {
                "application/json": components["schemas"]["CalendarChannelEventAssociation"];
            };
        };
        responses: {
            /** @description Successful operation */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            createCalendarChannelEventAssociation?: components["schemas"]["CalendarChannelEventAssociationForResponse"];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    createManyCalendarChannelEventAssociations: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CalendarChannelEventAssociation"][];
            };
        };
        responses: {
            /** @description Successful operation */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            createCalendarChannelEventAssociations?: components["schemas"]["CalendarChannelEventAssociationForResponse"][];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    findOneCalendarChannelEventAssociation: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path: {
                /** @description Object id. */
                id: components["parameters"]["idPath"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            calendarChannelEventAssociation?: components["schemas"]["CalendarChannelEventAssociationForResponse"];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    deleteOneCalendarChannelEventAssociation: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Object id. */
                id: components["parameters"]["idPath"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            deleteCalendarChannelEventAssociation?: {
                                /** Format: uuid */
                                id?: string;
                            };
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    UpdateOneCalendarChannelEventAssociation: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path: {
                /** @description Object id. */
                id: components["parameters"]["idPath"];
            };
            cookie?: never;
        };
        /** @description body */
        requestBody: {
            content: {
                "application/json": components["schemas"]["CalendarChannelEventAssociationForUpdate"];
            };
        };
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            updateCalendarChannelEventAssociation?: components["schemas"]["CalendarChannelEventAssociationForResponse"];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    findCalendarChannelEventAssociationDuplicates: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description body */
        requestBody: {
            content: {
                "application/json": {
                    data?: components["schemas"]["CalendarChannelEventAssociation"][];
                    ids?: string[];
                };
            };
        };
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            totalCount?: number;
                            pageInfo?: {
                                hasNextPage?: boolean;
                                /** Format: uuid */
                                startCursor?: string;
                                /** Format: uuid */
                                endCursor?: string;
                            };
                            calendarChannelEventAssociationDuplicates?: components["schemas"]["CalendarChannelEventAssociationForResponse"][];
                        }[];
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    findManyCalendarChannels: {
        parameters: {
            query?: {
                /** @description Format: **field_name_1,field_name_2[DIRECTION_2]
                 *         Refer to the filter section at the top of the page for more details. */
                order_by?: components["parameters"]["orderBy"];
                /** @description Format: field[COMPARATOR]:value,field2[COMPARATOR]:value2
                 *         Refer to the filter section at the top of the page for more details. */
                filter?: components["parameters"]["filter"];
                /** @description Limits the number of objects returned. */
                limit?: components["parameters"]["limit"];
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
                /** @description Returns objects starting after a specific cursor. You can find cursors in **startCursor** and **endCursor** in **pageInfo** in response data */
                starting_after?: components["parameters"]["startingAfter"];
                /** @description Returns objects ending before a specific cursor. You can find cursors in **startCursor** and **endCursor** in **pageInfo** in response data */
                ending_before?: components["parameters"]["endingBefore"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            calendarChannels?: components["schemas"]["CalendarChannelForResponse"][];
                        };
                        pageInfo?: {
                            hasNextPage?: boolean;
                            /** Format: uuid */
                            startCursor?: string;
                            /** Format: uuid */
                            endCursor?: string;
                        };
                        totalCount?: number;
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    createOneCalendarChannel: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description body */
        requestBody: {
            content: {
                "application/json": components["schemas"]["CalendarChannel"];
            };
        };
        responses: {
            /** @description Successful operation */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            createCalendarChannel?: components["schemas"]["CalendarChannelForResponse"];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    createManyCalendarChannels: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CalendarChannel"][];
            };
        };
        responses: {
            /** @description Successful operation */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            createCalendarChannels?: components["schemas"]["CalendarChannelForResponse"][];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    findOneCalendarChannel: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path: {
                /** @description Object id. */
                id: components["parameters"]["idPath"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            calendarChannel?: components["schemas"]["CalendarChannelForResponse"];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    deleteOneCalendarChannel: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Object id. */
                id: components["parameters"]["idPath"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            deleteCalendarChannel?: {
                                /** Format: uuid */
                                id?: string;
                            };
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    UpdateOneCalendarChannel: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path: {
                /** @description Object id. */
                id: components["parameters"]["idPath"];
            };
            cookie?: never;
        };
        /** @description body */
        requestBody: {
            content: {
                "application/json": components["schemas"]["CalendarChannelForUpdate"];
            };
        };
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            updateCalendarChannel?: components["schemas"]["CalendarChannelForResponse"];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    findCalendarChannelDuplicates: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description body */
        requestBody: {
            content: {
                "application/json": {
                    data?: components["schemas"]["CalendarChannel"][];
                    ids?: string[];
                };
            };
        };
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            totalCount?: number;
                            pageInfo?: {
                                hasNextPage?: boolean;
                                /** Format: uuid */
                                startCursor?: string;
                                /** Format: uuid */
                                endCursor?: string;
                            };
                            calendarChannelDuplicates?: components["schemas"]["CalendarChannelForResponse"][];
                        }[];
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    findManyCalendarEventParticipants: {
        parameters: {
            query?: {
                /** @description Format: **field_name_1,field_name_2[DIRECTION_2]
                 *         Refer to the filter section at the top of the page for more details. */
                order_by?: components["parameters"]["orderBy"];
                /** @description Format: field[COMPARATOR]:value,field2[COMPARATOR]:value2
                 *         Refer to the filter section at the top of the page for more details. */
                filter?: components["parameters"]["filter"];
                /** @description Limits the number of objects returned. */
                limit?: components["parameters"]["limit"];
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
                /** @description Returns objects starting after a specific cursor. You can find cursors in **startCursor** and **endCursor** in **pageInfo** in response data */
                starting_after?: components["parameters"]["startingAfter"];
                /** @description Returns objects ending before a specific cursor. You can find cursors in **startCursor** and **endCursor** in **pageInfo** in response data */
                ending_before?: components["parameters"]["endingBefore"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            calendarEventParticipants?: components["schemas"]["CalendarEventParticipantForResponse"][];
                        };
                        pageInfo?: {
                            hasNextPage?: boolean;
                            /** Format: uuid */
                            startCursor?: string;
                            /** Format: uuid */
                            endCursor?: string;
                        };
                        totalCount?: number;
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    createOneCalendarEventParticipant: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description body */
        requestBody: {
            content: {
                "application/json": components["schemas"]["CalendarEventParticipant"];
            };
        };
        responses: {
            /** @description Successful operation */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            createCalendarEventParticipant?: components["schemas"]["CalendarEventParticipantForResponse"];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    createManyCalendarEventParticipants: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CalendarEventParticipant"][];
            };
        };
        responses: {
            /** @description Successful operation */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            createCalendarEventParticipants?: components["schemas"]["CalendarEventParticipantForResponse"][];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    findOneCalendarEventParticipant: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path: {
                /** @description Object id. */
                id: components["parameters"]["idPath"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            calendarEventParticipant?: components["schemas"]["CalendarEventParticipantForResponse"];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    deleteOneCalendarEventParticipant: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Object id. */
                id: components["parameters"]["idPath"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            deleteCalendarEventParticipant?: {
                                /** Format: uuid */
                                id?: string;
                            };
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    UpdateOneCalendarEventParticipant: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path: {
                /** @description Object id. */
                id: components["parameters"]["idPath"];
            };
            cookie?: never;
        };
        /** @description body */
        requestBody: {
            content: {
                "application/json": components["schemas"]["CalendarEventParticipantForUpdate"];
            };
        };
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            updateCalendarEventParticipant?: components["schemas"]["CalendarEventParticipantForResponse"];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    findCalendarEventParticipantDuplicates: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description body */
        requestBody: {
            content: {
                "application/json": {
                    data?: components["schemas"]["CalendarEventParticipant"][];
                    ids?: string[];
                };
            };
        };
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            totalCount?: number;
                            pageInfo?: {
                                hasNextPage?: boolean;
                                /** Format: uuid */
                                startCursor?: string;
                                /** Format: uuid */
                                endCursor?: string;
                            };
                            calendarEventParticipantDuplicates?: components["schemas"]["CalendarEventParticipantForResponse"][];
                        }[];
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    findManyCalendarEvents: {
        parameters: {
            query?: {
                /** @description Format: **field_name_1,field_name_2[DIRECTION_2]
                 *         Refer to the filter section at the top of the page for more details. */
                order_by?: components["parameters"]["orderBy"];
                /** @description Format: field[COMPARATOR]:value,field2[COMPARATOR]:value2
                 *         Refer to the filter section at the top of the page for more details. */
                filter?: components["parameters"]["filter"];
                /** @description Limits the number of objects returned. */
                limit?: components["parameters"]["limit"];
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
                /** @description Returns objects starting after a specific cursor. You can find cursors in **startCursor** and **endCursor** in **pageInfo** in response data */
                starting_after?: components["parameters"]["startingAfter"];
                /** @description Returns objects ending before a specific cursor. You can find cursors in **startCursor** and **endCursor** in **pageInfo** in response data */
                ending_before?: components["parameters"]["endingBefore"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            calendarEvents?: components["schemas"]["CalendarEventForResponse"][];
                        };
                        pageInfo?: {
                            hasNextPage?: boolean;
                            /** Format: uuid */
                            startCursor?: string;
                            /** Format: uuid */
                            endCursor?: string;
                        };
                        totalCount?: number;
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    createOneCalendarEvent: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description body */
        requestBody: {
            content: {
                "application/json": components["schemas"]["CalendarEvent"];
            };
        };
        responses: {
            /** @description Successful operation */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            createCalendarEvent?: components["schemas"]["CalendarEventForResponse"];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    createManyCalendarEvents: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CalendarEvent"][];
            };
        };
        responses: {
            /** @description Successful operation */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            createCalendarEvents?: components["schemas"]["CalendarEventForResponse"][];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    findOneCalendarEvent: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path: {
                /** @description Object id. */
                id: components["parameters"]["idPath"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            calendarEvent?: components["schemas"]["CalendarEventForResponse"];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    deleteOneCalendarEvent: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Object id. */
                id: components["parameters"]["idPath"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            deleteCalendarEvent?: {
                                /** Format: uuid */
                                id?: string;
                            };
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    UpdateOneCalendarEvent: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path: {
                /** @description Object id. */
                id: components["parameters"]["idPath"];
            };
            cookie?: never;
        };
        /** @description body */
        requestBody: {
            content: {
                "application/json": components["schemas"]["CalendarEventForUpdate"];
            };
        };
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            updateCalendarEvent?: components["schemas"]["CalendarEventForResponse"];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    findCalendarEventDuplicates: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description body */
        requestBody: {
            content: {
                "application/json": {
                    data?: components["schemas"]["CalendarEvent"][];
                    ids?: string[];
                };
            };
        };
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            totalCount?: number;
                            pageInfo?: {
                                hasNextPage?: boolean;
                                /** Format: uuid */
                                startCursor?: string;
                                /** Format: uuid */
                                endCursor?: string;
                            };
                            calendarEventDuplicates?: components["schemas"]["CalendarEventForResponse"][];
                        }[];
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    findManyCompanies: {
        parameters: {
            query?: {
                /** @description Format: **field_name_1,field_name_2[DIRECTION_2]
                 *         Refer to the filter section at the top of the page for more details. */
                order_by?: components["parameters"]["orderBy"];
                /** @description Format: field[COMPARATOR]:value,field2[COMPARATOR]:value2
                 *         Refer to the filter section at the top of the page for more details. */
                filter?: components["parameters"]["filter"];
                /** @description Limits the number of objects returned. */
                limit?: components["parameters"]["limit"];
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
                /** @description Returns objects starting after a specific cursor. You can find cursors in **startCursor** and **endCursor** in **pageInfo** in response data */
                starting_after?: components["parameters"]["startingAfter"];
                /** @description Returns objects ending before a specific cursor. You can find cursors in **startCursor** and **endCursor** in **pageInfo** in response data */
                ending_before?: components["parameters"]["endingBefore"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            companies?: components["schemas"]["CompanyForResponse"][];
                        };
                        pageInfo?: {
                            hasNextPage?: boolean;
                            /** Format: uuid */
                            startCursor?: string;
                            /** Format: uuid */
                            endCursor?: string;
                        };
                        totalCount?: number;
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    createOneCompany: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description body */
        requestBody: {
            content: {
                "application/json": components["schemas"]["Company"];
            };
        };
        responses: {
            /** @description Successful operation */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            createCompany?: components["schemas"]["CompanyForResponse"];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    createManyCompanies: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["Company"][];
            };
        };
        responses: {
            /** @description Successful operation */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            createCompanies?: components["schemas"]["CompanyForResponse"][];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    findOneCompany: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path: {
                /** @description Object id. */
                id: components["parameters"]["idPath"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            company?: components["schemas"]["CompanyForResponse"];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    deleteOneCompany: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Object id. */
                id: components["parameters"]["idPath"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            deleteCompany?: {
                                /** Format: uuid */
                                id?: string;
                            };
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    UpdateOneCompany: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path: {
                /** @description Object id. */
                id: components["parameters"]["idPath"];
            };
            cookie?: never;
        };
        /** @description body */
        requestBody: {
            content: {
                "application/json": components["schemas"]["CompanyForUpdate"];
            };
        };
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            updateCompany?: components["schemas"]["CompanyForResponse"];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    findCompanyDuplicates: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description body */
        requestBody: {
            content: {
                "application/json": {
                    data?: components["schemas"]["Company"][];
                    ids?: string[];
                };
            };
        };
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            totalCount?: number;
                            pageInfo?: {
                                hasNextPage?: boolean;
                                /** Format: uuid */
                                startCursor?: string;
                                /** Format: uuid */
                                endCursor?: string;
                            };
                            companyDuplicates?: components["schemas"]["CompanyForResponse"][];
                        }[];
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    findManyConnectedAccounts: {
        parameters: {
            query?: {
                /** @description Format: **field_name_1,field_name_2[DIRECTION_2]
                 *         Refer to the filter section at the top of the page for more details. */
                order_by?: components["parameters"]["orderBy"];
                /** @description Format: field[COMPARATOR]:value,field2[COMPARATOR]:value2
                 *         Refer to the filter section at the top of the page for more details. */
                filter?: components["parameters"]["filter"];
                /** @description Limits the number of objects returned. */
                limit?: components["parameters"]["limit"];
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
                /** @description Returns objects starting after a specific cursor. You can find cursors in **startCursor** and **endCursor** in **pageInfo** in response data */
                starting_after?: components["parameters"]["startingAfter"];
                /** @description Returns objects ending before a specific cursor. You can find cursors in **startCursor** and **endCursor** in **pageInfo** in response data */
                ending_before?: components["parameters"]["endingBefore"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            connectedAccounts?: components["schemas"]["ConnectedAccountForResponse"][];
                        };
                        pageInfo?: {
                            hasNextPage?: boolean;
                            /** Format: uuid */
                            startCursor?: string;
                            /** Format: uuid */
                            endCursor?: string;
                        };
                        totalCount?: number;
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    createOneConnectedAccount: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description body */
        requestBody: {
            content: {
                "application/json": components["schemas"]["ConnectedAccount"];
            };
        };
        responses: {
            /** @description Successful operation */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            createConnectedAccount?: components["schemas"]["ConnectedAccountForResponse"];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    createManyConnectedAccounts: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ConnectedAccount"][];
            };
        };
        responses: {
            /** @description Successful operation */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            createConnectedAccounts?: components["schemas"]["ConnectedAccountForResponse"][];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    findOneConnectedAccount: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path: {
                /** @description Object id. */
                id: components["parameters"]["idPath"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            connectedAccount?: components["schemas"]["ConnectedAccountForResponse"];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    deleteOneConnectedAccount: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Object id. */
                id: components["parameters"]["idPath"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            deleteConnectedAccount?: {
                                /** Format: uuid */
                                id?: string;
                            };
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    UpdateOneConnectedAccount: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path: {
                /** @description Object id. */
                id: components["parameters"]["idPath"];
            };
            cookie?: never;
        };
        /** @description body */
        requestBody: {
            content: {
                "application/json": components["schemas"]["ConnectedAccountForUpdate"];
            };
        };
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            updateConnectedAccount?: components["schemas"]["ConnectedAccountForResponse"];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    findConnectedAccountDuplicates: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description body */
        requestBody: {
            content: {
                "application/json": {
                    data?: components["schemas"]["ConnectedAccount"][];
                    ids?: string[];
                };
            };
        };
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            totalCount?: number;
                            pageInfo?: {
                                hasNextPage?: boolean;
                                /** Format: uuid */
                                startCursor?: string;
                                /** Format: uuid */
                                endCursor?: string;
                            };
                            connectedAccountDuplicates?: components["schemas"]["ConnectedAccountForResponse"][];
                        }[];
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    findManyFavoriteFolders: {
        parameters: {
            query?: {
                /** @description Format: **field_name_1,field_name_2[DIRECTION_2]
                 *         Refer to the filter section at the top of the page for more details. */
                order_by?: components["parameters"]["orderBy"];
                /** @description Format: field[COMPARATOR]:value,field2[COMPARATOR]:value2
                 *         Refer to the filter section at the top of the page for more details. */
                filter?: components["parameters"]["filter"];
                /** @description Limits the number of objects returned. */
                limit?: components["parameters"]["limit"];
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
                /** @description Returns objects starting after a specific cursor. You can find cursors in **startCursor** and **endCursor** in **pageInfo** in response data */
                starting_after?: components["parameters"]["startingAfter"];
                /** @description Returns objects ending before a specific cursor. You can find cursors in **startCursor** and **endCursor** in **pageInfo** in response data */
                ending_before?: components["parameters"]["endingBefore"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            favoriteFolders?: components["schemas"]["FavoriteFolderForResponse"][];
                        };
                        pageInfo?: {
                            hasNextPage?: boolean;
                            /** Format: uuid */
                            startCursor?: string;
                            /** Format: uuid */
                            endCursor?: string;
                        };
                        totalCount?: number;
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    createOneFavoriteFolder: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description body */
        requestBody: {
            content: {
                "application/json": components["schemas"]["FavoriteFolder"];
            };
        };
        responses: {
            /** @description Successful operation */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            createFavoriteFolder?: components["schemas"]["FavoriteFolderForResponse"];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    createManyFavoriteFolders: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["FavoriteFolder"][];
            };
        };
        responses: {
            /** @description Successful operation */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            createFavoriteFolders?: components["schemas"]["FavoriteFolderForResponse"][];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    findOneFavoriteFolder: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path: {
                /** @description Object id. */
                id: components["parameters"]["idPath"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            favoriteFolder?: components["schemas"]["FavoriteFolderForResponse"];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    deleteOneFavoriteFolder: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Object id. */
                id: components["parameters"]["idPath"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            deleteFavoriteFolder?: {
                                /** Format: uuid */
                                id?: string;
                            };
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    UpdateOneFavoriteFolder: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path: {
                /** @description Object id. */
                id: components["parameters"]["idPath"];
            };
            cookie?: never;
        };
        /** @description body */
        requestBody: {
            content: {
                "application/json": components["schemas"]["FavoriteFolderForUpdate"];
            };
        };
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            updateFavoriteFolder?: components["schemas"]["FavoriteFolderForResponse"];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    findFavoriteFolderDuplicates: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description body */
        requestBody: {
            content: {
                "application/json": {
                    data?: components["schemas"]["FavoriteFolder"][];
                    ids?: string[];
                };
            };
        };
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            totalCount?: number;
                            pageInfo?: {
                                hasNextPage?: boolean;
                                /** Format: uuid */
                                startCursor?: string;
                                /** Format: uuid */
                                endCursor?: string;
                            };
                            favoriteFolderDuplicates?: components["schemas"]["FavoriteFolderForResponse"][];
                        }[];
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    findManyFavorites: {
        parameters: {
            query?: {
                /** @description Format: **field_name_1,field_name_2[DIRECTION_2]
                 *         Refer to the filter section at the top of the page for more details. */
                order_by?: components["parameters"]["orderBy"];
                /** @description Format: field[COMPARATOR]:value,field2[COMPARATOR]:value2
                 *         Refer to the filter section at the top of the page for more details. */
                filter?: components["parameters"]["filter"];
                /** @description Limits the number of objects returned. */
                limit?: components["parameters"]["limit"];
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
                /** @description Returns objects starting after a specific cursor. You can find cursors in **startCursor** and **endCursor** in **pageInfo** in response data */
                starting_after?: components["parameters"]["startingAfter"];
                /** @description Returns objects ending before a specific cursor. You can find cursors in **startCursor** and **endCursor** in **pageInfo** in response data */
                ending_before?: components["parameters"]["endingBefore"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            favorites?: components["schemas"]["FavoriteForResponse"][];
                        };
                        pageInfo?: {
                            hasNextPage?: boolean;
                            /** Format: uuid */
                            startCursor?: string;
                            /** Format: uuid */
                            endCursor?: string;
                        };
                        totalCount?: number;
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    createOneFavorite: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description body */
        requestBody: {
            content: {
                "application/json": components["schemas"]["Favorite"];
            };
        };
        responses: {
            /** @description Successful operation */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            createFavorite?: components["schemas"]["FavoriteForResponse"];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    createManyFavorites: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["Favorite"][];
            };
        };
        responses: {
            /** @description Successful operation */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            createFavorites?: components["schemas"]["FavoriteForResponse"][];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    findOneFavorite: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path: {
                /** @description Object id. */
                id: components["parameters"]["idPath"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            favorite?: components["schemas"]["FavoriteForResponse"];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    deleteOneFavorite: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Object id. */
                id: components["parameters"]["idPath"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            deleteFavorite?: {
                                /** Format: uuid */
                                id?: string;
                            };
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    UpdateOneFavorite: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path: {
                /** @description Object id. */
                id: components["parameters"]["idPath"];
            };
            cookie?: never;
        };
        /** @description body */
        requestBody: {
            content: {
                "application/json": components["schemas"]["FavoriteForUpdate"];
            };
        };
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            updateFavorite?: components["schemas"]["FavoriteForResponse"];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    findFavoriteDuplicates: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description body */
        requestBody: {
            content: {
                "application/json": {
                    data?: components["schemas"]["Favorite"][];
                    ids?: string[];
                };
            };
        };
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            totalCount?: number;
                            pageInfo?: {
                                hasNextPage?: boolean;
                                /** Format: uuid */
                                startCursor?: string;
                                /** Format: uuid */
                                endCursor?: string;
                            };
                            favoriteDuplicates?: components["schemas"]["FavoriteForResponse"][];
                        }[];
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    findManyMessageChannelMessageAssociations: {
        parameters: {
            query?: {
                /** @description Format: **field_name_1,field_name_2[DIRECTION_2]
                 *         Refer to the filter section at the top of the page for more details. */
                order_by?: components["parameters"]["orderBy"];
                /** @description Format: field[COMPARATOR]:value,field2[COMPARATOR]:value2
                 *         Refer to the filter section at the top of the page for more details. */
                filter?: components["parameters"]["filter"];
                /** @description Limits the number of objects returned. */
                limit?: components["parameters"]["limit"];
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
                /** @description Returns objects starting after a specific cursor. You can find cursors in **startCursor** and **endCursor** in **pageInfo** in response data */
                starting_after?: components["parameters"]["startingAfter"];
                /** @description Returns objects ending before a specific cursor. You can find cursors in **startCursor** and **endCursor** in **pageInfo** in response data */
                ending_before?: components["parameters"]["endingBefore"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            messageChannelMessageAssociations?: components["schemas"]["MessageChannelMessageAssociationForResponse"][];
                        };
                        pageInfo?: {
                            hasNextPage?: boolean;
                            /** Format: uuid */
                            startCursor?: string;
                            /** Format: uuid */
                            endCursor?: string;
                        };
                        totalCount?: number;
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    createOneMessageChannelMessageAssociation: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description body */
        requestBody: {
            content: {
                "application/json": components["schemas"]["MessageChannelMessageAssociation"];
            };
        };
        responses: {
            /** @description Successful operation */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            createMessageChannelMessageAssociation?: components["schemas"]["MessageChannelMessageAssociationForResponse"];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    createManyMessageChannelMessageAssociations: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["MessageChannelMessageAssociation"][];
            };
        };
        responses: {
            /** @description Successful operation */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            createMessageChannelMessageAssociations?: components["schemas"]["MessageChannelMessageAssociationForResponse"][];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    findOneMessageChannelMessageAssociation: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path: {
                /** @description Object id. */
                id: components["parameters"]["idPath"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            messageChannelMessageAssociation?: components["schemas"]["MessageChannelMessageAssociationForResponse"];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    deleteOneMessageChannelMessageAssociation: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Object id. */
                id: components["parameters"]["idPath"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            deleteMessageChannelMessageAssociation?: {
                                /** Format: uuid */
                                id?: string;
                            };
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    UpdateOneMessageChannelMessageAssociation: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path: {
                /** @description Object id. */
                id: components["parameters"]["idPath"];
            };
            cookie?: never;
        };
        /** @description body */
        requestBody: {
            content: {
                "application/json": components["schemas"]["MessageChannelMessageAssociationForUpdate"];
            };
        };
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            updateMessageChannelMessageAssociation?: components["schemas"]["MessageChannelMessageAssociationForResponse"];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    findMessageChannelMessageAssociationDuplicates: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description body */
        requestBody: {
            content: {
                "application/json": {
                    data?: components["schemas"]["MessageChannelMessageAssociation"][];
                    ids?: string[];
                };
            };
        };
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            totalCount?: number;
                            pageInfo?: {
                                hasNextPage?: boolean;
                                /** Format: uuid */
                                startCursor?: string;
                                /** Format: uuid */
                                endCursor?: string;
                            };
                            messageChannelMessageAssociationDuplicates?: components["schemas"]["MessageChannelMessageAssociationForResponse"][];
                        }[];
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    findManyMessageChannels: {
        parameters: {
            query?: {
                /** @description Format: **field_name_1,field_name_2[DIRECTION_2]
                 *         Refer to the filter section at the top of the page for more details. */
                order_by?: components["parameters"]["orderBy"];
                /** @description Format: field[COMPARATOR]:value,field2[COMPARATOR]:value2
                 *         Refer to the filter section at the top of the page for more details. */
                filter?: components["parameters"]["filter"];
                /** @description Limits the number of objects returned. */
                limit?: components["parameters"]["limit"];
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
                /** @description Returns objects starting after a specific cursor. You can find cursors in **startCursor** and **endCursor** in **pageInfo** in response data */
                starting_after?: components["parameters"]["startingAfter"];
                /** @description Returns objects ending before a specific cursor. You can find cursors in **startCursor** and **endCursor** in **pageInfo** in response data */
                ending_before?: components["parameters"]["endingBefore"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            messageChannels?: components["schemas"]["MessageChannelForResponse"][];
                        };
                        pageInfo?: {
                            hasNextPage?: boolean;
                            /** Format: uuid */
                            startCursor?: string;
                            /** Format: uuid */
                            endCursor?: string;
                        };
                        totalCount?: number;
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    createOneMessageChannel: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description body */
        requestBody: {
            content: {
                "application/json": components["schemas"]["MessageChannel"];
            };
        };
        responses: {
            /** @description Successful operation */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            createMessageChannel?: components["schemas"]["MessageChannelForResponse"];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    createManyMessageChannels: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["MessageChannel"][];
            };
        };
        responses: {
            /** @description Successful operation */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            createMessageChannels?: components["schemas"]["MessageChannelForResponse"][];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    findOneMessageChannel: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path: {
                /** @description Object id. */
                id: components["parameters"]["idPath"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            messageChannel?: components["schemas"]["MessageChannelForResponse"];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    deleteOneMessageChannel: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Object id. */
                id: components["parameters"]["idPath"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            deleteMessageChannel?: {
                                /** Format: uuid */
                                id?: string;
                            };
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    UpdateOneMessageChannel: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path: {
                /** @description Object id. */
                id: components["parameters"]["idPath"];
            };
            cookie?: never;
        };
        /** @description body */
        requestBody: {
            content: {
                "application/json": components["schemas"]["MessageChannelForUpdate"];
            };
        };
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            updateMessageChannel?: components["schemas"]["MessageChannelForResponse"];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    findMessageChannelDuplicates: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description body */
        requestBody: {
            content: {
                "application/json": {
                    data?: components["schemas"]["MessageChannel"][];
                    ids?: string[];
                };
            };
        };
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            totalCount?: number;
                            pageInfo?: {
                                hasNextPage?: boolean;
                                /** Format: uuid */
                                startCursor?: string;
                                /** Format: uuid */
                                endCursor?: string;
                            };
                            messageChannelDuplicates?: components["schemas"]["MessageChannelForResponse"][];
                        }[];
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    findManyMessageFolders: {
        parameters: {
            query?: {
                /** @description Format: **field_name_1,field_name_2[DIRECTION_2]
                 *         Refer to the filter section at the top of the page for more details. */
                order_by?: components["parameters"]["orderBy"];
                /** @description Format: field[COMPARATOR]:value,field2[COMPARATOR]:value2
                 *         Refer to the filter section at the top of the page for more details. */
                filter?: components["parameters"]["filter"];
                /** @description Limits the number of objects returned. */
                limit?: components["parameters"]["limit"];
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
                /** @description Returns objects starting after a specific cursor. You can find cursors in **startCursor** and **endCursor** in **pageInfo** in response data */
                starting_after?: components["parameters"]["startingAfter"];
                /** @description Returns objects ending before a specific cursor. You can find cursors in **startCursor** and **endCursor** in **pageInfo** in response data */
                ending_before?: components["parameters"]["endingBefore"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            messageFolders?: components["schemas"]["MessageFolderForResponse"][];
                        };
                        pageInfo?: {
                            hasNextPage?: boolean;
                            /** Format: uuid */
                            startCursor?: string;
                            /** Format: uuid */
                            endCursor?: string;
                        };
                        totalCount?: number;
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    createOneMessageFolder: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description body */
        requestBody: {
            content: {
                "application/json": components["schemas"]["MessageFolder"];
            };
        };
        responses: {
            /** @description Successful operation */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            createMessageFolder?: components["schemas"]["MessageFolderForResponse"];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    createManyMessageFolders: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["MessageFolder"][];
            };
        };
        responses: {
            /** @description Successful operation */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            createMessageFolders?: components["schemas"]["MessageFolderForResponse"][];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    findOneMessageFolder: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path: {
                /** @description Object id. */
                id: components["parameters"]["idPath"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            messageFolder?: components["schemas"]["MessageFolderForResponse"];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    deleteOneMessageFolder: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Object id. */
                id: components["parameters"]["idPath"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            deleteMessageFolder?: {
                                /** Format: uuid */
                                id?: string;
                            };
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    UpdateOneMessageFolder: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path: {
                /** @description Object id. */
                id: components["parameters"]["idPath"];
            };
            cookie?: never;
        };
        /** @description body */
        requestBody: {
            content: {
                "application/json": components["schemas"]["MessageFolderForUpdate"];
            };
        };
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            updateMessageFolder?: components["schemas"]["MessageFolderForResponse"];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    findMessageFolderDuplicates: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description body */
        requestBody: {
            content: {
                "application/json": {
                    data?: components["schemas"]["MessageFolder"][];
                    ids?: string[];
                };
            };
        };
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            totalCount?: number;
                            pageInfo?: {
                                hasNextPage?: boolean;
                                /** Format: uuid */
                                startCursor?: string;
                                /** Format: uuid */
                                endCursor?: string;
                            };
                            messageFolderDuplicates?: components["schemas"]["MessageFolderForResponse"][];
                        }[];
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    findManyMessageParticipants: {
        parameters: {
            query?: {
                /** @description Format: **field_name_1,field_name_2[DIRECTION_2]
                 *         Refer to the filter section at the top of the page for more details. */
                order_by?: components["parameters"]["orderBy"];
                /** @description Format: field[COMPARATOR]:value,field2[COMPARATOR]:value2
                 *         Refer to the filter section at the top of the page for more details. */
                filter?: components["parameters"]["filter"];
                /** @description Limits the number of objects returned. */
                limit?: components["parameters"]["limit"];
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
                /** @description Returns objects starting after a specific cursor. You can find cursors in **startCursor** and **endCursor** in **pageInfo** in response data */
                starting_after?: components["parameters"]["startingAfter"];
                /** @description Returns objects ending before a specific cursor. You can find cursors in **startCursor** and **endCursor** in **pageInfo** in response data */
                ending_before?: components["parameters"]["endingBefore"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            messageParticipants?: components["schemas"]["MessageParticipantForResponse"][];
                        };
                        pageInfo?: {
                            hasNextPage?: boolean;
                            /** Format: uuid */
                            startCursor?: string;
                            /** Format: uuid */
                            endCursor?: string;
                        };
                        totalCount?: number;
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    createOneMessageParticipant: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description body */
        requestBody: {
            content: {
                "application/json": components["schemas"]["MessageParticipant"];
            };
        };
        responses: {
            /** @description Successful operation */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            createMessageParticipant?: components["schemas"]["MessageParticipantForResponse"];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    createManyMessageParticipants: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["MessageParticipant"][];
            };
        };
        responses: {
            /** @description Successful operation */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            createMessageParticipants?: components["schemas"]["MessageParticipantForResponse"][];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    findOneMessageParticipant: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path: {
                /** @description Object id. */
                id: components["parameters"]["idPath"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            messageParticipant?: components["schemas"]["MessageParticipantForResponse"];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    deleteOneMessageParticipant: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Object id. */
                id: components["parameters"]["idPath"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            deleteMessageParticipant?: {
                                /** Format: uuid */
                                id?: string;
                            };
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    UpdateOneMessageParticipant: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path: {
                /** @description Object id. */
                id: components["parameters"]["idPath"];
            };
            cookie?: never;
        };
        /** @description body */
        requestBody: {
            content: {
                "application/json": components["schemas"]["MessageParticipantForUpdate"];
            };
        };
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            updateMessageParticipant?: components["schemas"]["MessageParticipantForResponse"];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    findMessageParticipantDuplicates: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description body */
        requestBody: {
            content: {
                "application/json": {
                    data?: components["schemas"]["MessageParticipant"][];
                    ids?: string[];
                };
            };
        };
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            totalCount?: number;
                            pageInfo?: {
                                hasNextPage?: boolean;
                                /** Format: uuid */
                                startCursor?: string;
                                /** Format: uuid */
                                endCursor?: string;
                            };
                            messageParticipantDuplicates?: components["schemas"]["MessageParticipantForResponse"][];
                        }[];
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    findManyMessages: {
        parameters: {
            query?: {
                /** @description Format: **field_name_1,field_name_2[DIRECTION_2]
                 *         Refer to the filter section at the top of the page for more details. */
                order_by?: components["parameters"]["orderBy"];
                /** @description Format: field[COMPARATOR]:value,field2[COMPARATOR]:value2
                 *         Refer to the filter section at the top of the page for more details. */
                filter?: components["parameters"]["filter"];
                /** @description Limits the number of objects returned. */
                limit?: components["parameters"]["limit"];
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
                /** @description Returns objects starting after a specific cursor. You can find cursors in **startCursor** and **endCursor** in **pageInfo** in response data */
                starting_after?: components["parameters"]["startingAfter"];
                /** @description Returns objects ending before a specific cursor. You can find cursors in **startCursor** and **endCursor** in **pageInfo** in response data */
                ending_before?: components["parameters"]["endingBefore"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            messages?: components["schemas"]["MessageForResponse"][];
                        };
                        pageInfo?: {
                            hasNextPage?: boolean;
                            /** Format: uuid */
                            startCursor?: string;
                            /** Format: uuid */
                            endCursor?: string;
                        };
                        totalCount?: number;
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    createOneMessage: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description body */
        requestBody: {
            content: {
                "application/json": components["schemas"]["Message"];
            };
        };
        responses: {
            /** @description Successful operation */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            createMessage?: components["schemas"]["MessageForResponse"];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    createManyMessages: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["Message"][];
            };
        };
        responses: {
            /** @description Successful operation */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            createMessages?: components["schemas"]["MessageForResponse"][];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    findOneMessage: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path: {
                /** @description Object id. */
                id: components["parameters"]["idPath"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            message?: components["schemas"]["MessageForResponse"];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    deleteOneMessage: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Object id. */
                id: components["parameters"]["idPath"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            deleteMessage?: {
                                /** Format: uuid */
                                id?: string;
                            };
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    UpdateOneMessage: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path: {
                /** @description Object id. */
                id: components["parameters"]["idPath"];
            };
            cookie?: never;
        };
        /** @description body */
        requestBody: {
            content: {
                "application/json": components["schemas"]["MessageForUpdate"];
            };
        };
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            updateMessage?: components["schemas"]["MessageForResponse"];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    findMessageDuplicates: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description body */
        requestBody: {
            content: {
                "application/json": {
                    data?: components["schemas"]["Message"][];
                    ids?: string[];
                };
            };
        };
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            totalCount?: number;
                            pageInfo?: {
                                hasNextPage?: boolean;
                                /** Format: uuid */
                                startCursor?: string;
                                /** Format: uuid */
                                endCursor?: string;
                            };
                            messageDuplicates?: components["schemas"]["MessageForResponse"][];
                        }[];
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    findManyMessageThreads: {
        parameters: {
            query?: {
                /** @description Format: **field_name_1,field_name_2[DIRECTION_2]
                 *         Refer to the filter section at the top of the page for more details. */
                order_by?: components["parameters"]["orderBy"];
                /** @description Format: field[COMPARATOR]:value,field2[COMPARATOR]:value2
                 *         Refer to the filter section at the top of the page for more details. */
                filter?: components["parameters"]["filter"];
                /** @description Limits the number of objects returned. */
                limit?: components["parameters"]["limit"];
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
                /** @description Returns objects starting after a specific cursor. You can find cursors in **startCursor** and **endCursor** in **pageInfo** in response data */
                starting_after?: components["parameters"]["startingAfter"];
                /** @description Returns objects ending before a specific cursor. You can find cursors in **startCursor** and **endCursor** in **pageInfo** in response data */
                ending_before?: components["parameters"]["endingBefore"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            messageThreads?: components["schemas"]["MessageThreadForResponse"][];
                        };
                        pageInfo?: {
                            hasNextPage?: boolean;
                            /** Format: uuid */
                            startCursor?: string;
                            /** Format: uuid */
                            endCursor?: string;
                        };
                        totalCount?: number;
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    createOneMessageThread: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description body */
        requestBody: {
            content: {
                "application/json": components["schemas"]["MessageThread"];
            };
        };
        responses: {
            /** @description Successful operation */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            createMessageThread?: components["schemas"]["MessageThreadForResponse"];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    createManyMessageThreads: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["MessageThread"][];
            };
        };
        responses: {
            /** @description Successful operation */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            createMessageThreads?: components["schemas"]["MessageThreadForResponse"][];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    findOneMessageThread: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path: {
                /** @description Object id. */
                id: components["parameters"]["idPath"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            messageThread?: components["schemas"]["MessageThreadForResponse"];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    deleteOneMessageThread: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Object id. */
                id: components["parameters"]["idPath"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            deleteMessageThread?: {
                                /** Format: uuid */
                                id?: string;
                            };
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    UpdateOneMessageThread: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path: {
                /** @description Object id. */
                id: components["parameters"]["idPath"];
            };
            cookie?: never;
        };
        /** @description body */
        requestBody: {
            content: {
                "application/json": components["schemas"]["MessageThreadForUpdate"];
            };
        };
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            updateMessageThread?: components["schemas"]["MessageThreadForResponse"];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    findMessageThreadDuplicates: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description body */
        requestBody: {
            content: {
                "application/json": {
                    data?: components["schemas"]["MessageThread"][];
                    ids?: string[];
                };
            };
        };
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            totalCount?: number;
                            pageInfo?: {
                                hasNextPage?: boolean;
                                /** Format: uuid */
                                startCursor?: string;
                                /** Format: uuid */
                                endCursor?: string;
                            };
                            messageThreadDuplicates?: components["schemas"]["MessageThreadForResponse"][];
                        }[];
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    findManyNotes: {
        parameters: {
            query?: {
                /** @description Format: **field_name_1,field_name_2[DIRECTION_2]
                 *         Refer to the filter section at the top of the page for more details. */
                order_by?: components["parameters"]["orderBy"];
                /** @description Format: field[COMPARATOR]:value,field2[COMPARATOR]:value2
                 *         Refer to the filter section at the top of the page for more details. */
                filter?: components["parameters"]["filter"];
                /** @description Limits the number of objects returned. */
                limit?: components["parameters"]["limit"];
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
                /** @description Returns objects starting after a specific cursor. You can find cursors in **startCursor** and **endCursor** in **pageInfo** in response data */
                starting_after?: components["parameters"]["startingAfter"];
                /** @description Returns objects ending before a specific cursor. You can find cursors in **startCursor** and **endCursor** in **pageInfo** in response data */
                ending_before?: components["parameters"]["endingBefore"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            notes?: components["schemas"]["NoteForResponse"][];
                        };
                        pageInfo?: {
                            hasNextPage?: boolean;
                            /** Format: uuid */
                            startCursor?: string;
                            /** Format: uuid */
                            endCursor?: string;
                        };
                        totalCount?: number;
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    createOneNote: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description body */
        requestBody: {
            content: {
                "application/json": components["schemas"]["Note"];
            };
        };
        responses: {
            /** @description Successful operation */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            createNote?: components["schemas"]["NoteForResponse"];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    createManyNotes: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["Note"][];
            };
        };
        responses: {
            /** @description Successful operation */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            createNotes?: components["schemas"]["NoteForResponse"][];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    findOneNote: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path: {
                /** @description Object id. */
                id: components["parameters"]["idPath"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            note?: components["schemas"]["NoteForResponse"];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    deleteOneNote: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Object id. */
                id: components["parameters"]["idPath"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            deleteNote?: {
                                /** Format: uuid */
                                id?: string;
                            };
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    UpdateOneNote: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path: {
                /** @description Object id. */
                id: components["parameters"]["idPath"];
            };
            cookie?: never;
        };
        /** @description body */
        requestBody: {
            content: {
                "application/json": components["schemas"]["NoteForUpdate"];
            };
        };
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            updateNote?: components["schemas"]["NoteForResponse"];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    findNoteDuplicates: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description body */
        requestBody: {
            content: {
                "application/json": {
                    data?: components["schemas"]["Note"][];
                    ids?: string[];
                };
            };
        };
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            totalCount?: number;
                            pageInfo?: {
                                hasNextPage?: boolean;
                                /** Format: uuid */
                                startCursor?: string;
                                /** Format: uuid */
                                endCursor?: string;
                            };
                            noteDuplicates?: components["schemas"]["NoteForResponse"][];
                        }[];
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    findManyNoteTargets: {
        parameters: {
            query?: {
                /** @description Format: **field_name_1,field_name_2[DIRECTION_2]
                 *         Refer to the filter section at the top of the page for more details. */
                order_by?: components["parameters"]["orderBy"];
                /** @description Format: field[COMPARATOR]:value,field2[COMPARATOR]:value2
                 *         Refer to the filter section at the top of the page for more details. */
                filter?: components["parameters"]["filter"];
                /** @description Limits the number of objects returned. */
                limit?: components["parameters"]["limit"];
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
                /** @description Returns objects starting after a specific cursor. You can find cursors in **startCursor** and **endCursor** in **pageInfo** in response data */
                starting_after?: components["parameters"]["startingAfter"];
                /** @description Returns objects ending before a specific cursor. You can find cursors in **startCursor** and **endCursor** in **pageInfo** in response data */
                ending_before?: components["parameters"]["endingBefore"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            noteTargets?: components["schemas"]["NoteTargetForResponse"][];
                        };
                        pageInfo?: {
                            hasNextPage?: boolean;
                            /** Format: uuid */
                            startCursor?: string;
                            /** Format: uuid */
                            endCursor?: string;
                        };
                        totalCount?: number;
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    createOneNoteTarget: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description body */
        requestBody: {
            content: {
                "application/json": components["schemas"]["NoteTarget"];
            };
        };
        responses: {
            /** @description Successful operation */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            createNoteTarget?: components["schemas"]["NoteTargetForResponse"];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    createManyNoteTargets: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["NoteTarget"][];
            };
        };
        responses: {
            /** @description Successful operation */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            createNoteTargets?: components["schemas"]["NoteTargetForResponse"][];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    findOneNoteTarget: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path: {
                /** @description Object id. */
                id: components["parameters"]["idPath"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            noteTarget?: components["schemas"]["NoteTargetForResponse"];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    deleteOneNoteTarget: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Object id. */
                id: components["parameters"]["idPath"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            deleteNoteTarget?: {
                                /** Format: uuid */
                                id?: string;
                            };
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    UpdateOneNoteTarget: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path: {
                /** @description Object id. */
                id: components["parameters"]["idPath"];
            };
            cookie?: never;
        };
        /** @description body */
        requestBody: {
            content: {
                "application/json": components["schemas"]["NoteTargetForUpdate"];
            };
        };
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            updateNoteTarget?: components["schemas"]["NoteTargetForResponse"];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    findNoteTargetDuplicates: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description body */
        requestBody: {
            content: {
                "application/json": {
                    data?: components["schemas"]["NoteTarget"][];
                    ids?: string[];
                };
            };
        };
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            totalCount?: number;
                            pageInfo?: {
                                hasNextPage?: boolean;
                                /** Format: uuid */
                                startCursor?: string;
                                /** Format: uuid */
                                endCursor?: string;
                            };
                            noteTargetDuplicates?: components["schemas"]["NoteTargetForResponse"][];
                        }[];
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    findManyOpportunities: {
        parameters: {
            query?: {
                /** @description Format: **field_name_1,field_name_2[DIRECTION_2]
                 *         Refer to the filter section at the top of the page for more details. */
                order_by?: components["parameters"]["orderBy"];
                /** @description Format: field[COMPARATOR]:value,field2[COMPARATOR]:value2
                 *         Refer to the filter section at the top of the page for more details. */
                filter?: components["parameters"]["filter"];
                /** @description Limits the number of objects returned. */
                limit?: components["parameters"]["limit"];
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
                /** @description Returns objects starting after a specific cursor. You can find cursors in **startCursor** and **endCursor** in **pageInfo** in response data */
                starting_after?: components["parameters"]["startingAfter"];
                /** @description Returns objects ending before a specific cursor. You can find cursors in **startCursor** and **endCursor** in **pageInfo** in response data */
                ending_before?: components["parameters"]["endingBefore"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            opportunities?: components["schemas"]["OpportunityForResponse"][];
                        };
                        pageInfo?: {
                            hasNextPage?: boolean;
                            /** Format: uuid */
                            startCursor?: string;
                            /** Format: uuid */
                            endCursor?: string;
                        };
                        totalCount?: number;
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    createOneOpportunity: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description body */
        requestBody: {
            content: {
                "application/json": components["schemas"]["Opportunity"];
            };
        };
        responses: {
            /** @description Successful operation */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            createOpportunity?: components["schemas"]["OpportunityForResponse"];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    createManyOpportunities: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["Opportunity"][];
            };
        };
        responses: {
            /** @description Successful operation */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            createOpportunities?: components["schemas"]["OpportunityForResponse"][];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    findOneOpportunity: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path: {
                /** @description Object id. */
                id: components["parameters"]["idPath"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            opportunity?: components["schemas"]["OpportunityForResponse"];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    deleteOneOpportunity: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Object id. */
                id: components["parameters"]["idPath"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            deleteOpportunity?: {
                                /** Format: uuid */
                                id?: string;
                            };
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    UpdateOneOpportunity: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path: {
                /** @description Object id. */
                id: components["parameters"]["idPath"];
            };
            cookie?: never;
        };
        /** @description body */
        requestBody: {
            content: {
                "application/json": components["schemas"]["OpportunityForUpdate"];
            };
        };
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            updateOpportunity?: components["schemas"]["OpportunityForResponse"];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    findOpportunityDuplicates: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description body */
        requestBody: {
            content: {
                "application/json": {
                    data?: components["schemas"]["Opportunity"][];
                    ids?: string[];
                };
            };
        };
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            totalCount?: number;
                            pageInfo?: {
                                hasNextPage?: boolean;
                                /** Format: uuid */
                                startCursor?: string;
                                /** Format: uuid */
                                endCursor?: string;
                            };
                            opportunityDuplicates?: components["schemas"]["OpportunityForResponse"][];
                        }[];
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    findManyPeople: {
        parameters: {
            query?: {
                /** @description Format: **field_name_1,field_name_2[DIRECTION_2]
                 *         Refer to the filter section at the top of the page for more details. */
                order_by?: components["parameters"]["orderBy"];
                /** @description Format: field[COMPARATOR]:value,field2[COMPARATOR]:value2
                 *         Refer to the filter section at the top of the page for more details. */
                filter?: components["parameters"]["filter"];
                /** @description Limits the number of objects returned. */
                limit?: components["parameters"]["limit"];
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
                /** @description Returns objects starting after a specific cursor. You can find cursors in **startCursor** and **endCursor** in **pageInfo** in response data */
                starting_after?: components["parameters"]["startingAfter"];
                /** @description Returns objects ending before a specific cursor. You can find cursors in **startCursor** and **endCursor** in **pageInfo** in response data */
                ending_before?: components["parameters"]["endingBefore"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            people?: components["schemas"]["PersonForResponse"][];
                        };
                        pageInfo?: {
                            hasNextPage?: boolean;
                            /** Format: uuid */
                            startCursor?: string;
                            /** Format: uuid */
                            endCursor?: string;
                        };
                        totalCount?: number;
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    createOnePerson: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description body */
        requestBody: {
            content: {
                "application/json": components["schemas"]["Person"];
            };
        };
        responses: {
            /** @description Successful operation */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            createPerson?: components["schemas"]["PersonForResponse"];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    createManyPeople: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["Person"][];
            };
        };
        responses: {
            /** @description Successful operation */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            createPeople?: components["schemas"]["PersonForResponse"][];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    findOnePerson: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path: {
                /** @description Object id. */
                id: components["parameters"]["idPath"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            person?: components["schemas"]["PersonForResponse"];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    deleteOnePerson: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Object id. */
                id: components["parameters"]["idPath"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            deletePerson?: {
                                /** Format: uuid */
                                id?: string;
                            };
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    UpdateOnePerson: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path: {
                /** @description Object id. */
                id: components["parameters"]["idPath"];
            };
            cookie?: never;
        };
        /** @description body */
        requestBody: {
            content: {
                "application/json": components["schemas"]["PersonForUpdate"];
            };
        };
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            updatePerson?: components["schemas"]["PersonForResponse"];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    findPersonDuplicates: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description body */
        requestBody: {
            content: {
                "application/json": {
                    data?: components["schemas"]["Person"][];
                    ids?: string[];
                };
            };
        };
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            totalCount?: number;
                            pageInfo?: {
                                hasNextPage?: boolean;
                                /** Format: uuid */
                                startCursor?: string;
                                /** Format: uuid */
                                endCursor?: string;
                            };
                            personDuplicates?: components["schemas"]["PersonForResponse"][];
                        }[];
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    findManyTasks: {
        parameters: {
            query?: {
                /** @description Format: **field_name_1,field_name_2[DIRECTION_2]
                 *         Refer to the filter section at the top of the page for more details. */
                order_by?: components["parameters"]["orderBy"];
                /** @description Format: field[COMPARATOR]:value,field2[COMPARATOR]:value2
                 *         Refer to the filter section at the top of the page for more details. */
                filter?: components["parameters"]["filter"];
                /** @description Limits the number of objects returned. */
                limit?: components["parameters"]["limit"];
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
                /** @description Returns objects starting after a specific cursor. You can find cursors in **startCursor** and **endCursor** in **pageInfo** in response data */
                starting_after?: components["parameters"]["startingAfter"];
                /** @description Returns objects ending before a specific cursor. You can find cursors in **startCursor** and **endCursor** in **pageInfo** in response data */
                ending_before?: components["parameters"]["endingBefore"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            tasks?: components["schemas"]["TaskForResponse"][];
                        };
                        pageInfo?: {
                            hasNextPage?: boolean;
                            /** Format: uuid */
                            startCursor?: string;
                            /** Format: uuid */
                            endCursor?: string;
                        };
                        totalCount?: number;
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    createOneTask: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description body */
        requestBody: {
            content: {
                "application/json": components["schemas"]["Task"];
            };
        };
        responses: {
            /** @description Successful operation */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            createTask?: components["schemas"]["TaskForResponse"];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    createManyTasks: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["Task"][];
            };
        };
        responses: {
            /** @description Successful operation */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            createTasks?: components["schemas"]["TaskForResponse"][];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    findOneTask: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path: {
                /** @description Object id. */
                id: components["parameters"]["idPath"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            task?: components["schemas"]["TaskForResponse"];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    deleteOneTask: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Object id. */
                id: components["parameters"]["idPath"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            deleteTask?: {
                                /** Format: uuid */
                                id?: string;
                            };
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    UpdateOneTask: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path: {
                /** @description Object id. */
                id: components["parameters"]["idPath"];
            };
            cookie?: never;
        };
        /** @description body */
        requestBody: {
            content: {
                "application/json": components["schemas"]["TaskForUpdate"];
            };
        };
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            updateTask?: components["schemas"]["TaskForResponse"];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    findTaskDuplicates: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description body */
        requestBody: {
            content: {
                "application/json": {
                    data?: components["schemas"]["Task"][];
                    ids?: string[];
                };
            };
        };
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            totalCount?: number;
                            pageInfo?: {
                                hasNextPage?: boolean;
                                /** Format: uuid */
                                startCursor?: string;
                                /** Format: uuid */
                                endCursor?: string;
                            };
                            taskDuplicates?: components["schemas"]["TaskForResponse"][];
                        }[];
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    findManyTaskTargets: {
        parameters: {
            query?: {
                /** @description Format: **field_name_1,field_name_2[DIRECTION_2]
                 *         Refer to the filter section at the top of the page for more details. */
                order_by?: components["parameters"]["orderBy"];
                /** @description Format: field[COMPARATOR]:value,field2[COMPARATOR]:value2
                 *         Refer to the filter section at the top of the page for more details. */
                filter?: components["parameters"]["filter"];
                /** @description Limits the number of objects returned. */
                limit?: components["parameters"]["limit"];
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
                /** @description Returns objects starting after a specific cursor. You can find cursors in **startCursor** and **endCursor** in **pageInfo** in response data */
                starting_after?: components["parameters"]["startingAfter"];
                /** @description Returns objects ending before a specific cursor. You can find cursors in **startCursor** and **endCursor** in **pageInfo** in response data */
                ending_before?: components["parameters"]["endingBefore"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            taskTargets?: components["schemas"]["TaskTargetForResponse"][];
                        };
                        pageInfo?: {
                            hasNextPage?: boolean;
                            /** Format: uuid */
                            startCursor?: string;
                            /** Format: uuid */
                            endCursor?: string;
                        };
                        totalCount?: number;
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    createOneTaskTarget: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description body */
        requestBody: {
            content: {
                "application/json": components["schemas"]["TaskTarget"];
            };
        };
        responses: {
            /** @description Successful operation */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            createTaskTarget?: components["schemas"]["TaskTargetForResponse"];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    createManyTaskTargets: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["TaskTarget"][];
            };
        };
        responses: {
            /** @description Successful operation */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            createTaskTargets?: components["schemas"]["TaskTargetForResponse"][];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    findOneTaskTarget: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path: {
                /** @description Object id. */
                id: components["parameters"]["idPath"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            taskTarget?: components["schemas"]["TaskTargetForResponse"];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    deleteOneTaskTarget: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Object id. */
                id: components["parameters"]["idPath"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            deleteTaskTarget?: {
                                /** Format: uuid */
                                id?: string;
                            };
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    UpdateOneTaskTarget: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path: {
                /** @description Object id. */
                id: components["parameters"]["idPath"];
            };
            cookie?: never;
        };
        /** @description body */
        requestBody: {
            content: {
                "application/json": components["schemas"]["TaskTargetForUpdate"];
            };
        };
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            updateTaskTarget?: components["schemas"]["TaskTargetForResponse"];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    findTaskTargetDuplicates: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description body */
        requestBody: {
            content: {
                "application/json": {
                    data?: components["schemas"]["TaskTarget"][];
                    ids?: string[];
                };
            };
        };
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            totalCount?: number;
                            pageInfo?: {
                                hasNextPage?: boolean;
                                /** Format: uuid */
                                startCursor?: string;
                                /** Format: uuid */
                                endCursor?: string;
                            };
                            taskTargetDuplicates?: components["schemas"]["TaskTargetForResponse"][];
                        }[];
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    findManyTimelineActivities: {
        parameters: {
            query?: {
                /** @description Format: **field_name_1,field_name_2[DIRECTION_2]
                 *         Refer to the filter section at the top of the page for more details. */
                order_by?: components["parameters"]["orderBy"];
                /** @description Format: field[COMPARATOR]:value,field2[COMPARATOR]:value2
                 *         Refer to the filter section at the top of the page for more details. */
                filter?: components["parameters"]["filter"];
                /** @description Limits the number of objects returned. */
                limit?: components["parameters"]["limit"];
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
                /** @description Returns objects starting after a specific cursor. You can find cursors in **startCursor** and **endCursor** in **pageInfo** in response data */
                starting_after?: components["parameters"]["startingAfter"];
                /** @description Returns objects ending before a specific cursor. You can find cursors in **startCursor** and **endCursor** in **pageInfo** in response data */
                ending_before?: components["parameters"]["endingBefore"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            timelineActivities?: components["schemas"]["TimelineActivityForResponse"][];
                        };
                        pageInfo?: {
                            hasNextPage?: boolean;
                            /** Format: uuid */
                            startCursor?: string;
                            /** Format: uuid */
                            endCursor?: string;
                        };
                        totalCount?: number;
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    createOneTimelineActivity: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description body */
        requestBody: {
            content: {
                "application/json": components["schemas"]["TimelineActivity"];
            };
        };
        responses: {
            /** @description Successful operation */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            createTimelineActivity?: components["schemas"]["TimelineActivityForResponse"];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    createManyTimelineActivities: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["TimelineActivity"][];
            };
        };
        responses: {
            /** @description Successful operation */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            createTimelineActivities?: components["schemas"]["TimelineActivityForResponse"][];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    findOneTimelineActivity: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path: {
                /** @description Object id. */
                id: components["parameters"]["idPath"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            timelineActivity?: components["schemas"]["TimelineActivityForResponse"];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    deleteOneTimelineActivity: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Object id. */
                id: components["parameters"]["idPath"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            deleteTimelineActivity?: {
                                /** Format: uuid */
                                id?: string;
                            };
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    UpdateOneTimelineActivity: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path: {
                /** @description Object id. */
                id: components["parameters"]["idPath"];
            };
            cookie?: never;
        };
        /** @description body */
        requestBody: {
            content: {
                "application/json": components["schemas"]["TimelineActivityForUpdate"];
            };
        };
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            updateTimelineActivity?: components["schemas"]["TimelineActivityForResponse"];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    findTimelineActivityDuplicates: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description body */
        requestBody: {
            content: {
                "application/json": {
                    data?: components["schemas"]["TimelineActivity"][];
                    ids?: string[];
                };
            };
        };
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            totalCount?: number;
                            pageInfo?: {
                                hasNextPage?: boolean;
                                /** Format: uuid */
                                startCursor?: string;
                                /** Format: uuid */
                                endCursor?: string;
                            };
                            timelineActivityDuplicates?: components["schemas"]["TimelineActivityForResponse"][];
                        }[];
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    findManyViewFields: {
        parameters: {
            query?: {
                /** @description Format: **field_name_1,field_name_2[DIRECTION_2]
                 *         Refer to the filter section at the top of the page for more details. */
                order_by?: components["parameters"]["orderBy"];
                /** @description Format: field[COMPARATOR]:value,field2[COMPARATOR]:value2
                 *         Refer to the filter section at the top of the page for more details. */
                filter?: components["parameters"]["filter"];
                /** @description Limits the number of objects returned. */
                limit?: components["parameters"]["limit"];
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
                /** @description Returns objects starting after a specific cursor. You can find cursors in **startCursor** and **endCursor** in **pageInfo** in response data */
                starting_after?: components["parameters"]["startingAfter"];
                /** @description Returns objects ending before a specific cursor. You can find cursors in **startCursor** and **endCursor** in **pageInfo** in response data */
                ending_before?: components["parameters"]["endingBefore"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            viewFields?: components["schemas"]["ViewFieldForResponse"][];
                        };
                        pageInfo?: {
                            hasNextPage?: boolean;
                            /** Format: uuid */
                            startCursor?: string;
                            /** Format: uuid */
                            endCursor?: string;
                        };
                        totalCount?: number;
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    createOneViewField: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description body */
        requestBody: {
            content: {
                "application/json": components["schemas"]["ViewField"];
            };
        };
        responses: {
            /** @description Successful operation */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            createViewField?: components["schemas"]["ViewFieldForResponse"];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    createManyViewFields: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ViewField"][];
            };
        };
        responses: {
            /** @description Successful operation */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            createViewFields?: components["schemas"]["ViewFieldForResponse"][];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    findOneViewField: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path: {
                /** @description Object id. */
                id: components["parameters"]["idPath"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            viewField?: components["schemas"]["ViewFieldForResponse"];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    deleteOneViewField: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Object id. */
                id: components["parameters"]["idPath"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            deleteViewField?: {
                                /** Format: uuid */
                                id?: string;
                            };
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    UpdateOneViewField: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path: {
                /** @description Object id. */
                id: components["parameters"]["idPath"];
            };
            cookie?: never;
        };
        /** @description body */
        requestBody: {
            content: {
                "application/json": components["schemas"]["ViewFieldForUpdate"];
            };
        };
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            updateViewField?: components["schemas"]["ViewFieldForResponse"];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    findViewFieldDuplicates: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description body */
        requestBody: {
            content: {
                "application/json": {
                    data?: components["schemas"]["ViewField"][];
                    ids?: string[];
                };
            };
        };
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            totalCount?: number;
                            pageInfo?: {
                                hasNextPage?: boolean;
                                /** Format: uuid */
                                startCursor?: string;
                                /** Format: uuid */
                                endCursor?: string;
                            };
                            viewFieldDuplicates?: components["schemas"]["ViewFieldForResponse"][];
                        }[];
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    findManyViewFilterGroups: {
        parameters: {
            query?: {
                /** @description Format: **field_name_1,field_name_2[DIRECTION_2]
                 *         Refer to the filter section at the top of the page for more details. */
                order_by?: components["parameters"]["orderBy"];
                /** @description Format: field[COMPARATOR]:value,field2[COMPARATOR]:value2
                 *         Refer to the filter section at the top of the page for more details. */
                filter?: components["parameters"]["filter"];
                /** @description Limits the number of objects returned. */
                limit?: components["parameters"]["limit"];
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
                /** @description Returns objects starting after a specific cursor. You can find cursors in **startCursor** and **endCursor** in **pageInfo** in response data */
                starting_after?: components["parameters"]["startingAfter"];
                /** @description Returns objects ending before a specific cursor. You can find cursors in **startCursor** and **endCursor** in **pageInfo** in response data */
                ending_before?: components["parameters"]["endingBefore"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            viewFilterGroups?: components["schemas"]["ViewFilterGroupForResponse"][];
                        };
                        pageInfo?: {
                            hasNextPage?: boolean;
                            /** Format: uuid */
                            startCursor?: string;
                            /** Format: uuid */
                            endCursor?: string;
                        };
                        totalCount?: number;
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    createOneViewFilterGroup: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description body */
        requestBody: {
            content: {
                "application/json": components["schemas"]["ViewFilterGroup"];
            };
        };
        responses: {
            /** @description Successful operation */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            createViewFilterGroup?: components["schemas"]["ViewFilterGroupForResponse"];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    createManyViewFilterGroups: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ViewFilterGroup"][];
            };
        };
        responses: {
            /** @description Successful operation */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            createViewFilterGroups?: components["schemas"]["ViewFilterGroupForResponse"][];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    findOneViewFilterGroup: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path: {
                /** @description Object id. */
                id: components["parameters"]["idPath"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            viewFilterGroup?: components["schemas"]["ViewFilterGroupForResponse"];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    deleteOneViewFilterGroup: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Object id. */
                id: components["parameters"]["idPath"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            deleteViewFilterGroup?: {
                                /** Format: uuid */
                                id?: string;
                            };
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    UpdateOneViewFilterGroup: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path: {
                /** @description Object id. */
                id: components["parameters"]["idPath"];
            };
            cookie?: never;
        };
        /** @description body */
        requestBody: {
            content: {
                "application/json": components["schemas"]["ViewFilterGroupForUpdate"];
            };
        };
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            updateViewFilterGroup?: components["schemas"]["ViewFilterGroupForResponse"];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    findViewFilterGroupDuplicates: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description body */
        requestBody: {
            content: {
                "application/json": {
                    data?: components["schemas"]["ViewFilterGroup"][];
                    ids?: string[];
                };
            };
        };
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            totalCount?: number;
                            pageInfo?: {
                                hasNextPage?: boolean;
                                /** Format: uuid */
                                startCursor?: string;
                                /** Format: uuid */
                                endCursor?: string;
                            };
                            viewFilterGroupDuplicates?: components["schemas"]["ViewFilterGroupForResponse"][];
                        }[];
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    findManyViewFilters: {
        parameters: {
            query?: {
                /** @description Format: **field_name_1,field_name_2[DIRECTION_2]
                 *         Refer to the filter section at the top of the page for more details. */
                order_by?: components["parameters"]["orderBy"];
                /** @description Format: field[COMPARATOR]:value,field2[COMPARATOR]:value2
                 *         Refer to the filter section at the top of the page for more details. */
                filter?: components["parameters"]["filter"];
                /** @description Limits the number of objects returned. */
                limit?: components["parameters"]["limit"];
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
                /** @description Returns objects starting after a specific cursor. You can find cursors in **startCursor** and **endCursor** in **pageInfo** in response data */
                starting_after?: components["parameters"]["startingAfter"];
                /** @description Returns objects ending before a specific cursor. You can find cursors in **startCursor** and **endCursor** in **pageInfo** in response data */
                ending_before?: components["parameters"]["endingBefore"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            viewFilters?: components["schemas"]["ViewFilterForResponse"][];
                        };
                        pageInfo?: {
                            hasNextPage?: boolean;
                            /** Format: uuid */
                            startCursor?: string;
                            /** Format: uuid */
                            endCursor?: string;
                        };
                        totalCount?: number;
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    createOneViewFilter: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description body */
        requestBody: {
            content: {
                "application/json": components["schemas"]["ViewFilter"];
            };
        };
        responses: {
            /** @description Successful operation */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            createViewFilter?: components["schemas"]["ViewFilterForResponse"];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    createManyViewFilters: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ViewFilter"][];
            };
        };
        responses: {
            /** @description Successful operation */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            createViewFilters?: components["schemas"]["ViewFilterForResponse"][];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    findOneViewFilter: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path: {
                /** @description Object id. */
                id: components["parameters"]["idPath"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            viewFilter?: components["schemas"]["ViewFilterForResponse"];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    deleteOneViewFilter: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Object id. */
                id: components["parameters"]["idPath"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            deleteViewFilter?: {
                                /** Format: uuid */
                                id?: string;
                            };
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    UpdateOneViewFilter: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path: {
                /** @description Object id. */
                id: components["parameters"]["idPath"];
            };
            cookie?: never;
        };
        /** @description body */
        requestBody: {
            content: {
                "application/json": components["schemas"]["ViewFilterForUpdate"];
            };
        };
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            updateViewFilter?: components["schemas"]["ViewFilterForResponse"];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    findViewFilterDuplicates: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description body */
        requestBody: {
            content: {
                "application/json": {
                    data?: components["schemas"]["ViewFilter"][];
                    ids?: string[];
                };
            };
        };
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            totalCount?: number;
                            pageInfo?: {
                                hasNextPage?: boolean;
                                /** Format: uuid */
                                startCursor?: string;
                                /** Format: uuid */
                                endCursor?: string;
                            };
                            viewFilterDuplicates?: components["schemas"]["ViewFilterForResponse"][];
                        }[];
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    findManyViewGroups: {
        parameters: {
            query?: {
                /** @description Format: **field_name_1,field_name_2[DIRECTION_2]
                 *         Refer to the filter section at the top of the page for more details. */
                order_by?: components["parameters"]["orderBy"];
                /** @description Format: field[COMPARATOR]:value,field2[COMPARATOR]:value2
                 *         Refer to the filter section at the top of the page for more details. */
                filter?: components["parameters"]["filter"];
                /** @description Limits the number of objects returned. */
                limit?: components["parameters"]["limit"];
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
                /** @description Returns objects starting after a specific cursor. You can find cursors in **startCursor** and **endCursor** in **pageInfo** in response data */
                starting_after?: components["parameters"]["startingAfter"];
                /** @description Returns objects ending before a specific cursor. You can find cursors in **startCursor** and **endCursor** in **pageInfo** in response data */
                ending_before?: components["parameters"]["endingBefore"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            viewGroups?: components["schemas"]["ViewGroupForResponse"][];
                        };
                        pageInfo?: {
                            hasNextPage?: boolean;
                            /** Format: uuid */
                            startCursor?: string;
                            /** Format: uuid */
                            endCursor?: string;
                        };
                        totalCount?: number;
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    createOneViewGroup: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description body */
        requestBody: {
            content: {
                "application/json": components["schemas"]["ViewGroup"];
            };
        };
        responses: {
            /** @description Successful operation */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            createViewGroup?: components["schemas"]["ViewGroupForResponse"];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    createManyViewGroups: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ViewGroup"][];
            };
        };
        responses: {
            /** @description Successful operation */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            createViewGroups?: components["schemas"]["ViewGroupForResponse"][];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    findOneViewGroup: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path: {
                /** @description Object id. */
                id: components["parameters"]["idPath"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            viewGroup?: components["schemas"]["ViewGroupForResponse"];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    deleteOneViewGroup: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Object id. */
                id: components["parameters"]["idPath"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            deleteViewGroup?: {
                                /** Format: uuid */
                                id?: string;
                            };
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    UpdateOneViewGroup: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path: {
                /** @description Object id. */
                id: components["parameters"]["idPath"];
            };
            cookie?: never;
        };
        /** @description body */
        requestBody: {
            content: {
                "application/json": components["schemas"]["ViewGroupForUpdate"];
            };
        };
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            updateViewGroup?: components["schemas"]["ViewGroupForResponse"];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    findViewGroupDuplicates: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description body */
        requestBody: {
            content: {
                "application/json": {
                    data?: components["schemas"]["ViewGroup"][];
                    ids?: string[];
                };
            };
        };
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            totalCount?: number;
                            pageInfo?: {
                                hasNextPage?: boolean;
                                /** Format: uuid */
                                startCursor?: string;
                                /** Format: uuid */
                                endCursor?: string;
                            };
                            viewGroupDuplicates?: components["schemas"]["ViewGroupForResponse"][];
                        }[];
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    findManyViews: {
        parameters: {
            query?: {
                /** @description Format: **field_name_1,field_name_2[DIRECTION_2]
                 *         Refer to the filter section at the top of the page for more details. */
                order_by?: components["parameters"]["orderBy"];
                /** @description Format: field[COMPARATOR]:value,field2[COMPARATOR]:value2
                 *         Refer to the filter section at the top of the page for more details. */
                filter?: components["parameters"]["filter"];
                /** @description Limits the number of objects returned. */
                limit?: components["parameters"]["limit"];
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
                /** @description Returns objects starting after a specific cursor. You can find cursors in **startCursor** and **endCursor** in **pageInfo** in response data */
                starting_after?: components["parameters"]["startingAfter"];
                /** @description Returns objects ending before a specific cursor. You can find cursors in **startCursor** and **endCursor** in **pageInfo** in response data */
                ending_before?: components["parameters"]["endingBefore"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            views?: components["schemas"]["ViewForResponse"][];
                        };
                        pageInfo?: {
                            hasNextPage?: boolean;
                            /** Format: uuid */
                            startCursor?: string;
                            /** Format: uuid */
                            endCursor?: string;
                        };
                        totalCount?: number;
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    createOneView: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description body */
        requestBody: {
            content: {
                "application/json": components["schemas"]["View"];
            };
        };
        responses: {
            /** @description Successful operation */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            createView?: components["schemas"]["ViewForResponse"];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    createManyViews: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["View"][];
            };
        };
        responses: {
            /** @description Successful operation */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            createViews?: components["schemas"]["ViewForResponse"][];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    findOneView: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path: {
                /** @description Object id. */
                id: components["parameters"]["idPath"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            view?: components["schemas"]["ViewForResponse"];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    deleteOneView: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Object id. */
                id: components["parameters"]["idPath"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            deleteView?: {
                                /** Format: uuid */
                                id?: string;
                            };
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    UpdateOneView: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path: {
                /** @description Object id. */
                id: components["parameters"]["idPath"];
            };
            cookie?: never;
        };
        /** @description body */
        requestBody: {
            content: {
                "application/json": components["schemas"]["ViewForUpdate"];
            };
        };
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            updateView?: components["schemas"]["ViewForResponse"];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    findViewDuplicates: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description body */
        requestBody: {
            content: {
                "application/json": {
                    data?: components["schemas"]["View"][];
                    ids?: string[];
                };
            };
        };
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            totalCount?: number;
                            pageInfo?: {
                                hasNextPage?: boolean;
                                /** Format: uuid */
                                startCursor?: string;
                                /** Format: uuid */
                                endCursor?: string;
                            };
                            viewDuplicates?: components["schemas"]["ViewForResponse"][];
                        }[];
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    findManyViewSorts: {
        parameters: {
            query?: {
                /** @description Format: **field_name_1,field_name_2[DIRECTION_2]
                 *         Refer to the filter section at the top of the page for more details. */
                order_by?: components["parameters"]["orderBy"];
                /** @description Format: field[COMPARATOR]:value,field2[COMPARATOR]:value2
                 *         Refer to the filter section at the top of the page for more details. */
                filter?: components["parameters"]["filter"];
                /** @description Limits the number of objects returned. */
                limit?: components["parameters"]["limit"];
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
                /** @description Returns objects starting after a specific cursor. You can find cursors in **startCursor** and **endCursor** in **pageInfo** in response data */
                starting_after?: components["parameters"]["startingAfter"];
                /** @description Returns objects ending before a specific cursor. You can find cursors in **startCursor** and **endCursor** in **pageInfo** in response data */
                ending_before?: components["parameters"]["endingBefore"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            viewSorts?: components["schemas"]["ViewSortForResponse"][];
                        };
                        pageInfo?: {
                            hasNextPage?: boolean;
                            /** Format: uuid */
                            startCursor?: string;
                            /** Format: uuid */
                            endCursor?: string;
                        };
                        totalCount?: number;
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    createOneViewSort: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description body */
        requestBody: {
            content: {
                "application/json": components["schemas"]["ViewSort"];
            };
        };
        responses: {
            /** @description Successful operation */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            createViewSort?: components["schemas"]["ViewSortForResponse"];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    createManyViewSorts: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ViewSort"][];
            };
        };
        responses: {
            /** @description Successful operation */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            createViewSorts?: components["schemas"]["ViewSortForResponse"][];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    findOneViewSort: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path: {
                /** @description Object id. */
                id: components["parameters"]["idPath"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            viewSort?: components["schemas"]["ViewSortForResponse"];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    deleteOneViewSort: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Object id. */
                id: components["parameters"]["idPath"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            deleteViewSort?: {
                                /** Format: uuid */
                                id?: string;
                            };
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    UpdateOneViewSort: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path: {
                /** @description Object id. */
                id: components["parameters"]["idPath"];
            };
            cookie?: never;
        };
        /** @description body */
        requestBody: {
            content: {
                "application/json": components["schemas"]["ViewSortForUpdate"];
            };
        };
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            updateViewSort?: components["schemas"]["ViewSortForResponse"];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    findViewSortDuplicates: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description body */
        requestBody: {
            content: {
                "application/json": {
                    data?: components["schemas"]["ViewSort"][];
                    ids?: string[];
                };
            };
        };
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            totalCount?: number;
                            pageInfo?: {
                                hasNextPage?: boolean;
                                /** Format: uuid */
                                startCursor?: string;
                                /** Format: uuid */
                                endCursor?: string;
                            };
                            viewSortDuplicates?: components["schemas"]["ViewSortForResponse"][];
                        }[];
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    findManyWorkflowAutomatedTriggers: {
        parameters: {
            query?: {
                /** @description Format: **field_name_1,field_name_2[DIRECTION_2]
                 *         Refer to the filter section at the top of the page for more details. */
                order_by?: components["parameters"]["orderBy"];
                /** @description Format: field[COMPARATOR]:value,field2[COMPARATOR]:value2
                 *         Refer to the filter section at the top of the page for more details. */
                filter?: components["parameters"]["filter"];
                /** @description Limits the number of objects returned. */
                limit?: components["parameters"]["limit"];
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
                /** @description Returns objects starting after a specific cursor. You can find cursors in **startCursor** and **endCursor** in **pageInfo** in response data */
                starting_after?: components["parameters"]["startingAfter"];
                /** @description Returns objects ending before a specific cursor. You can find cursors in **startCursor** and **endCursor** in **pageInfo** in response data */
                ending_before?: components["parameters"]["endingBefore"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            workflowAutomatedTriggers?: components["schemas"]["WorkflowAutomatedTriggerForResponse"][];
                        };
                        pageInfo?: {
                            hasNextPage?: boolean;
                            /** Format: uuid */
                            startCursor?: string;
                            /** Format: uuid */
                            endCursor?: string;
                        };
                        totalCount?: number;
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    createOneWorkflowAutomatedTrigger: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description body */
        requestBody: {
            content: {
                "application/json": components["schemas"]["WorkflowAutomatedTrigger"];
            };
        };
        responses: {
            /** @description Successful operation */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            createWorkflowAutomatedTrigger?: components["schemas"]["WorkflowAutomatedTriggerForResponse"];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    createManyWorkflowAutomatedTriggers: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["WorkflowAutomatedTrigger"][];
            };
        };
        responses: {
            /** @description Successful operation */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            createWorkflowAutomatedTriggers?: components["schemas"]["WorkflowAutomatedTriggerForResponse"][];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    findOneWorkflowAutomatedTrigger: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path: {
                /** @description Object id. */
                id: components["parameters"]["idPath"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            workflowAutomatedTrigger?: components["schemas"]["WorkflowAutomatedTriggerForResponse"];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    deleteOneWorkflowAutomatedTrigger: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Object id. */
                id: components["parameters"]["idPath"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            deleteWorkflowAutomatedTrigger?: {
                                /** Format: uuid */
                                id?: string;
                            };
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    UpdateOneWorkflowAutomatedTrigger: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path: {
                /** @description Object id. */
                id: components["parameters"]["idPath"];
            };
            cookie?: never;
        };
        /** @description body */
        requestBody: {
            content: {
                "application/json": components["schemas"]["WorkflowAutomatedTriggerForUpdate"];
            };
        };
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            updateWorkflowAutomatedTrigger?: components["schemas"]["WorkflowAutomatedTriggerForResponse"];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    findWorkflowAutomatedTriggerDuplicates: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description body */
        requestBody: {
            content: {
                "application/json": {
                    data?: components["schemas"]["WorkflowAutomatedTrigger"][];
                    ids?: string[];
                };
            };
        };
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            totalCount?: number;
                            pageInfo?: {
                                hasNextPage?: boolean;
                                /** Format: uuid */
                                startCursor?: string;
                                /** Format: uuid */
                                endCursor?: string;
                            };
                            workflowAutomatedTriggerDuplicates?: components["schemas"]["WorkflowAutomatedTriggerForResponse"][];
                        }[];
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    findManyWorkflowRuns: {
        parameters: {
            query?: {
                /** @description Format: **field_name_1,field_name_2[DIRECTION_2]
                 *         Refer to the filter section at the top of the page for more details. */
                order_by?: components["parameters"]["orderBy"];
                /** @description Format: field[COMPARATOR]:value,field2[COMPARATOR]:value2
                 *         Refer to the filter section at the top of the page for more details. */
                filter?: components["parameters"]["filter"];
                /** @description Limits the number of objects returned. */
                limit?: components["parameters"]["limit"];
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
                /** @description Returns objects starting after a specific cursor. You can find cursors in **startCursor** and **endCursor** in **pageInfo** in response data */
                starting_after?: components["parameters"]["startingAfter"];
                /** @description Returns objects ending before a specific cursor. You can find cursors in **startCursor** and **endCursor** in **pageInfo** in response data */
                ending_before?: components["parameters"]["endingBefore"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            workflowRuns?: components["schemas"]["WorkflowRunForResponse"][];
                        };
                        pageInfo?: {
                            hasNextPage?: boolean;
                            /** Format: uuid */
                            startCursor?: string;
                            /** Format: uuid */
                            endCursor?: string;
                        };
                        totalCount?: number;
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    createOneWorkflowRun: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description body */
        requestBody: {
            content: {
                "application/json": components["schemas"]["WorkflowRun"];
            };
        };
        responses: {
            /** @description Successful operation */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            createWorkflowRun?: components["schemas"]["WorkflowRunForResponse"];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    createManyWorkflowRuns: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["WorkflowRun"][];
            };
        };
        responses: {
            /** @description Successful operation */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            createWorkflowRuns?: components["schemas"]["WorkflowRunForResponse"][];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    findOneWorkflowRun: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path: {
                /** @description Object id. */
                id: components["parameters"]["idPath"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            workflowRun?: components["schemas"]["WorkflowRunForResponse"];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    deleteOneWorkflowRun: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Object id. */
                id: components["parameters"]["idPath"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            deleteWorkflowRun?: {
                                /** Format: uuid */
                                id?: string;
                            };
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    UpdateOneWorkflowRun: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path: {
                /** @description Object id. */
                id: components["parameters"]["idPath"];
            };
            cookie?: never;
        };
        /** @description body */
        requestBody: {
            content: {
                "application/json": components["schemas"]["WorkflowRunForUpdate"];
            };
        };
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            updateWorkflowRun?: components["schemas"]["WorkflowRunForResponse"];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    findWorkflowRunDuplicates: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description body */
        requestBody: {
            content: {
                "application/json": {
                    data?: components["schemas"]["WorkflowRun"][];
                    ids?: string[];
                };
            };
        };
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            totalCount?: number;
                            pageInfo?: {
                                hasNextPage?: boolean;
                                /** Format: uuid */
                                startCursor?: string;
                                /** Format: uuid */
                                endCursor?: string;
                            };
                            workflowRunDuplicates?: components["schemas"]["WorkflowRunForResponse"][];
                        }[];
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    findManyWorkflows: {
        parameters: {
            query?: {
                /** @description Format: **field_name_1,field_name_2[DIRECTION_2]
                 *         Refer to the filter section at the top of the page for more details. */
                order_by?: components["parameters"]["orderBy"];
                /** @description Format: field[COMPARATOR]:value,field2[COMPARATOR]:value2
                 *         Refer to the filter section at the top of the page for more details. */
                filter?: components["parameters"]["filter"];
                /** @description Limits the number of objects returned. */
                limit?: components["parameters"]["limit"];
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
                /** @description Returns objects starting after a specific cursor. You can find cursors in **startCursor** and **endCursor** in **pageInfo** in response data */
                starting_after?: components["parameters"]["startingAfter"];
                /** @description Returns objects ending before a specific cursor. You can find cursors in **startCursor** and **endCursor** in **pageInfo** in response data */
                ending_before?: components["parameters"]["endingBefore"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            workflows?: components["schemas"]["WorkflowForResponse"][];
                        };
                        pageInfo?: {
                            hasNextPage?: boolean;
                            /** Format: uuid */
                            startCursor?: string;
                            /** Format: uuid */
                            endCursor?: string;
                        };
                        totalCount?: number;
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    createOneWorkflow: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description body */
        requestBody: {
            content: {
                "application/json": components["schemas"]["Workflow"];
            };
        };
        responses: {
            /** @description Successful operation */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            createWorkflow?: components["schemas"]["WorkflowForResponse"];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    createManyWorkflows: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["Workflow"][];
            };
        };
        responses: {
            /** @description Successful operation */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            createWorkflows?: components["schemas"]["WorkflowForResponse"][];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    findOneWorkflow: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path: {
                /** @description Object id. */
                id: components["parameters"]["idPath"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            workflow?: components["schemas"]["WorkflowForResponse"];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    deleteOneWorkflow: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Object id. */
                id: components["parameters"]["idPath"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            deleteWorkflow?: {
                                /** Format: uuid */
                                id?: string;
                            };
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    UpdateOneWorkflow: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path: {
                /** @description Object id. */
                id: components["parameters"]["idPath"];
            };
            cookie?: never;
        };
        /** @description body */
        requestBody: {
            content: {
                "application/json": components["schemas"]["WorkflowForUpdate"];
            };
        };
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            updateWorkflow?: components["schemas"]["WorkflowForResponse"];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    findWorkflowDuplicates: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description body */
        requestBody: {
            content: {
                "application/json": {
                    data?: components["schemas"]["Workflow"][];
                    ids?: string[];
                };
            };
        };
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            totalCount?: number;
                            pageInfo?: {
                                hasNextPage?: boolean;
                                /** Format: uuid */
                                startCursor?: string;
                                /** Format: uuid */
                                endCursor?: string;
                            };
                            workflowDuplicates?: components["schemas"]["WorkflowForResponse"][];
                        }[];
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    findManyWorkflowVersions: {
        parameters: {
            query?: {
                /** @description Format: **field_name_1,field_name_2[DIRECTION_2]
                 *         Refer to the filter section at the top of the page for more details. */
                order_by?: components["parameters"]["orderBy"];
                /** @description Format: field[COMPARATOR]:value,field2[COMPARATOR]:value2
                 *         Refer to the filter section at the top of the page for more details. */
                filter?: components["parameters"]["filter"];
                /** @description Limits the number of objects returned. */
                limit?: components["parameters"]["limit"];
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
                /** @description Returns objects starting after a specific cursor. You can find cursors in **startCursor** and **endCursor** in **pageInfo** in response data */
                starting_after?: components["parameters"]["startingAfter"];
                /** @description Returns objects ending before a specific cursor. You can find cursors in **startCursor** and **endCursor** in **pageInfo** in response data */
                ending_before?: components["parameters"]["endingBefore"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            workflowVersions?: components["schemas"]["WorkflowVersionForResponse"][];
                        };
                        pageInfo?: {
                            hasNextPage?: boolean;
                            /** Format: uuid */
                            startCursor?: string;
                            /** Format: uuid */
                            endCursor?: string;
                        };
                        totalCount?: number;
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    createOneWorkflowVersion: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description body */
        requestBody: {
            content: {
                "application/json": components["schemas"]["WorkflowVersion"];
            };
        };
        responses: {
            /** @description Successful operation */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            createWorkflowVersion?: components["schemas"]["WorkflowVersionForResponse"];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    createManyWorkflowVersions: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["WorkflowVersion"][];
            };
        };
        responses: {
            /** @description Successful operation */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            createWorkflowVersions?: components["schemas"]["WorkflowVersionForResponse"][];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    findOneWorkflowVersion: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path: {
                /** @description Object id. */
                id: components["parameters"]["idPath"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            workflowVersion?: components["schemas"]["WorkflowVersionForResponse"];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    deleteOneWorkflowVersion: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Object id. */
                id: components["parameters"]["idPath"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            deleteWorkflowVersion?: {
                                /** Format: uuid */
                                id?: string;
                            };
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    UpdateOneWorkflowVersion: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path: {
                /** @description Object id. */
                id: components["parameters"]["idPath"];
            };
            cookie?: never;
        };
        /** @description body */
        requestBody: {
            content: {
                "application/json": components["schemas"]["WorkflowVersionForUpdate"];
            };
        };
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            updateWorkflowVersion?: components["schemas"]["WorkflowVersionForResponse"];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    findWorkflowVersionDuplicates: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description body */
        requestBody: {
            content: {
                "application/json": {
                    data?: components["schemas"]["WorkflowVersion"][];
                    ids?: string[];
                };
            };
        };
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            totalCount?: number;
                            pageInfo?: {
                                hasNextPage?: boolean;
                                /** Format: uuid */
                                startCursor?: string;
                                /** Format: uuid */
                                endCursor?: string;
                            };
                            workflowVersionDuplicates?: components["schemas"]["WorkflowVersionForResponse"][];
                        }[];
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    findManyWorkspaceMembers: {
        parameters: {
            query?: {
                /** @description Format: **field_name_1,field_name_2[DIRECTION_2]
                 *         Refer to the filter section at the top of the page for more details. */
                order_by?: components["parameters"]["orderBy"];
                /** @description Format: field[COMPARATOR]:value,field2[COMPARATOR]:value2
                 *         Refer to the filter section at the top of the page for more details. */
                filter?: components["parameters"]["filter"];
                /** @description Limits the number of objects returned. */
                limit?: components["parameters"]["limit"];
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
                /** @description Returns objects starting after a specific cursor. You can find cursors in **startCursor** and **endCursor** in **pageInfo** in response data */
                starting_after?: components["parameters"]["startingAfter"];
                /** @description Returns objects ending before a specific cursor. You can find cursors in **startCursor** and **endCursor** in **pageInfo** in response data */
                ending_before?: components["parameters"]["endingBefore"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            workspaceMembers?: components["schemas"]["WorkspaceMemberForResponse"][];
                        };
                        pageInfo?: {
                            hasNextPage?: boolean;
                            /** Format: uuid */
                            startCursor?: string;
                            /** Format: uuid */
                            endCursor?: string;
                        };
                        totalCount?: number;
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    createOneWorkspaceMember: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description body */
        requestBody: {
            content: {
                "application/json": components["schemas"]["WorkspaceMember"];
            };
        };
        responses: {
            /** @description Successful operation */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            createWorkspaceMember?: components["schemas"]["WorkspaceMemberForResponse"];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    createManyWorkspaceMembers: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["WorkspaceMember"][];
            };
        };
        responses: {
            /** @description Successful operation */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            createWorkspaceMembers?: components["schemas"]["WorkspaceMemberForResponse"][];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    findOneWorkspaceMember: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path: {
                /** @description Object id. */
                id: components["parameters"]["idPath"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            workspaceMember?: components["schemas"]["WorkspaceMemberForResponse"];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    deleteOneWorkspaceMember: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Object id. */
                id: components["parameters"]["idPath"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            deleteWorkspaceMember?: {
                                /** Format: uuid */
                                id?: string;
                            };
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    UpdateOneWorkspaceMember: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path: {
                /** @description Object id. */
                id: components["parameters"]["idPath"];
            };
            cookie?: never;
        };
        /** @description body */
        requestBody: {
            content: {
                "application/json": components["schemas"]["WorkspaceMemberForUpdate"];
            };
        };
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            updateWorkspaceMember?: components["schemas"]["WorkspaceMemberForResponse"];
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
    findWorkspaceMemberDuplicates: {
        parameters: {
            query?: {
                /** @description Determines the level of nested related objects to include in the response.
                 *         - 0: Primary object only
                 *         - 1: Primary object + direct relations
                 *         - 2: Primary object + direct relations + nested relations */
                depth?: components["parameters"]["depth"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description body */
        requestBody: {
            content: {
                "application/json": {
                    data?: components["schemas"]["WorkspaceMember"][];
                    ids?: string[];
                };
            };
        };
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            totalCount?: number;
                            pageInfo?: {
                                hasNextPage?: boolean;
                                /** Format: uuid */
                                startCursor?: string;
                                /** Format: uuid */
                                endCursor?: string;
                            };
                            workspaceMemberDuplicates?: components["schemas"]["WorkspaceMemberForResponse"][];
                        }[];
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
        };
    };
}
